<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>windseek</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><link href=/index.xml rel=alternate type=application/rss+xml title=windseek><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div class=blog-index><article><header><p class=meta>Apr 7, 2023
- 1 minute read
- <a href=https://scottlx.github.io/posts/contiv-memif/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/contiv-memif/>contiv memif</a></h1></header><p>contiv memif contiv的cni与device plugin相结合，实现了：
Pod能同时接入不止一张网卡 Pod接入的网卡可以是tap，veth，memif devicePlugin Device Plugin实际是一个运行在Kubelet所在的Node上的gRPC server，通过Unix Socket、基于以下（简化的）API来和Kubelet的gRPC server通信，并维护对应设备资源在当前Node上的注册、发现、分配、卸载。 其中，ListAndWatch()负责对应设备资源的discovery和watch；Allocate()负责设备资源的分配。
Insight kubelet kubelet接收上图格式的API。API中的annotations定义了pod的网卡个数与类型，resources中定义了所需要的device plugin的资源，也就是memif。
kubelet执行常规的syncPod流程，调用contiv cni创建网络。此时会在请求中将annotation传递给cni。
同时，agent的DevicePluginServer会向kubelet注册rpc服务，注册contivpp.io/memif的设备资源，从而kubelet的device manager会grpc请求DevicePluginServer获取contivpp.io/memif设备资源。
cni cni实现了github.com/containernetworking/cni标准的add和del接口。实际上做的事情只是将cni请求转换为了对agent的grpc请求：解析args，并通过grpc调用agent的接口发送cniRequest，再根据grpc的返回结果，将结果再次转换成标准cni接口的返回格式
Agent podmanager podmanager实现了上述cni调用的grpc server，主要任务是将cni的request转换为内部的event数据格式，供event loop处理。
request是cni定义的请求数据类型，详见https://github.com/containernetworking/cni/blob/master/SPEC.md#parameters
event则是agent内部的关于pod事务模型，类似原生kvScheduler的针对vpp api的transaction。每一种event都会对应一个plugin去实现他的handler，供event loop调用。
event loop event loop是整个contiv agent的核心处理逻辑，北向对接event queue，南向调用各个EventHandler，将event转换为kvScheduler的事务。
执行了以下步骤：
对事件的预处理，包括校验，判断事件类型，加载必要的配置等 判断是否是更新的事件 对事件的handler进行排序，并生成正向或回退的handler顺序 与本次事件无关的handler过滤掉 创建对这次事件的记录record 打印上述步骤生成的所有事件相关信息 执行事件更新或同步，生成vpp-agent里的事务 将contiv生成的配置与外部配置进行merge，得到最终配置 将最终配置的vpp-agent事务commit到agent的kvscheduler 若事务失败，将已经完成的操作进行回退 完成事件，输出记录record与计时 打印回退失败等不可恢复的异常 若开启一致性检查，则最好再执行一次同步校验 devicemanager devicemanager既实现了对接kublet的DevicePluginServer，又实现了AllocateDevice类型的event的handler。换句话说是自己产生并处理自己的event。
主要业务逻辑：
创建memif socket文件的目录并挂载至容器
创建连接socket的secret。
上述的创建并不是真实的创建，而是把需要的信息(event.Envs, event.Annotations, event.Mounts)通过grpc返回给kublet，让kubelet去创建。
devicemanager还会将上述memif的信息保存在缓存中，供其他插件来获取。若缓存中信息不存在，则会调用kubelet的api获取信息。
ipNet ipNet插件主要负责node和pod中各类网卡的创建销毁，vxlan的分配，vrf的分配等
更新网卡时，ipnet会读取annotation中kv，判断网卡类型。若类型为memif，则会向deviceManager获取当前pod里各容器的memifInfo，之后根据memifInfo里的socket地址和secret，创建memif类型的网卡事务，并 push 至kvscheduler</p></article><article><header><p class=meta>Mar 20, 2023
- 2 minute read
- <a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/>数位dp</a></h1></header><p>题目特征 要求统计满足一定条件的数的数量（即，最终目的为计数，若要结果则只能回溯爆搜得到）；
这些条件经过转化后可以使用「数位」的思想去理解和判断；
输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；
上界很大（比如 10^{18}），暴力枚举验证会超时。
思路 从高到低枚举每一位，统计符合target的个数，并记录到dp数组中。枚举完毕之后则得到答案。
因此数位dp的第一个状态都是数位的位置，第二个状态由题意来定
模板 以leetcode1012为例，统计小于等于n的数字中每一位的数字至少重复一次的个数。
模板时灵神的模板。难点主要是mask，isLimit，isNum这几个标识
mask即dp的第二个状态，这边用到了状态压缩的思想，将0到9选过的状态压缩成一个数字(否则要10个状态) isLimit 标识了本次(i)选择的范围，是否受到n的影响。如果不引进这个变量，则需要考虑当前数字的最高位来决定本次的范围(最高位==n的最高位时，本次的范围是[0,s[i]],最高位&lt;n的最高位时，本次的范围是[0,9])。可以发现这个限制是有传递的性质的，因此引入这个变量能简化范围的选择过程。 isNum 标识了本次(i)之前是否有数字，换句话说本次(i)是否是第一个数字(最高位)。这个标识主要是解决前导0的问题，否则答案里会重复(前导两个0和前导三个0虽然是同个数字，但都会被记入答案) func numDupDigitsAtMostN(n int) (ans int) { s := strconv.Itoa(n) // s[0]是最高位 /* 若需要从低到高的顺序，则按如下生成 for ; n > 0; n = n / 10 { list = append(list, n%10) } */ m := len(s) dp := make([][1 &lt;&lt; 10]int, m) // 数位dp的第一个状态都是数位的位置，第二个状态由题意来定 // 问题转换为计算没有重复数字的个数，因此第二个状态记录已经选过数字的集合 // i 表示从高到低第i位， j是前面已经选过的数字的集合,最大为[0,9]的子集个数 // 例如集合 {0,2,3} 对应的二进制数为 1101 （集合的思想就是状压） for i := range dp { for j := range dp[i] { dp[i][j] = -1 // -1 表示没有计算过 } } var f func(int, int, bool, bool) int // mask是dp数组中第二个状态 // isLimit表示当前是否受到n的约束，若为true表示当前位最大填s[i] // 若isLimit为true时填了s[i],则isLimit为true传递到下一位，下一位也受到n的约束 // isNum主要是处理前导零的问题。isNum表示i前面是否填了数字 // 若isNum为true，则i位可以从0开始填；否则，说明i是第一位，i可以不填，或者至少填1(因为不能有前导0) f = func(i, mask int, isLimit, isNum bool) (res int) { if i == m { // base case，遍历完毕 if isNum { // 且不是全部跳过不选的 return 1 // 得到了一个合法数字 } return } if !</p><footer><a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 28, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/>raft选举流程</a></h1></header><p>图解 Raft (thesecretlivesofdata.com)
算法目的：实现了分布式节点的数据一致性
节点有三个状态：follower，candidate，leader
leader election 初始阶段所有节点处于follower状态
follower状态下节点存在一个election timeout（150ms—300ms之间的随机数，随机降低了多个节点同时升级为candidate的可能性），election timeout内没有收到leader的heartbeat后，会自动升级为candidate状态，并开始一个新的election term。term是全局的，表示整个集群发生过选举的轮次(任期)。
candidate状态下，节点会向集群内所有节点发送requests votes请求。其他节点收到requests votes请求后，如果在本次term内还没有投过票，则会返回选票，如果candidate收到的选票占集群节点的大多数，则升级为本次term的leader节点。升级为leader之后向他的follower 发送append entries消息（也就是包含entry消息的心跳），follower也会返回消息的response，系统正常情况下维持在该状态
如果选举时，在一个term内发生了两个节点有同样的选票，会在超时过后进入下一轮进行重新选举
log replication client的请求只会发往leader。leader收到改动后，将改动写入日志（还未持久化commit），并将改动通过heartbeat广播至follower节点。follower节点写了entry之后（此时还未commit），返回ack。leader收到大于集群节点一半的ack之后，认为已经可以commit了，广播commit的通知。最终集群内所有follower触发commit，向leader返回ack。最后leader认为集群已经达成一致性了，向client返回ack
如果集群中产生网络隔离，每个隔离域中会产生一个新的leader，整个集群会存在多个leader。follower少的leader由于获取不到majority ack，他的entry不会被commit。此时client往另一个follower多的leader发送数据改变请求，该隔离域的节点会被commit
此时去掉网络隔离后，之前follower少的隔离域内未commit的entry会被刷成之前follower多的隔离域的entry,随后commit，此时集群再次达成一致性</p></article><article><header><p class=meta>Oct 28, 2022
- 8 minute read
- <a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90/>问题分析</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/>etcd client v3 连接流程</a></h1></header><p>首先需要了解grpc框架的一些概念，这边引用网上的一张图 Resolver 提供一个用户自定义的解析、修改地址的方法，使得用户可以自己去实现地址解析的逻辑、做服务发现、地址更新等等功能。
将Endpoints里的ETCD服务器地址(127.0.0.1:2379这种格式)做一次转换传给grpc框架。也可以自己重新写此resolver，做服务发现功能。例如etcd服务器地址写nacos之类的地址，在resolver中写好转换逻辑。 调用ClientConn的ParseServiceConfig接口告诉endpoints的负载策略是轮询 Balancer 管理subConns，并收集各conn信息，更新状态至ClientConn 生成picker(balancer)的快照，从而ClientConn可以选择发送rpc请求的subConn 此处etcd client没有实现balancer，默认使用grpc提供的轮询的balancer
重试策略 与一般的c-s模型不同，etcd client的重试是针对集群的重试。单个节点的断连不会造成所有节点的重连。
重试机制 一般的重试是对同一个节点进行重试，但etcd client的自动重试不会在ETCD集群的同一节点上进行，是轮询重试集群的每个节点。重试时不会重新建连，而是使用balancer提供的transport。transport的状态更新与这一块的重试是通过balancer解耦的。
重试条件 etcd unary拦截器 拦截器类似http里的中间件的概念，在发送实际请求之前对报文进行篡改。一般用来添加认证，日志记录，缓存之类的功能。
此处etcd的一元拦截器主要做了自动重试的功能，且只会重试一些特定的错误(DeadlineExceeded, Canceled,ErrInvalidAuthToken)
func (c *Client) unaryClientInterceptor(optFuncs ...retryOption) grpc.UnaryClientInterceptor { ... if isContextError(lastErr) { if ctx.Err() != nil { // its the context deadline or cancellation. return lastErr } // its the callCtx deadline or cancellation, in which case try again. continue } if callOpts.retryAuth && rpctypes.Error(lastErr) == rpctypes.ErrInvalidAuthToken { // clear auth token before refreshing it.</p><footer><a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 13, 2022
- 3 minute read
- <a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/>单调栈</a></h1></header><p>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。
标准模板 第一个for循环内循环输入数组， 第二个for循环维持栈内单调特性，不满足单调的元素依次出栈 第一个for循环内对元素入栈 496. 下一个更大元素 I 直接输入出栈元素即可
func nextGreaterElement(nums1 []int, nums2 []int) []int { //单调递减栈 var stack,res []int //标准模板，首个元素先入栈 stack = append(stack, 0) //由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询 map1 := make(map[int]int) for i,v := range(nums1) { map1[v] = i //顺便初始化res，查不到的为-1 res = append(res, -1) } for i:=1; i &lt; len(nums2); i++ { // 单调递减，所以>=的都出栈 for len(stack) > 0 && nums2[stack[len(stack)-1]] &lt;= nums2[i] { // 查表，需要输出的加入res if idx, ok := map1[nums2[stack[len(stack)-1]]]; ok { res[idx] = nums2[i] } //pop stack = stack[:len(stack)-1] } // push stack = append(stack, i) } return res } 42.</p><footer><a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 12, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/>拓扑排序(选课)</a></h1></header><p>207. 课程表 - 力扣（LeetCode）
思路 课程之间的依赖关系可以用图来表示
顶点：课程 边：有向的边，起点是前置课程，终点是后置课程 这种图叫做AOV（Activity On Vertex）网络，字面意思就是边代表了节点之间的活动的先后关系。
按照题意，这个图是无环的（课程不能循环依赖），也就是DAG图。DAG图其实就是一颗树，只不过根节点是一个虚拟根节点（可以有多个起始根节点，但外面可以用一个虚拟根节点作为他们的父节点）。
因此，可以用广度优先遍历（BFS）来求解。队列存放可以选的课程（入度为0），依次出队列（选课）。直到队列为空（没有课可以选了），看是否已经学完所有的课程
入度：指向自己的边的数量，入度为0表示自己没有前置课程，可以入队列 出度：指向别人的边。用一个数据结构记录每个节点的出度列表。当某个节点出队列时，更新本节点的出度列表里所有节点的入度（-1） 代码 func canFinish(numCourses int, prerequisites [][]int) bool { //保存各课程的入度 空间O(v) indegree := make([]int, numCourses) // 保存各课程的出度列表 空间O(e) courseMp := make(map[int][]int) //时间 O(e) for _, pre := range(prerequisites) { indegree[pre[0]]++ courseMp[pre[1]] = append(courseMp[pre[1]], pre[0]) } var q []int // 已经学习了的课程的计数 var num int // 初始入度为0的课程加入队列 for course, depends := range(indegree) { if depends == 0 { q = append(q, course) } } //循环直到队列为空 时间O(v) for len(q) > 0 { // 出队列 finished := q[0] q = q[1:] num++ // 更新入度数据结构(slice) // 从出度课程列表中直接取受影响的课程 for _, course := range(courseMp[finished]) { indegree[course]-- // 入度-1后若为0，则可以入队列 if indegree[course] == 0 { q = append(q, course) } } } //是否学完 return num == numCourses } 时间复杂度：O (v+e) 空间复杂度: O(v+e) 若需要省空间，不需要省时间，可以不使用courseMp存放出度数组，每次重新遍历prerequisites 获取出度数组。此时处理每个节点都需要重新遍历所有的边，因此：</p><footer><a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 8, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/>优势洗牌(田忌赛马)</a></h1></header><p>870. 优势洗牌 - 力扣（LeetCode）
思路 将nums1(自己的马)进行升序排序，得到下等马->上等马的序列 贪心策略 若某个位置上自己的马比对手的马强，由于已经排过序了，已经是最下等的马了，因此使用这匹马 若某个位置上自己的马比对手的马弱，将该下等马放到最后的位置（对手的上等马的位置） 由于nums2的顺序固定（已知对手上场顺序），因此使用nums2的元素值对nums2的index进行排序，得到上场顺序（ids） 按照上场顺序(ids)依次写入ans数组中 代码 func advantageCount(nums1 []int, nums2 []int) []int { sort.Ints(nums1) n := len(nums1) ans := make([]int, n) ids := make([]int, n) for i := 0; i &lt; n; i++ { ids[i] = i } sort.Slice(ids, func(i, j int) bool { return nums2[ids[i]] &lt; nums2[ids[j]] }) left, right := 0, n-1 for _, v := range nums1 { if v > nums2[ids[left]] { ans[ids[left]] = v left++ } else { ans[ids[right]] = v right-- } } return ans } 总结 灵活运用不对数组进行真正的排序，而是获得排序后的index的顺序这一技巧</p></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>k8s源码分析</a></h1></header><p>API Server Controller Device Plugin Informer Kube Proxy Pod Create Schduler(V1.13)</p></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redisserver/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redisserver/>redis Server</a></h1></header><p>数据库切换 默认会创建16个数据库，客户端通过select选取。但一般情况只用第0个数据库，切换容易导致误操作
typedef struct redisDb { dict *dict; //键空间 dict *expires; //过期字典 int id; } redisDb; 所有键空间存储在redisDb的dict中，称为key space
每个键是字符串对象，值是各种对象
读写键操作 更新keyspace_hits和keyspace_misses，用来输出统计数据 更新键的LRU时间 若发现该键已经过期，则删除键 若该键被watch，标记键为dirty，使得监听者发现后重新拉数据 dirty计数器++，用来触发持久化和复制操作 过期字典的键是键空间的键字符串对象的指针（不会新分配空间），值是longlong类型的过期时间（毫秒精度的unix时间戳）
判断是否过期：
先在过期字典里取key的过期时间，再与当前时间比较
删除策略 （redis同时采用惰性删除和定期删除策略，其中定期删除是随机取出一定数量的键做检查）：
定时删除：过期时立刻删除（问题：要创建大量定时器，占用太多CPU，因此不合理） 惰性删除：获取键时若过期才删除 （问题：内存最不友好） 定期删除：定期对所有key进行检查并删除 （问题：如何确定定期时间，太快或太慢都不好） 持久化 解密Redis持久化 - justjavac - 博客园 (cnblogs.com)
rdb 记录键值
主服务器初始化加载时不会加载过期的键值，从服务器会加载过期的键值，但同步之后也会被清空掉
主节点统一管理过期删除，从节点只能被动接收del命令，保证了数据一致性，但从节点里可能会有过期键值
SAVE阻塞保存，BGSAVE用子进程保存
自动保存：自动保存规则设置在一个列表中，表示一段时间内进行了多少次改动就满足保存规则
每次写入会将db的dirty计数器加1，且每次保存会保存的时间戳lastsave。当距离lastsave的时间超过条件中设置的时间，比较dirty与规则中设置的改动次数，若满足则触发BGSAVE
RDB数据格式
REDIS db_version database 0 database 3 EOF check_sum 格式细节包括压缩算法略过
aof 记录写命令（启动时优先选择加载aof）
命令追加：按redis协议追加到aof_buf缓冲区中
文件写入和同步：redis server主线程每次循环结束前，将缓冲区写入aof文件，并调用fsync落盘
同步策略：always（每次都落盘），everysec(离上次落盘超过一秒触发落盘), no（靠操作系统自己落盘，一般是30s）
过期但还未被删除的键值不会追加到aof中，只有惰性删除或定期删除显示调用del后才会追加DEL命令
aof重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。</p><footer><a href=https://scottlx.github.io/posts/redisserver/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/>redis 多节点</a></h1></header><p>主从（复制） 同步 slave刚上线或断线重连时的第一次全量同步
slave的客户端主动发送sync命令，触发master的BGSAVE，BGSAVE过程中将命令存入缓冲区，BGSAVE完成后发送RDB文件，slave完成RDB载入后再发送缓冲区的指令
命令传播 完成同步后的增量同步
master主动发送命令
psync 优化后的sync，作为断线重连后的增量同步 slave发送psync命令，master返回+continue，之后发送断开期间执行的写命令
偏移量 主节点和从节点各自维护一个偏移量，表示当前已接收数据的字节数。当从节点发现自身偏移量与主节点不一致时，主动向主节点发送psync命令
复制缓冲区 主节点进行命令传播时(增量同步),会将写命令复制一份到缓冲区。且每个写命令都绑定一个对应的偏移量。从节点发送的psync中带有偏移量， 通过该偏移量在复制缓冲区中查找偏移量之后的写命令。如果查不到，则执行完整同步(sync)
服务器运行ID 从节点向主节点注册自己的分布式ID，新上线的从节点若不在注册表内，则进行完整同步(sync)，否则进行部分重同步。
同步过程 slaveof命令设置redisServer中的masterhost和masterport字段，之后主从连接由cron定时器任务里触发
anetTcpConnect建立一个新的tcp连接 ping-pong命令测试连接 auth鉴权 发送端口号，主节点刷新client信息 psyn/sync 同步 命令传播 心跳 发送REPLCONF ACK命令，其中带有从节点的偏移量，可以检测命令丢失（命令丢失后主节点和从节点的偏移量会不一样）；收到心跳的时间戳用来监测网络延迟状态，若一定数量的从服务器的lag超过一定值，表示该主从集合不健康，不允许client写入 一致性 不是强一致性（cap），是最终一致性。用最终一致性换取了高吞吐量
master与slave的同步存在数据不一致的时间窗口期 网络分区后哨兵模式或者集群模式的选主会产生脑裂 哨兵 多了一个哨兵节点进行主节点选举，触发从同步等工作，数据的同步还是主从模式 哨兵节点运行的是一个特殊模式的redis服务器，里面没有数据库。
连接类型 命令连接
订阅连接
/*实例不是 Sentinel （主服务器或者从服务器） 并且以下条件的其中一个成立： 1）SENTINEL 未收到过这个服务器的 INFO 命令回复 2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔 那么向实例发送 INFO 命令 */ if ((ri->flags & SRI_SENTINEL) == 0 && ​ (ri->info_refresh == 0 || ​ (now - ri->info_refresh) > info_period)) { ​ /* Send INFO to masters and slaves, not sentinels.</p><footer><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/ rel=full-article>继续阅读 →</a></footer></article><div class=pagination><a href=/ aria-label=First class=label-pagination><i class="fa fa-angle-double-left fa-lg"></i></a>
<a href=/ aria-label=Previous class=label-pagination><i class="fa fa-angle-left fa-lg"></i></a>
<a href=/ class=label-pagination>1</a>
<a href=/page/2/ class=label-pagination>2</a>
<a href=/page/3/ class=label-pagination>3</a>
<a href=/page/3/ aria-label=Next class=label-pagination><i class="fa fa-angle-right fa-lg"></i></a>
<a href=/page/3/ aria-label=Last><i class="fa fa-angle-double-right fa-lg"></i></a></div></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>