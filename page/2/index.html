<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>windseek</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><link href=/index.xml rel=alternate type=application/rss+xml title=windseek><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div class=blog-index><article><header><p class=meta>Oct 28, 2022
- 8 minute read
- <a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90/>问题分析</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/>etcd client v3 连接流程</a></h1></header><p><p>首先需要了解grpc框架的一些概念，这边引用网上的一张图
<img src=/img/blobs/etcdclient.png alt="Alt text"></p><h3 id=resolver>Resolver</h3><p>提供一个用户自定义的解析、修改地址的方法，使得用户可以自己去实现地址解析的逻辑、做服务发现、地址更新等等功能。</p><ol><li>将Endpoints里的ETCD服务器地址(127.0.0.1:2379这种格式)做一次转换传给grpc框架。也可以自己重新写此resolver，做服务发现功能。例如etcd服务器地址写nacos之类的地址，在resolver中写好转换逻辑。</li><li>调用ClientConn的ParseServiceConfig接口告诉endpoints的负载策略是轮询</li></ol><h3 id=balancer>Balancer</h3><ol><li>管理subConns，并收集各conn信息，更新状态至ClientConn</li><li>生成picker(balancer)的快照，从而ClientConn可以选择发送rpc请求的subConn</li></ol><p>此处etcd client没有实现balancer，默认使用grpc提供的轮询的balancer</p><h3 id=重试策略>重试策略</h3><p>与一般的c-s模型不同，etcd client的重试是针对集群的重试。单个节点的断连不会造成所有节点的重连。</p><h4 id=重试机制>重试机制</h4><p>一般的重试是对同一个节点进行重试，但etcd client的自动重试不会在ETCD集群的同一节点上进行，是轮询重试集群的每个节点。重试时不会重新建连，而是使用balancer提供的transport。transport的状态更新与这一块的重试是通过balancer解耦的。</p><h4 id=重试条件>重试条件</h4><h5 id=etcd-unary拦截器>etcd unary拦截器</h5><p>拦截器类似http里的中间件的概念，在发送实际请求之前对报文进行篡改。一般用来添加认证，日志记录，缓存之类的功能。</p><p>此处etcd的一元拦截器主要做了自动重试的功能，且只会重试一些特定的错误(DeadlineExceeded, Canceled,ErrInvalidAuthToken)</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> (c <span style=color:#719e07>*</span>Client) <span style=color:#268bd2>unaryClientInterceptor</span>(optFuncs <span style=color:#719e07>...</span>retryOption) grpc.UnaryClientInterceptor {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#719e07>...</span>
</span></span><span style=display:flex><span><span style=color:#719e07>if</span> <span style=color:#268bd2>isContextError</span>(lastErr) {
</span></span><span style=display:flex><span>				<span style=color:#719e07>if</span> ctx.<span style=color:#268bd2>Err</span>() <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>					<span style=color:#586e75>// its the context deadline or cancellation.</span>
</span></span><span style=display:flex><span>					<span style=color:#719e07>return</span> lastErr
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#586e75>// its the callCtx deadline or cancellation, in which case try again.</span>
</span></span><span style=display:flex><span>				<span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> callOpts.retryAuth <span style=color:#719e07>&amp;&amp;</span> rpctypes.<span style=color:#268bd2>Error</span>(lastErr) <span style=color:#719e07>==</span> rpctypes.ErrInvalidAuthToken {
</span></span><span style=display:flex><span>				<span style=color:#586e75>// clear auth token before refreshing it.</span>
</span></span><span style=display:flex><span>				<span style=color:#586e75>// call c.Auth.Authenticate with an invalid token will always fail the auth check on the server-side,</span>
</span></span><span style=display:flex><span>				<span style=color:#586e75>// if the server has not apply the patch of pr #12165 (https://github.com/etcd-io/etcd/pull/12165)</span>
</span></span><span style=display:flex><span>				<span style=color:#586e75>// and a rpctypes.ErrInvalidAuthToken will recursively call c.getToken until system run out of resource.</span>
</span></span><span style=display:flex><span>				c.authTokenBundle.<span style=color:#268bd2>UpdateAuthToken</span>(<span style=color:#2aa198>&#34;&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				gterr <span style=color:#719e07>:=</span> c.<span style=color:#268bd2>getToken</span>(ctx)
</span></span><span style=display:flex><span>				<span style=color:#719e07>if</span> gterr <span style=color:#719e07>!=</span> <span style=color:#cb4b16>nil</span> {
</span></span><span style=display:flex><span>					c.<span style=color:#268bd2>GetLogger</span>().<span style=color:#268bd2>Warn</span>(
</span></span><span style=display:flex><span>						<span style=color:#2aa198>&#34;retrying of unary invoker failed to fetch new auth token&#34;</span>,
</span></span><span style=display:flex><span>						zap.<span style=color:#268bd2>String</span>(<span style=color:#2aa198>&#34;target&#34;</span>, cc.<span style=color:#268bd2>Target</span>()),
</span></span><span style=display:flex><span>						zap.<span style=color:#268bd2>Error</span>(gterr),
</span></span><span style=display:flex><span>					)
</span></span><span style=display:flex><span>					<span style=color:#719e07>return</span> gterr <span style=color:#586e75>// lastErr must be invalid auth token</span>
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>				<span style=color:#719e07>continue</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>    <span style=color:#719e07>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=重试次数>重试次数</h4><p>此处Invoke的大循环里，默认callOpts.max是0，也就是说尝试一次Invoke后就会return错误</p></p><footer><a href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 13, 2022
- 3 minute read
- <a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title>单调栈</h1></header><p><p>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。</p><h4 id=标准模板>标准模板</h4><ol><li>第一个for循环内循环输入数组，</li><li>第二个for循环维持栈内单调特性，不满足单调的元素依次出栈</li><li>第一个for循环内对元素入栈</li></ol><h4 id=496-下一个更大元素-i><a href=https://leetcode.cn/problems/next-greater-element-i/ target=_blank rel=noopener>496. 下一个更大元素 I</a></h4><p>直接输入出栈元素即可</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>nextGreaterElement</span>(nums1 []<span style=color:#dc322f>int</span>, nums2 []<span style=color:#dc322f>int</span>) []<span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>//单调递减栈</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>var</span> stack,res []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//标准模板，首个元素先入栈</span>
</span></span><span style=display:flex><span>    stack = <span style=color:#b58900>append</span>(stack, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询</span>
</span></span><span style=display:flex><span>    map1 <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>map</span>[<span style=color:#dc322f>int</span>]<span style=color:#dc322f>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> i,v <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span>(nums1) {
</span></span><span style=display:flex><span>        map1[v] = i
</span></span><span style=display:flex><span>        <span style=color:#586e75>//顺便初始化res，查不到的为-1</span>
</span></span><span style=display:flex><span>        res = <span style=color:#b58900>append</span>(res, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> i<span style=color:#719e07>:=</span><span style=color:#2aa198>1</span>; i &lt; <span style=color:#b58900>len</span>(nums2); i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 单调递减，所以&gt;=的都出栈</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> nums2[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] <span style=color:#719e07>&lt;=</span> nums2[i] {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 查表，需要输出的加入res</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> idx, ok <span style=color:#719e07>:=</span> map1[nums2[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]]]; ok {
</span></span><span style=display:flex><span>                res[idx] = nums2[i]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>//pop</span>
</span></span><span style=display:flex><span>            stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#586e75>// push</span>
</span></span><span style=display:flex><span>        stack = <span style=color:#b58900>append</span>(stack, i)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=42-接雨水><a href=https://leetcode.cn/problems/trapping-rain-water/ target=_blank rel=noopener>42. 接雨水</a></h4><p>出栈后计算出栈元素高度所在层的面积</p></p><footer><a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 12, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/>拓扑排序(选课)</a></h1></header><p><p><a href=https://leetcode.cn/problems/course-schedule/ target=_blank rel=noopener>207. 课程表 - 力扣（LeetCode）</a></p><h2 id=思路>思路</h2><p>课程之间的依赖关系可以用图来表示</p><ul><li>顶点：课程</li><li>边：有向的边，起点是前置课程，终点是后置课程</li></ul><p>这种图叫做AOV（Activity On Vertex）网络，字面意思就是边代表了节点之间的活动的先后关系。</p><p>按照题意，这个图是无环的（课程不能循环依赖），也就是DAG图。DAG图其实就是一颗树，只不过根节点是一个虚拟根节点（可以有多个起始根节点，但外面可以用一个虚拟根节点作为他们的父节点）。</p><p>因此，可以用广度优先遍历（BFS）来求解。队列存放可以选的课程（入度为0），依次出队列（选课）。直到队列为空（没有课可以选了），看是否已经学完所有的课程</p><ul><li>入度：指向自己的边的数量，入度为0表示自己没有前置课程，可以入队列</li><li>出度：指向别人的边。用一个数据结构记录每个节点的出度列表。当某个节点出队列时，更新本节点的出度列表里所有节点的入度（-1）</li></ul><h2 id=代码>代码</h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>canFinish</span>(numCourses <span style=color:#dc322f>int</span>, prerequisites [][]<span style=color:#dc322f>int</span>) <span style=color:#dc322f>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>//保存各课程的入度 空间O(v)</span>
</span></span><span style=display:flex><span>    indegree <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>int</span>, numCourses)
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 保存各课程的出度列表 空间O(e)</span>
</span></span><span style=display:flex><span>    courseMp <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>map</span>[<span style=color:#dc322f>int</span>][]<span style=color:#dc322f>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#586e75>//时间 O(e)</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> _, pre <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span>(prerequisites) {
</span></span><span style=display:flex><span>        indegree[pre[<span style=color:#2aa198>0</span>]]<span style=color:#719e07>++</span>
</span></span><span style=display:flex><span>        courseMp[pre[<span style=color:#2aa198>1</span>]] = <span style=color:#b58900>append</span>(courseMp[pre[<span style=color:#2aa198>1</span>]], pre[<span style=color:#2aa198>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>var</span> q []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 已经学习了的课程的计数</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>var</span> num <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 初始入度为0的课程加入队列</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> course, depends <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span>(indegree) {
</span></span><span style=display:flex><span>        <span style=color:#719e07>if</span> depends <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>            q = <span style=color:#b58900>append</span>(q, course)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//循环直到队列为空 时间O(v)</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(q) &gt; <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 出队列</span>
</span></span><span style=display:flex><span>        finished <span style=color:#719e07>:=</span> q[<span style=color:#2aa198>0</span>]
</span></span><span style=display:flex><span>        q = q[<span style=color:#2aa198>1</span>:]
</span></span><span style=display:flex><span>        num<span style=color:#719e07>++</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 更新入度数据结构(slice)</span>
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 从出度课程列表中直接取受影响的课程</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> _, course <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span>(courseMp[finished]) {
</span></span><span style=display:flex><span>            indegree[course]<span style=color:#719e07>--</span>
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 入度-1后若为0，则可以入队列</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> indegree[course] <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>                q = <span style=color:#b58900>append</span>(q, course)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//是否学完</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> num <span style=color:#719e07>==</span> numCourses
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>时间复杂度：O (v+e)</li><li>空间复杂度: O(v+e)</li></ul><p>若需要省空间，不需要省时间，可以不使用courseMp存放出度数组，每次重新遍历prerequisites 获取出度数组。此时处理每个节点都需要重新遍历所有的边，因此：</p></p><footer><a href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 8, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/>优势洗牌(田忌赛马)</a></h1></header><p><p><a href=https://leetcode.cn/problems/advantage-shuffle/ target=_blank rel=noopener>870. 优势洗牌 - 力扣（LeetCode）</a></p><h3 id=思路>思路</h3><ol><li>将nums1(自己的马)进行升序排序，得到下等马->上等马的序列</li><li>贪心策略<ul><li>若某个位置上自己的马比对手的马强，由于已经排过序了，已经是最下等的马了，因此使用这匹马</li><li>若某个位置上自己的马比对手的马弱，将该下等马放到最后的位置（对手的上等马的位置）</li></ul></li><li>由于nums2的顺序固定（已知对手上场顺序），因此使用nums2的元素值对nums2的index进行排序，得到上场顺序（ids）</li><li>按照上场顺序(ids)依次写入ans数组中</li></ol><h3 id=代码>代码</h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>advantageCount</span>(nums1 []<span style=color:#dc322f>int</span>, nums2 []<span style=color:#dc322f>int</span>) []<span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>	sort.<span style=color:#268bd2>Ints</span>(nums1)
</span></span><span style=display:flex><span>	n <span style=color:#719e07>:=</span> <span style=color:#b58900>len</span>(nums1)
</span></span><span style=display:flex><span>	ans <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>int</span>, n)
</span></span><span style=display:flex><span>	ids <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>int</span>, n)
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#2aa198>0</span>; i &lt; n; i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>		ids[i] = i
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	sort.<span style=color:#268bd2>Slice</span>(ids, <span style=color:#268bd2>func</span>(i, j <span style=color:#dc322f>int</span>) <span style=color:#dc322f>bool</span> { <span style=color:#719e07>return</span> nums2[ids[i]] &lt; nums2[ids[j]] })
</span></span><span style=display:flex><span>	left, right <span style=color:#719e07>:=</span> <span style=color:#2aa198>0</span>, n<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> _, v <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> nums1 {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> v &gt; nums2[ids[left]] {
</span></span><span style=display:flex><span>			ans[ids[left]] = v
</span></span><span style=display:flex><span>			left<span style=color:#719e07>++</span>
</span></span><span style=display:flex><span>		} <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>			ans[ids[right]] = v
</span></span><span style=display:flex><span>			right<span style=color:#719e07>--</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> ans
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=总结>总结</h3><p>灵活运用不对数组进行真正的排序，而是获得排序后的index的顺序这一技巧</p></p><footer><a href=https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/k8s%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>k8s源码分析</a></h1></header><p><h3 id=api-server>API Server</h3><p><img src=/img/k8s/APIServer.svg alt=APIServer></p><h3 id=controller>Controller</h3><p><img src=/img/k8s/controller.svg alt=controller></p><h3 id=device-plugin>Device Plugin</h3><p><img src=/img/k8s/device_plugin.svg alt=device_plugin></p><h3 id=informer>Informer</h3><p><img src=/img/k8s/informer.svg alt=informer></p><h3 id=kube-proxy>Kube Proxy</h3><p><img src=/img/k8s/kubeproxy.svg alt=kubeproxy></p><h3 id=pod-create>Pod Create</h3><p><img src=/img/k8s/pod-create.svg alt="pod create"></p><h3 id=schdulerv113>Schduler(V1.13)</h3><p><img src=/img/k8s/schedulerv1.13.svg alt=schedulerv1.13></p></p></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redisserver/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redisserver/>redis Server</a></h1></header><p><h3 id=数据库切换>数据库切换</h3><p>默认会创建16个数据库，客户端通过select选取。但一般情况只用第0个数据库，切换容易导致误操作</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>typedef</span> <span style=color:#719e07>struct</span> redisDb {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  dict <span style=color:#719e07>*</span>dict; <span style=color:#586e75>//键空间
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  dict <span style=color:#719e07>*</span>expires; <span style=color:#586e75>//过期字典
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>  <span style=color:#dc322f>int</span> id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} redisDb;
</span></span></code></pre></div><p>所有键空间存储在redisDb的dict中，称为key space</p><p>每个键是字符串对象，值是各种对象</p><h3 id=读写键操作>读写键操作</h3><ol><li>更新keyspace_hits和keyspace_misses，用来输出统计数据</li><li>更新键的LRU时间</li><li>若发现该键已经过期，则删除键</li><li>若该键被watch，标记键为dirty，使得监听者发现后重新拉数据</li><li>dirty计数器++，用来触发持久化和复制操作</li></ol><p>过期字典的键是键空间的键字符串对象的指针（不会新分配空间），值是longlong类型的过期时间（毫秒精度的unix时间戳）</p><p>判断是否过期：</p><p>先在过期字典里取key的过期时间，再与当前时间比较</p><h3 id=删除策略>删除策略</h3><p>（redis同时采用惰性删除和定期删除策略，其中定期删除是随机取出一定数量的键做检查）：</p><ul><li>定时删除：过期时立刻删除（问题：要创建大量定时器，占用太多CPU，因此不合理）</li><li>惰性删除：获取键时若过期才删除 （问题：内存最不友好）</li><li>定期删除：定期对所有key进行检查并删除 （问题：如何确定定期时间，太快或太慢都不好）</li></ul><h3 id=持久化>持久化</h3><p><a href=https://www.cnblogs.com/justjavac/archive/2013/01/22/redis-persistence-demystified.html target=_blank rel=noopener>解密Redis持久化 - justjavac - 博客园 (cnblogs.com)</a></p><h4 id=rdb>rdb</h4><p>记录键值</p><p>主服务器初始化加载时不会加载过期的键值，从服务器会加载过期的键值，但同步之后也会被清空掉</p><p>主节点统一管理过期删除，从节点只能被动接收del命令，保证了数据一致性，但从节点里可能会有过期键值</p><p>SAVE阻塞保存，BGSAVE用子进程保存</p><p>自动保存：自动保存规则设置在一个列表中，表示一段时间内进行了多少次改动就满足保存规则</p><p>每次写入会将db的dirty计数器加1，且每次保存会保存的时间戳lastsave。当距离lastsave的时间超过条件中设置的时间，比较dirty与规则中设置的改动次数，若满足则触发BGSAVE</p><p>RDB数据格式</p><table><thead><tr><th>REDIS</th><th>db_version</th><th>database 0</th><th>database 3</th><th>EOF</th><th>check_sum</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>格式细节包括压缩算法略过</p><h4 id=aof>aof</h4><p>记录写命令（启动时优先选择加载aof）</p><p>命令追加：按redis协议追加到aof_buf缓冲区中</p><p>文件写入和同步：redis server主线程每次循环结束前，将缓冲区写入aof文件，并调用fsync落盘</p></p><footer><a href=https://scottlx.github.io/posts/redisserver/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/>redis 多节点</a></h1></header><p><h1 id=主从复制>主从（复制）</h1><h2 id=同步>同步</h2><p>slave刚上线或断线重连时的第一次全量同步</p><p>slave的客户端主动发送sync命令，触发master的BGSAVE，BGSAVE过程中将命令存入缓冲区，BGSAVE完成后发送RDB文件，slave完成RDB载入后再发送缓冲区的指令</p><h2 id=命令传播>命令传播</h2><p>完成同步后的增量同步</p><p>master主动发送命令</p><h2 id=psync>psync</h2><p>优化后的sync，作为断线重连后的增量同步
slave发送psync命令，master返回+continue，之后发送断开期间执行的写命令</p><h3 id=偏移量>偏移量</h3><p>主节点和从节点各自维护一个偏移量，表示当前已接收数据的字节数。当从节点发现自身偏移量与主节点不一致时，主动向主节点发送psync命令</p><h3 id=复制缓冲区>复制缓冲区</h3><p>主节点进行命令传播时(增量同步),会将写命令复制一份到缓冲区。且每个写命令都绑定一个对应的偏移量。从节点发送的psync中带有偏移量，
通过该偏移量在复制缓冲区中查找偏移量之后的写命令。如果查不到，则执行完整同步(sync)</p><h3 id=服务器运行id>服务器运行ID</h3><p>从节点向主节点注册自己的分布式ID，新上线的从节点若不在注册表内，则进行完整同步(sync)，否则进行部分重同步。</p><h2 id=同步过程>同步过程</h2><p>slaveof命令设置redisServer中的masterhost和masterport字段，之后主从连接由cron定时器任务里触发</p><ul><li>anetTcpConnect建立一个新的tcp连接</li><li>ping-pong命令测试连接</li><li>auth鉴权</li><li>发送端口号，主节点刷新client信息</li><li>psyn/sync 同步</li><li>命令传播</li><li>心跳 发送REPLCONF ACK命令，其中带有从节点的偏移量，可以检测命令丢失（命令丢失后主节点和从节点的偏移量会不一样）；收到心跳的时间戳用来监测网络延迟状态，若一定数量的从服务器的lag超过一定值，表示该主从集合不健康，不允许client写入</li></ul><h3 id=一致性>一致性</h3><p>不是强一致性（cap），是最终一致性。用最终一致性换取了高吞吐量</p><ul><li>master与slave的同步存在数据不一致的时间窗口期</li><li>网络分区后哨兵模式或者集群模式的选主会产生脑裂</li></ul><h1 id=哨兵>哨兵</h1><p>多了一个哨兵节点进行主节点选举，触发从同步等工作，数据的同步还是主从模式
哨兵节点运行的是一个特殊模式的redis服务器，里面没有数据库。</p><h3 id=连接类型>连接类型</h3><p>命令连接</p><p>订阅连接</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/*实例不是 Sentinel （主服务器或者从服务器）
</span></span></span><span style=display:flex><span><span style=color:#586e75>并且以下条件的其中一个成立：
</span></span></span><span style=display:flex><span><span style=color:#586e75>    1）SENTINEL 未收到过这个服务器的 INFO 命令回复
</span></span></span><span style=display:flex><span><span style=color:#586e75>    2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔
</span></span></span><span style=display:flex><span><span style=color:#586e75>   那么向实例发送 INFO 命令
</span></span></span><span style=display:flex><span><span style=color:#586e75>*/</span>
</span></span><span style=display:flex><span>  <span style=color:#719e07>if</span> ((ri<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>&amp;</span> SRI_SENTINEL) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span>
</span></span><span style=display:flex><span>​    (ri<span style=color:#719e07>-&gt;</span>info_refresh <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> <span style=color:#719e07>||</span>
</span></span><span style=display:flex><span>​    (now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>info_refresh) <span style=color:#719e07>&gt;</span> info_period))
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* Send INFO to masters and slaves, not sentinels. */</span>
</span></span><span style=display:flex><span>​    retval <span style=color:#719e07>=</span> <span style=color:#268bd2>redisAsyncCommand</span>(ri<span style=color:#719e07>-&gt;</span>cc,
</span></span><span style=display:flex><span>​      sentinelInfoReplyCallback, <span style=color:#b58900>NULL</span>, <span style=color:#2aa198>&#34;INFO&#34;</span>);
</span></span><span style=display:flex><span>​    <span style=color:#719e07>if</span> (retval <span style=color:#719e07>==</span> REDIS_OK) ri<span style=color:#719e07>-&gt;</span>pending_commands<span style=color:#719e07>++</span>;
</span></span><span style=display:flex><span>  } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> ((now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>last_pong_time) <span style=color:#719e07>&gt;</span> ping_period) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* Send PING to all the three kinds of instances. */</span>
</span></span><span style=display:flex><span>​    <span style=color:#268bd2>sentinelSendPing</span>(ri);
</span></span><span style=display:flex><span>  } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> ((now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>last_pub_time) <span style=color:#719e07>&gt;</span> SENTINEL_PUBLISH_PERIOD) {
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* PUBLISH hello messages to all the three kinds of instances. */</span>
</span></span><span style=display:flex><span>​    <span style=color:#268bd2>sentinelSendHello</span>(ri);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=节点的连接>节点的连接</h3><p>哨兵主定时任务开始时，以1s或10s的间隔发送INFO命令，得到主节点的回复，并处理INFO回复的信息。回复中包含该主节点的从节点ip+port。处理函数中更新主节点的实例sentinelRedisInstance，并创建从节点，进行从节点的连接，获取从节点的详细信息。</p></p><footer><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>redis 数据结构</a></h1></header><p><p>此系列作为redis设计与实现的笔记，会将本人自认为重点部分单独拎出来，并加入本人的一些理解。</p><h3 id=sds>SDS</h3><p>（simple dynamic string）</p><p>等同于go里的slice</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> sdshdr {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> free;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#dc322f>char</span> buf[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>优点：</p><ul><li>杜绝缓冲区溢出（free检验）</li><li>减少修改字符串时的内存分配次数（策略：小于1MB时，len=free，大于1MB时，free=1MB）</li><li>惰性空间释放（删除时实际空间并未缩减）</li><li>二进制安全（C字符串视/0为结束，不能用来存带/0的二进制数据）</li><li>部分兼容C字符串函数（默认在char数组最后加入/0，来兼容C字符串函数）</li></ul><h3 id=链表>链表</h3><p>双向链表，无环，保存头指针和尾指针，保存链表长度字段，链表节点的数据为void*指针</p><h3 id=字典>字典</h3><p>字典有type，每个type实现了一系列操作kv的函数（对比，生成哈希，删除，复制等）</p><p>每个字典存有两个哈希表，一般用第一个ht[0]，第二个ht[1]用作rehash时的暂存容器</p><p>哈希表由数组实现，数组存放kv链表头节点，链地址法解决冲突，冲突的新键值往表头加（由于没有指向表尾的指针）</p><p>rehash标志位，当没有进行rehash时为-1</p><p>key&ndash;>(hashfunc)&ndash;>hash&ndash;>(hashmask)&ndash;>index</p><p>murmurhash算法：输入有规律情况还是能生成随机分布性的hash</p><h4 id=rehash>rehash</h4><p>为ht[1]哈希表分配空间，空间的大小取决于当前ht[0]包含的键值数量以及要进行的操作，重新计算所有键值在ht[1]的索引并插入，插入后将ht[1]设置为ht[0]，并ht[1]指向新创的空白hash表</p><p>负载因子=ht[0].used/ht[0].size</p><h5 id=何时进行扩展>何时进行扩展?</h5><p>在进行持久化操作时(BGSAVE,BGREWRITEAOF)，负载因子>=5，普通场景下负载因子>=1</p><h5 id=何时进行收缩>何时进行收缩?</h5><p>负载因子&lt;0.1</p><h5 id=渐进式rehash>渐进式rehash</h5><p>开始时rehashidx为0，表示正在进行rehash，rehash期间对字典的CRUD会顺带将ht[0]上的KV rehash到ht[1]，完成后rehashidx置为-1,表示已经完成。rehash期间的CRUD会先在ht[0]上查，查不到再去ht[1]查</p><h3 id=跳表>跳表</h3><p>用来实现有序集合键，用作集群节点内部数据结构</p><p>优点，相较于平衡树，实现简单，且rebalance的效率高（局部rebalance，只修改搜索路径上的节点）</p><p>链表的扩展，维护了多个指向其他节点的指针，类似二分查找</p><p>每个节点的层数是随机生成的，遍历时先走最上层的前进指针，若下一条节点的分值比要查找的分值高，则通过回退指针回到原来的节点并走下一层的前进指针，以此类推</p><p>前进指针中存有跨度，累加所有跨度，当找到该节点后作为该节点在跳表中的排位（数组的index）</p><p>比较分值时，分值可能相同，相同时比较value值（obj指向的sds的字典序）</p><p>节点更新时，若score的改变未影响排序，则查找并直接改score，否则进行先删除后插入操作，会进行两次路径搜索</p><h3 id=整数集合>整数集合</h3><p>底层保存的整数为byte数组(int8)，按照解码类型(encoding)存入int16，int32或int64的数据</p><p>只能存一种类型的数据，短int集合中插入长int后，往长int类型兼容（升级）</p><p>节约内存，int16不需要分配int64的空间</p><p>自适应灵活性，集合中添加长度更长的新元素，会自动升级，但不支持降级</p><h3 id=压缩列表>压缩列表</h3><p>为了节约内存，将键值为小整数值和短字符串的entry按照特殊编排压缩为一段内存块</p><p>先略过</p><h3 id=对象>对象</h3><p>创建键值对时，键和值都被封装成对象，并指明对象的类型，编码以及底层数据结构的指针</p><p>key总是字符串对象，value可以是字符串对象，列表对象，哈希对象，集合对象，有序集合对象(zset)</p><p>编码指定了底层数据结构, 每种对象类型有多种编码的实现</p><h4 id=字符串对象>字符串对象</h4><p>long：value是数字，可以用long存</p><p>raw：value是字符串，长度大于32byte，用sds存，sds的内存是另外一块，和redisObject不连续</p><p>embstr：value是字符串，长度小于32byte，用sds存，sds的内存与redisObject的内存连续 （好处：减少分配和释放内存的次数，增加缓存命中率；坏处：没有实现写方法，只读，修改的话需要先转raw）</p></p><footer><a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 2 minute read
- <a href=https://scottlx.github.io/posts/gobpf/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%93%8d%e4%bd%9c%e6%8c%87%e5%8d%97/>操作指南</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/gobpf/>gobpf不完整使用指南</a></h1></header><p><h3 id=编译过程>编译过程</h3><h4 id=安装llvm-10clang-10>安装llvm-10,clang-10</h4><p>apt-install llvm-10 clang-10</p><h4 id=下载bpf2go>下载bpf2go</h4><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go install github.com/cilium/ebpf/cmd/bpf2go@latest
</span></span></code></pre></div><p>修改bpf程序的include</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#include</span> <span style=color:#719e07>&#34;common.h&#34;</span><span style=color:#719e07>
</span></span></span></code></pre></div><h4 id=编译时将bpd的headers包含进来>编译时将bpd的headers包含进来</h4><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#268bd2>GOPACKAGE</span><span style=color:#719e07>=</span>main bpf2go -cc clang-10 -cflags <span style=color:#2aa198>&#39;-O2 -g -Wall -Werror&#39;</span> -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /root/ebpf/examples/headers
</span></span></code></pre></div><p>得到大端和小端两个版本的ELF文件，之后在go程序里加载即可。cpu一般都是小端。</p><h3 id=内核版本要求>内核版本要求</h3><p>经测试一些gobpf的一些syscall不适配较低版本的内核（例如5.8的BPF_LINK_CREATE会报参数错误），建议使用最新版本内核5.19</p><h3 id=bpf_map>bpf_map</h3><p>用户态程序首先加载bpf maps，再将bpf maps绑定到fd上。elf文件中的realocation table用来将代码中的bpf maps重定向至正确的fd上,用户程序在fd上发起bpf syscall</p><p>map的value尽量不要存复合数据结构，若bpf程序和用户态程序共用一个头文件，用户态程序调用bpf.Lookup时由于结构体变量unexported而反射失败</p><h3 id=pinning-object>pinning object</h3><p>将map挂载到/sys/fs/bpf</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>ebpf.CollectionOptions{
</span></span><span style=display:flex><span>   Maps: ebpf.MapOptions{
</span></span><span style=display:flex><span>      <span style=color:#586e75>// Pin the map to the BPF filesystem and configure the</span>
</span></span><span style=display:flex><span>      <span style=color:#586e75>// library to automatically re-write it in the BPF</span>
</span></span><span style=display:flex><span>      <span style=color:#586e75>// program so it can be re-used if it already exists or</span>
</span></span><span style=display:flex><span>      <span style=color:#586e75>// create it if not</span>
</span></span><span style=display:flex><span>      PinPath: pinPath
</span></span></code></pre></div><p>其他用户态程序获取pinned map的fd</p></p><footer><a href=https://scottlx.github.io/posts/gobpf/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 2 minute read
- <a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/>初识ebpf</a></h1></header><p><p>摘自</p><p><a href=https://forsworns.github.io/zh/blogs/20210329/ target=_blank rel=noopener>eBPF 用户空间虚拟机实现相关 | Blog (forsworns.github.io)</a></p><p>[
<a href=http://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/ target=_blank rel=noopener>译] Cilium：BPF 和 XDP 参考指南（2021） (arthurchiao.art)</a></p><h3 id=hook-point>hook point</h3><p>可以插入bpf代码的位置</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>enum</span> bpf_prog_type {
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_UNSPEC,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_SOCKET_FILTER,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_KPROBE,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_SCHED_CLS,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_SCHED_ACT,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_TRACEPOINT,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_XDP,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_PERF_EVENT,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_CGROUP_SKB,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_CGROUP_SOCK,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_LWT_IN,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_LWT_OUT,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_LWT_XMIT,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_SOCK_OPS,
</span></span><span style=display:flex><span>    BPF_PROG_TYPE_SK_SKB,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=程序类型>程序类型</h3><table><thead><tr><th><strong>bpf_prog_type</strong></th><th><strong>BPF prog</strong> 入口参数（R1)</th><th><strong>程序类型</strong></th></tr></thead><tbody><tr><td><strong>BPF_PROG_TYPE_SOCKET_FILTER</strong></td><td><strong>struct __sk_buff</strong></td><td>用于过滤进出口网络报文，功能上和 cBPF 类似。</td></tr><tr><td><strong>BPF_PROG_TYPE_KPROBE</strong></td><td><strong>struct</strong> <strong>pt_regs</strong></td><td>用于 kprobe 功能的 BPF 代码。</td></tr><tr><td><strong>BPF_PROG_TYPE_TRACEPOINT</strong></td><td>这类 BPF 的参数比较特殊，根据 tracepoint 位置的不同而不同。</td><td>用于在各个 tracepoint 节点运行。</td></tr><tr><td><strong>BPF_PROG_TYPE_XDP</strong></td><td><strong>struct</strong> <strong>xdp_md</strong></td><td>用于控制 XDP(eXtreme Data Path)的 BPF 代码。</td></tr><tr><td><strong>BPF_PROG_TYPE_PERF_EVENT</strong></td><td><strong>struct bpf_perf_event_data</strong></td><td>用于定义 perf event 发生时回调的 BPF 代码。</td></tr><tr><td><strong>BPF_PROG_TYPE_CGROUP_SKB</strong></td><td><strong>struct __sk_buff</strong></td><td>用于在 network cgroup 中运行的 BPF 代码。功能上和 Socket_Filter 近似。具体用法可以参考范例 test_cgrp2_attach。</td></tr><tr><td><strong>BPF_PROG_TYPE_CGROUP_SOCK</strong></td><td><strong>struct bpf_sock</strong></td><td>另一个用于在 network cgroup 中运行的 BPF 代码，范例 test_cgrp2_sock2 中就展示了一个利用 BPF 来控制 host 和 netns 间通信的例子。</td></tr></tbody></table><p>BPF 程序类型就是由 BPF side 的代码的函数参数确定的，比如写了一个函数，参数是 <code>struct __sk_buff</code> 类型的，它就是一个 <strong>BPF_PROG_TYPE_SOCKET_FILTER</strong> 类型的 BPF 程序</p></p><footer><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/ rel=full-article>继续阅读 →</a></footer></article><div class=pagination><a href=/ aria-label=First class=label-pagination><i class="fa fa-angle-double-left fa-lg"></i></a>
<a href=/ aria-label=Previous class=label-pagination><i class="fa fa-angle-left fa-lg"></i></a>
<a href=/ class=label-pagination>1</a>
<a href=/page/2/ class=label-pagination>2</a>
<a href=/page/3/ class=label-pagination>3</a>
<a href=/page/3/ aria-label=Next class=label-pagination><i class="fa fa-angle-right fa-lg"></i></a>
<a href=/page/3/ aria-label=Last><i class="fa fa-angle-double-right fa-lg"></i></a></div></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>