<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>windseek</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><link href=/index.xml rel=alternate type=application/rss+xml title=windseek><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div class=blog-index><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/>redis 多节点</a></h1></header><p>主从（复制） 同步 slave刚上线或断线重连时的第一次全量同步
slave的客户端主动发送sync命令，触发master的BGSAVE，BGSAVE过程中将命令存入缓冲区，BGSAVE完成后发送RDB文件，slave完成RDB载入后再发送缓冲区的指令
命令传播 完成同步后的增量同步
master主动发送命令
psync 优化后的sync，作为断线重连后的增量同步 slave发送psync命令，master返回+continue，之后发送断开期间执行的写命令
偏移量 主节点和从节点各自维护一个偏移量，表示当前已接收数据的字节数。当从节点发现自身偏移量与主节点不一致时，主动向主节点发送psync命令
复制缓冲区 主节点进行命令传播时(增量同步),会将写命令复制一份到缓冲区。且每个写命令都绑定一个对应的偏移量。从节点发送的psync中带有偏移量， 通过该偏移量在复制缓冲区中查找偏移量之后的写命令。如果查不到，则执行完整同步(sync)
服务器运行ID 从节点向主节点注册自己的分布式ID，新上线的从节点若不在注册表内，则进行完整同步(sync)，否则进行部分重同步。
同步过程 slaveof命令设置redisServer中的masterhost和masterport字段，之后主从连接由cron定时器任务里触发
anetTcpConnect建立一个新的tcp连接 ping-pong命令测试连接 auth鉴权 发送端口号，主节点刷新client信息 psyn/sync 同步 命令传播 心跳 发送REPLCONF ACK命令，其中带有从节点的偏移量，可以检测命令丢失（命令丢失后主节点和从节点的偏移量会不一样）；收到心跳的时间戳用来监测网络延迟状态，若一定数量的从服务器的lag超过一定值，表示该主从集合不健康，不允许client写入 一致性 不是强一致性（cap），是最终一致性。用最终一致性换取了高吞吐量
master与slave的同步存在数据不一致的时间窗口期 网络分区后哨兵模式或者集群模式的选主会产生脑裂 哨兵 多了一个哨兵节点进行主节点选举，触发从同步等工作，数据的同步还是主从模式 哨兵节点运行的是一个特殊模式的redis服务器，里面没有数据库。
连接类型 命令连接
订阅连接
/*实例不是 Sentinel （主服务器或者从服务器） 并且以下条件的其中一个成立： 1）SENTINEL 未收到过这个服务器的 INFO 命令回复 2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔 那么向实例发送 INFO 命令 */ if ((ri->flags & SRI_SENTINEL) == 0 && ​ (ri->info_refresh == 0 || ​ (now - ri->info_refresh) > info_period)) { ​ /* Send INFO to masters and slaves, not sentinels.</p><footer><a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>redis 数据结构</a></h1></header><p>此系列作为redis设计与实现的笔记，会将本人自认为重点部分单独拎出来，并加入本人的一些理解。
SDS （simple dynamic string）
等同于go里的slice
struct sdshdr { int len; int free; char buf[]; } 优点：
杜绝缓冲区溢出（free检验） 减少修改字符串时的内存分配次数（策略：小于1MB时，len=free，大于1MB时，free=1MB） 惰性空间释放（删除时实际空间并未缩减） 二进制安全（C字符串视/0为结束，不能用来存带/0的二进制数据） 部分兼容C字符串函数（默认在char数组最后加入/0，来兼容C字符串函数） 链表 双向链表，无环，保存头指针和尾指针，保存链表长度字段，链表节点的数据为void*指针
字典 字典有type，每个type实现了一系列操作kv的函数（对比，生成哈希，删除，复制等）
每个字典存有两个哈希表，一般用第一个ht[0]，第二个ht[1]用作rehash时的暂存容器
哈希表由数组实现，数组存放kv链表头节点，链地址法解决冲突，冲突的新键值往表头加（由于没有指向表尾的指针）
rehash标志位，当没有进行rehash时为-1
key&ndash;>(hashfunc)&ndash;>hash&ndash;>(hashmask)&ndash;>index
murmurhash算法：输入有规律情况还是能生成随机分布性的hash
rehash 为ht[1]哈希表分配空间，空间的大小取决于当前ht[0]包含的键值数量以及要进行的操作，重新计算所有键值在ht[1]的索引并插入，插入后将ht[1]设置为ht[0]，并ht[1]指向新创的空白hash表
负载因子=ht[0].used/ht[0].size
何时进行扩展? 在进行持久化操作时(BGSAVE,BGREWRITEAOF)，负载因子>=5，普通场景下负载因子>=1
何时进行收缩? 负载因子&lt;0.1
渐进式rehash 开始时rehashidx为0，表示正在进行rehash，rehash期间对字典的CRUD会顺带将ht[0]上的KV rehash到ht[1]，完成后rehashidx置为-1,表示已经完成。rehash期间的CRUD会先在ht[0]上查，查不到再去ht[1]查
跳表 用来实现有序集合键，用作集群节点内部数据结构
优点，相较于平衡树，实现简单，且rebalance的效率高（局部rebalance，只修改搜索路径上的节点）
链表的扩展，维护了多个指向其他节点的指针，类似二分查找
每个节点的层数是随机生成的，遍历时先走最上层的前进指针，若下一条节点的分值比要查找的分值高，则通过回退指针回到原来的节点并走下一层的前进指针，以此类推
前进指针中存有跨度，累加所有跨度，当找到该节点后作为该节点在跳表中的排位（数组的index）
比较分值时，分值可能相同，相同时比较value值（obj指向的sds的字典序）
节点更新时，若score的改变未影响排序，则查找并直接改score，否则进行先删除后插入操作，会进行两次路径搜索
整数集合 底层保存的整数为byte数组(int8)，按照解码类型(encoding)存入int16，int32或int64的数据
只能存一种类型的数据，短int集合中插入长int后，往长int类型兼容（升级）
节约内存，int16不需要分配int64的空间
自适应灵活性，集合中添加长度更长的新元素，会自动升级，但不支持降级
压缩列表 为了节约内存，将键值为小整数值和短字符串的entry按照特殊编排压缩为一段内存块
先略过
对象 创建键值对时，键和值都被封装成对象，并指明对象的类型，编码以及底层数据结构的指针
key总是字符串对象，value可以是字符串对象，列表对象，哈希对象，集合对象，有序集合对象(zset)
编码指定了底层数据结构, 每种对象类型有多种编码的实现
字符串对象 long：value是数字，可以用long存
raw：value是字符串，长度大于32byte，用sds存，sds的内存是另外一块，和redisObject不连续
embstr：value是字符串，长度小于32byte，用sds存，sds的内存与redisObject的内存连续 （好处：减少分配和释放内存的次数，增加缓存命中率；坏处：没有实现写方法，只读，修改的话需要先转raw）
列表对象 ziplist：redisObject的ptr指向压缩列表（条件：每个字符串长度&lt;64byte且列表长度&lt;512）
linkedlist：构造元素为字符串对象的双向链表（列表对象中嵌套了字符串对象）</p><footer><a href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 2 minute read
- <a href=https://scottlx.github.io/posts/gobpf/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%93%8d%e4%bd%9c%e6%8c%87%e5%8d%97/>操作指南</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/gobpf/>gobpf不完整使用指南</a></h1></header><p>编译过程 安装llvm-10,clang-10 apt-install llvm-10 clang-10
下载bpf2go go install github.com/cilium/ebpf/cmd/bpf2go@latest 修改bpf程序的include
#include "common.h" 编译时将bpd的headers包含进来 GOPACKAGE=main bpf2go -cc clang-10 -cflags '-O2 -g -Wall -Werror' -target bpfel,bpfeb bpf helloworld.bpf.c -- -I /root/ebpf/examples/headers 得到大端和小端两个版本的ELF文件，之后在go程序里加载即可。cpu一般都是小端。
内核版本要求 经测试一些gobpf的一些syscall不适配较低版本的内核（例如5.8的BPF_LINK_CREATE会报参数错误），建议使用最新版本内核5.19
bpf_map 用户态程序首先加载bpf maps，再将bpf maps绑定到fd上。elf文件中的realocation table用来将代码中的bpf maps重定向至正确的fd上,用户程序在fd上发起bpf syscall
map的value尽量不要存复合数据结构，若bpf程序和用户态程序共用一个头文件，用户态程序调用bpf.Lookup时由于结构体变量unexported而反射失败
pinning object 将map挂载到/sys/fs/bpf
ebpf.CollectionOptions{ Maps: ebpf.MapOptions{ // Pin the map to the BPF filesystem and configure the // library to automatically re-write it in the BPF // program so it can be re-used if it already exists or // create it if not PinPath: pinPath 其他用户态程序获取pinned map的fd</p><footer><a href=https://scottlx.github.io/posts/gobpf/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 2 minute read
- <a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/>初识ebpf</a></h1></header><p>摘自
eBPF 用户空间虚拟机实现相关 | Blog (forsworns.github.io)
[ 译] Cilium：BPF 和 XDP 参考指南（2021） (arthurchiao.art)
hook point 可以插入bpf代码的位置
enum bpf_prog_type { BPF_PROG_TYPE_UNSPEC, BPF_PROG_TYPE_SOCKET_FILTER, BPF_PROG_TYPE_KPROBE, BPF_PROG_TYPE_SCHED_CLS, BPF_PROG_TYPE_SCHED_ACT, BPF_PROG_TYPE_TRACEPOINT, BPF_PROG_TYPE_XDP, BPF_PROG_TYPE_PERF_EVENT, BPF_PROG_TYPE_CGROUP_SKB, BPF_PROG_TYPE_CGROUP_SOCK, BPF_PROG_TYPE_LWT_IN, BPF_PROG_TYPE_LWT_OUT, BPF_PROG_TYPE_LWT_XMIT, BPF_PROG_TYPE_SOCK_OPS, BPF_PROG_TYPE_SK_SKB, }; 程序类型 bpf_prog_type BPF prog 入口参数（R1) 程序类型 BPF_PROG_TYPE_SOCKET_FILTER struct __sk_buff 用于过滤进出口网络报文，功能上和 cBPF 类似。 BPF_PROG_TYPE_KPROBE struct pt_regs 用于 kprobe 功能的 BPF 代码。 BPF_PROG_TYPE_TRACEPOINT 这类 BPF 的参数比较特殊，根据 tracepoint 位置的不同而不同。 用于在各个 tracepoint 节点运行。 BPF_PROG_TYPE_XDP struct xdp_md 用于控制 XDP(eXtreme Data Path)的 BPF 代码。 BPF_PROG_TYPE_PERF_EVENT struct bpf_perf_event_data 用于定义 perf event 发生时回调的 BPF 代码。 BPF_PROG_TYPE_CGROUP_SKB struct __sk_buff 用于在 network cgroup 中运行的 BPF 代码。功能上和 Socket_Filter 近似。具体用法可以参考范例 test_cgrp2_attach。 BPF_PROG_TYPE_CGROUP_SOCK struct bpf_sock 另一个用于在 network cgroup 中运行的 BPF 代码，范例 test_cgrp2_sock2 中就展示了一个利用 BPF 来控制 host 和 netns 间通信的例子。 BPF 程序类型就是由 BPF side 的代码的函数参数确定的，比如写了一个函数，参数是 struct __sk_buff 类型的，它就是一个 BPF_PROG_TYPE_SOCKET_FILTER 类型的 BPF 程序</p><footer><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/>基于事务处理的vpp管控面agent</a></h1></header><p>问题背景 vpp作为vrouter，类似物理交换机，各配置项依赖关系复杂。以下为vpp配置abf策略路由的例子：
typedef abf_policy { u32 policy_id; u32 acl_index; //依赖acl u8 n_paths; vl_api_fib_path_t paths[n_paths]; }; autoreply define abf_policy_add_del { option status="in_progress"; u32 client_index; u32 context; bool is_add; vl_api_abf_policy_t policy; }; typedef abf_itf_attach { u32 policy_id; vl_api_interface_index_t sw_if_index; //依赖interface，interface又会依赖其他资源 u32 priority; bool is_ipv6; }; 可以看到，策略路由首先依赖acl规则，之后将abf绑定至接口时需要依赖对应interface的index，且创建interface又需要依赖其他资源（绑定vrf等）。
除此之外，vpp配置写入存在中间状态与崩溃的问题，且无法避免。“崩溃”类似数据库写入的概念。数据必须要成功写入磁盘、磁带等持久化存储器后才能拥有持久性，只存储在，内存中的数据，一旦遇到应用程序忽然崩溃，或者数据库、操作系统一侧的崩溃，甚至是机器突然断电宕机等情况就会丢失，这些意外情况都统称为“崩溃”。
因此，为了解决vpp（物理交换机也适用）各配置项的依赖关系，以及保证原子性和持久性，实现崩溃恢复，需要在管控面agent侧处理好上述问题。
事务处理 本人对分布式事务领域涉及不深，以下摘自于
本地事务（也可称为局部事务），是单个服务使用单个数据源场景，也就是最基本的本地数据落盘的事务。本地事务要求底层数据源需要支持事务的开启、终止、提交、回滚、嵌套等。在数据库领域（ARIES理论，基于语义的恢复与隔离），感兴趣的可以研究下commiting logging机制（OceanBase）和shadow paging
全局事务，是单个服务多个数据源场景。主要目的是为了解决事务一致性问题，并做到统一提交，统一回滚的功能。例如我有一个全局事务需要在A表中写入记录a（本地事务A），再在B表中写入记录b（本地事务B），A表和B表分别在两台物理机的磁盘上。在数据存储领域由X/Open XA对此发布了一个事务处理架构，且当前很多分布式事务处理框架都是基于此来设计的。主要核心如下：
全局事务管理器（Transaction Manager，TM）：协调全局事务 局部资源管理器（Resource Manaeger，RM）：驱动本地事务 模型：XA，TCC，SAGA，AT 。。。 感兴趣的可以研究下阿里的seata。
事务处理视角看待vpp管控面 本地事务 vpp的配置是内存上的配置，不需要落盘。 vpp的每个资源的api可视为一个数据源 数据源没有实现事务的开启、终止、提交、回滚、嵌套、设置隔离级别等能力，只提供了下发，删除，读取接口 上述数据源未提供的能力需要agent来补齐 全局事务 agent暴露给上层的接口可视为全局事务 有些全局事务只涉及单个数据源，有些全局事务涉及多个数据源 agent内部需要实现TM，将全局事务转为有序的本地事务列表 agent内部需要实现RM，调用vpp api，驱动本地事务的执行 举例：</p><footer><a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 1, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86srv6/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86srv6/>初识srv6</a></h1></header><p>翻译自SRv6 Network Programming draft-filsfils-spring-srv6-network-programming-07
SRH Segment Routing Header
SRH在一个报文中可以有多个
NH ipv6 next-header field
Srv6的Routing Header的type是4，IP6 header的NH字段是43
SID 编排链节点的ID，srv6节点的SID table里面保存自己在各个编排链内的SID。local SID可以是设备外部接口（不会是内部接口）的ipv6地址。例如已经在外部接口配置了地址A和地址B，内部loopback配置了地址C。地址A和地址B会默认被加入到SID Table。
地址B可以是路由不可达的，为什么？
可以将地址A理解成全局segments，地址B为本地segments。只要报文在发送时加入了SID list&lt;A,B>，A在B的前面，只要A对外路由可达，报文就会被送到A，然后在本地进行下一步的处理（发往本地的B）
(SA,DA) (S3, S2, S1; SL)
S1是第一跳，S3是最后一跳。SL剩下几跳，也可理解为下一个SID节点的下标。例如SL=0， 表示SRH[0]=S3，下一个SID处理节点的ip地址是S3
SID格式 SID Table中并不是以Ip的形式保存SID的
LOC:FUNCT:ARGS::
function 每个SID可以绑定多个function。function与SID的绑定关系存在SID Table中。这个特性决定了SRV6的高度可编程性。
function太多，不一一列出，总结下规律
带有D的，表示Decapsulation，如果SL==0（已经是最后一跳）且NH!=SRH(没有嵌套另一个SRH)，且SRH的ENH（下一层header类别）符合function的定义(例如DT6，ENH必须是41(ipv6 encapsulation))，则剥去SRH
带有T的，表示table，查对应的fib表
带有X的，表示cross-connect，往邻接表对应的Ip地址发（直接拿mac）
带V的，表示Vlan，往对应Vlan发（改Vlan头部）
带B的，表示bond，insert在老的SRH和Ipv6 Header之间新插入一个SRH，将DA改为新的SRH的第一个segment；encap则是在最外面新插入一个ipv6头部，新ipv6头部SA是内部ipv6头部的SA，DA是新ipv6头部下的SRH的第一跳</p></article><div class=pagination><a href=/ aria-label=First class=label-pagination><i class="fa fa-angle-double-left fa-lg"></i></a>
<a href=/page/2/ aria-label=Previous class=label-pagination><i class="fa fa-angle-left fa-lg"></i></a>
<a href=/ class=label-pagination>1</a>
<a href=/page/2/ class=label-pagination>2</a>
<a href=/page/3/ class=label-pagination>3</a>
<a href=/page/3/ aria-label=Last><i class="fa fa-angle-double-right fa-lg"></i></a></div></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>