<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>windseek的博客</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><link href=/index.xml rel=alternate type=application/rss+xml title=windseek的博客><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek的博客</a></h1><h2>golang、云计算、SDN、NFV、软件架构</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/tools/>» 工具</option><option value=https://scottlx.github.io/archives/>» 归档</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/tools/ title=工具 target=_blank rel="noopener noreferrer">工具</a></li><li><a href=https://scottlx.github.io/archives/ title=归档 target=_blank rel="noopener noreferrer">归档</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div class=blog-index><article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/>基于事务处理的vpp管控面agent</a></h1></header><p><h3 id=问题背景>问题背景</h3><p>vpp作为vrouter，类似物理交换机，各配置项依赖关系复杂。以下为vpp配置abf策略路由的例子：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>typedef</span> abf_policy
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u32 policy_id;
</span></span><span style=display:flex><span>  u32 acl_index;  <span style=color:#586e75>//依赖acl
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  u8 n_paths;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_fib_path_t</span> paths[n_paths];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>autoreply define abf_policy_add_del
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  option status<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;in_progress&#34;</span>;
</span></span><span style=display:flex><span>  u32 client_index;
</span></span><span style=display:flex><span>  u32 context;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>bool</span> is_add;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_abf_policy_t</span> policy;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>typedef</span> abf_itf_attach
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u32 policy_id;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_interface_index_t</span> sw_if_index; <span style=color:#586e75>//依赖interface，interface又会依赖其他资源
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  u32 priority;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>bool</span> is_ipv6;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可以看到，策略路由首先依赖acl规则，之后将abf绑定至接口时需要依赖对应interface的index，且创建interface又需要依赖其他资源（绑定vrf等）。</p><p>除此之外，vpp配置写入存在中间状态与崩溃的问题，且无法避免。“崩溃”类似数据库写入的概念。数据必须要成功写入磁盘、磁带等持久化存储器后才能拥有持久性，只存储在，内存中的数据，一旦遇到应用程序忽然崩溃，或者数据库、操作系统一侧的崩溃，甚至是机器突然断电宕机等情况就会丢失，这些意外情况都统称为“崩溃”。</p><p>因此，为了解决vpp（物理交换机也适用）各配置项的依赖关系，以及保证原子性和持久性，实现崩溃恢复，需要在管控面agent侧处理好上述问题。</p><h3 id=事务处理>事务处理</h3><p>本人对分布式事务领域涉及不深，以下摘自于</p><p>本地事务（也可称为局部事务），是单个服务使用单个数据源场景，也就是最基本的本地数据落盘的事务。本地事务要求底层数据源需要支持事务的开启、终止、提交、回滚、嵌套等。在数据库领域（ARIES理论，基于语义的恢复与隔离），感兴趣的可以研究下commiting logging机制（OceanBase）和shadow paging</p><p>全局事务，是单个服务多个数据源场景。主要目的是为了解决事务一致性问题，并做到统一提交，统一回滚的功能。例如我有一个全局事务需要在A表中写入记录a（本地事务A），再在B表中写入记录b（本地事务B），A表和B表分别在两台物理机的磁盘上。在数据存储领域由X/Open XA对此发布了一个事务处理架构，且当前很多分布式事务处理框架都是基于此来设计的。主要核心如下：</p><ul><li>全局事务管理器（Transaction Manager，TM）：协调全局事务</li><li>局部资源管理器（Resource Manaeger，RM）：驱动本地事务</li><li>模型：XA，TCC，SAGA，AT 。。。</li></ul><p>感兴趣的可以研究下阿里的seata。</p><h3 id=事务处理视角看待vpp管控面>事务处理视角看待vpp管控面</h3><h4 id=本地事务>本地事务</h4><ul><li>vpp的配置是内存上的配置，不需要落盘。</li><li>vpp的每个资源的api可视为一个数据源</li><li>数据源没有实现事务的开启、终止、提交、回滚、嵌套、设置隔离级别等能力，只提供了下发，删除，读取接口</li><li>上述数据源未提供的能力需要agent来补齐</li></ul><h4 id=全局事务>全局事务</h4><ul><li>agent暴露给上层的接口可视为全局事务</li><li>有些全局事务只涉及单个数据源，有些全局事务涉及多个数据源</li><li>agent内部需要实现TM，将全局事务转为有序的本地事务列表</li><li>agent内部需要实现RM，调用vpp api，驱动本地事务的执行</li></ul><p>举例：</p></p><footer><a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Oct 1, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86srv6/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86srv6/>初识srv6</a></h1></header><p><p>翻译自SRv6 Network Programming
draft-filsfils-spring-srv6-network-programming-07</p><h3 id=srh>SRH</h3><p>Segment Routing Header</p><p>SRH在一个报文中可以有多个</p><h3 id=nh>NH</h3><p>ipv6 next-header field</p><p>Srv6的Routing Header的type是4，IP6 header的NH字段是43</p><h3 id=sid>SID</h3><p>编排链节点的ID，srv6节点的SID table里面保存自己在各个编排链内的SID。local SID可以是设备外部接口（不会是内部接口）的ipv6地址。例如已经在外部接口配置了地址A和地址B，内部loopback配置了地址C。地址A和地址B会默认被加入到SID Table。</p><p>地址B可以是路由不可达的，为什么？</p><p>可以将地址A理解成全局segments，地址B为本地segments。只要报文在发送时加入了SID list&lt;A,B>，A在B的前面，只要A对外路由可达，报文就会被送到A，然后在本地进行下一步的处理（发往本地的B）</p><p>(SA,DA) (S3, S2, S1; SL)</p><p>S1是第一跳，S3是最后一跳。SL剩下几跳，也可理解为下一个SID节点的下标。例如SL=0， 表示SRH[0]=S3，下一个SID处理节点的ip地址是S3</p><h3 id=sid格式>SID格式</h3><p>SID Table中并不是以Ip的形式保存SID的</p><p>LOC:FUNCT:ARGS::</p><h3 id=function>function</h3><p>每个SID可以绑定多个function。function与SID的绑定关系存在SID Table中。这个特性决定了SRV6的高度可编程性。</p><p>function太多，不一一列出，总结下规律</p><p>带有D的，表示Decapsulation，如果SL==0（已经是最后一跳）且NH!=SRH(没有嵌套另一个SRH)，且SRH的ENH（下一层header类别）符合function的定义(例如DT6，ENH必须是41(ipv6 encapsulation))，则剥去SRH</p><p>带有T的，表示table，查对应的fib表</p><p>带有X的，表示cross-connect，往邻接表对应的Ip地址发（直接拿mac）</p><p>带V的，表示Vlan，往对应Vlan发（改Vlan头部）</p><p>带B的，表示bond，insert在老的SRH和Ipv6 Header之间新插入一个SRH，将DA改为新的SRH的第一个segment；encap则是在最外面新插入一个ipv6头部，新ipv6头部SA是内部ipv6头部的SA，DA是新ipv6头部下的SRH的第一跳</p></p></article><div class=pagination><a href=/ aria-label=First class=label-pagination><i class="fa fa-angle-double-left fa-lg"></i></a>
<a href=/page/2/ aria-label=Previous class=label-pagination><i class="fa fa-angle-left fa-lg"></i></a>
<a href=/ class=label-pagination>1</a>
<a href=/page/2/ class=label-pagination>2</a>
<a href=/page/3/ class=label-pagination>3</a>
<a href=/page/3/ aria-label=Last><i class="fa fa-angle-double-right fa-lg"></i></a></div></div><aside class="sidebar thirds"><section class="first odd"><h1>Sidebar Header</h1><p><p>Here&rsquo;s a
<a href=https://www.google.com target=_blank rel=noopener>link to google</a></p><p>New paragraph</p><p>Another paragraph which has two spaces in the end to create a new line using markdown<br>New line but not a new paragraph</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a></li></ul><section class=odd><h1>Sidebar Links</h1><li><a href=https://scottlx.github.io/about title="About me">About me</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>