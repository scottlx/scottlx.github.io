<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>windseek</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><link href=/index.xml rel=alternate type=application/rss+xml title=windseek><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» 归档</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=归档>归档</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div class=blog-index><article><header><p class=meta>Mar 6, 2025
- 11 minute read
- <a href=https://scottlx.github.io/posts/bpf_lpm_trie/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>bpf lpm trie</h1></header><p><p>lpm有多种实现方式，最常用的是用trie。当然也会有更简单的实现方式，例如某些特定场景用多重哈希表就能解决（ipv4地址，32个掩码对应32个哈希表）</p><p>从4.11内核版本开始，bpf map引入了<code>BPF_MAP_TYPE_LPM_TRIE</code></p><p>主要是用于匹配ip地址，内部是将数据存储在一个不平衡的trie中，key使用<code>prefixlen,data</code></p><p>data是以大端网络序存储的，data[0]存的是msb。</p><p>prefixlen支持8的整数倍，最高可以是2048。因此除了ip匹配，还可以用来做端口，协议，vpcid等等的扩充匹配。在应用层面上除了做路由表，还可以作为acl，policy等匹配过滤的底层实现</p><h4 id=使用方式>使用方式</h4><p><a href=https://docs.kernel.org/next/bpf/map_lpm_trie.html target=_blank rel=noopener>BPF_MAP_TYPE_LPM_TRIE — The Linux Kernel documentation</a></p><p>除了上述基本的Ipv4的使用方式，扩展使用方式可以参考一下cillium中IPCACHE_MAP的使用</p><p>首先是map的定义</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> ipcache_key {
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> bpf_lpm_trie_key lpm_key;
</span></span><span style=display:flex><span>	__u16 cluster_id;
</span></span><span style=display:flex><span>	__u8 pad1;
</span></span><span style=display:flex><span>	__u8 family;
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>			__u32		ip4;
</span></span><span style=display:flex><span>			__u32		pad4;
</span></span><span style=display:flex><span>			__u32		pad5;
</span></span><span style=display:flex><span>			__u32		pad6;
</span></span><span style=display:flex><span>		};
</span></span><span style=display:flex><span>		<span style=color:#719e07>union</span> v6addr	ip6;
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>} __packed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>/* Global IP -&gt; Identity map for applying egress label-based policy */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(type, BPF_MAP_TYPE_LPM_TRIE);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(key, <span style=color:#719e07>struct</span> ipcache_key);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(value, <span style=color:#719e07>struct</span> remote_endpoint_info);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(pinning, LIBBPF_PIN_BY_NAME);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(max_entries, IPCACHE_MAP_SIZE);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(map_flags, BPF_F_NO_PREALLOC);
</span></span><span style=display:flex><span>} IPCACHE_MAP __section_maps_btf;
</span></span></code></pre></div><p>可以看到cillium将v4和v6合并成一个map查询，匹配条件并带上了<code>cluster_id</code></p></p><footer><a href=https://scottlx.github.io/posts/bpf_lpm_trie/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Mar 3, 2025
- 5 minute read
- <a href=https://scottlx.github.io/posts/cilium-datapath/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/cilium-datapath/>cilium datapath</a></h1></header><p><h3 id=hook点>hook点</h3><p>大部分是挂载位置是tc，tc是网络协议栈初始处理挂载点</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// linux source code: dev.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>__netif_receive_skb_core
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>list_for_each_entry_rcu</span>(ptype, <span style=color:#719e07>&amp;</span>ptype_all, list) {...} <span style=color:#586e75>// packet capture
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> do_xdp_generic <span style=color:#586e75>// handle generic xdp
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> sch_handle_ingress <span style=color:#586e75>// tc ingress
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>|</span> tcf_classify
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> __tcf_classify <span style=color:#586e75>// ebpf program is working here
</span></span></span></code></pre></div><p>如果没有下发policy，xdp就不会挂载各类filter程序</p><p><img src=https://rexrock.github.io/post-images/1614297388691.png alt="cilium datapath"></p><h3 id=网络设备>网络设备</h3><p>cillium的网络方案不像常规的网桥模式（ovs，linux bridge），datapath不是一个完整的run to completion，而是分散在各个虚拟接口上，类似pipeline模式</p><p>cillium_host: 集群内所有podCIDR的网关，地址对容器可见</p><p>cilium_net: cilium_host的veth对，ipvlan模式才会用到？</p><p>clilium_vxlan: 用来提供Pod跨节点通信overlay封装</p><p>lxcXXXX: 容器veth对在主机侧的接口</p><h3 id=同节点pod2pod>同节点pod2pod</h3><p>cillium_host是所有pod的网关，因此会先arp request该地址。arp相应其实是在lxc处被代答了，arp报文不会走到cillium_host</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>__section_entry
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>cil_from_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>	<span style=color:#719e07>case</span> <span style=color:#268bd2>bpf_htons</span>(ETH_P_ARP)<span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>		ret <span style=color:#719e07>=</span> <span style=color:#268bd2>tail_call_internal</span>(ctx, CILIUM_CALL_ARP, <span style=color:#719e07>&amp;</span>ext_err);
</span></span><span style=display:flex><span>		<span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>__section_tail</span>(CILIUM_MAP_CALLS, CILIUM_CALL_ARP)
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>tail_handle_arp</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> macaddr mac <span style=color:#719e07>=</span> THIS_INTERFACE_MAC;
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> macaddr smac;
</span></span><span style=display:flex><span>	__be32 sip;
</span></span><span style=display:flex><span>	__be32 tip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Pass any unknown ARP requests to the Linux stack */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span><span style=color:#268bd2>arp_validate</span>(ctx, <span style=color:#719e07>&amp;</span>mac, <span style=color:#719e07>&amp;</span>smac, <span style=color:#719e07>&amp;</span>sip, <span style=color:#719e07>&amp;</span>tip))
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> CTX_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/*
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * The endpoint is expected to make ARP requests for its gateway IP.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * Most of the time, the gateway IP configured on the endpoint is
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * IPV4_GATEWAY but it may not be the case if after cilium agent reload
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * a different gateway is chosen. In such a case, existing endpoints
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * will have an old gateway configured. Since we don&#39;t know the IP of
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * previous gateways, we answer requests for all IPs with the exception
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * of the LXC IP (to avoid specific problems, like IP duplicate address
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * detection checks that might run within the container).
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (tip <span style=color:#719e07>==</span> LXC_IPV4)
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> CTX_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> <span style=color:#268bd2>arp_respond</span>(ctx, <span style=color:#719e07>&amp;</span>mac, tip, <span style=color:#719e07>&amp;</span>smac, sip, <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>普通ipv4报文，走handle_ipv4_from_lxc</p></p><footer><a href=https://scottlx.github.io/posts/cilium-datapath/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Feb 18, 2025
- 1 minute read
- <a href=https://scottlx.github.io/posts/dpvs-icmp/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/dpvs-icmp/>dpvs icmp session</a></h1></header><p><p>原生的ipvs仅处理三种类型的ICMP报文：ICMP_DEST_UNREACH、ICMP_SOURCE_QUENCH和ICMP_TIME_EXCEEDED</p><p>对于不是这三种类型的ICMP，则设置为不相关联(related)的ICMP，返回NF_ACCEPT，之后走本机路由流程</p><p>dpvs对ipvs进行了一些修改，修改后逻辑如下</p><h2 id=icmp差错报文流程>icmp差错报文流程</h2><ul><li><p>__dp_vs_in</p></li><li><p>__dp_vs_in_icmp4 （处理icmp差错报文，入参related表示找到了关联的conn）</p><p>若不是ICMP_DEST_UNREACH，ICMP_SOURCE_QUENCH，ICMP_TIME_EXCEEDED，返回到_dp_vs_in走普通conn命中流程</p><p>icmp差错报文，需要将报文头偏移到icmp头内部的ip头，<strong>根据内部ip头查找内部ip的conn</strong>。</p><p>若找到conn，<strong>表明此ICMP报文是由之前客户端的请求报文所触发的，由真实服务器回复的ICMP报文</strong>。将related置1</p><p>若未找到则返回accept，返回到_dp_vs_in走普通conn命中流程</p><ul><li>​ __xmit_inbound_icmp4</li></ul><p>​ 找net和local路由，之后走__dp_vs_xmit_icmp4</p><ul><li>__dp_vs_xmit_icmp4</li></ul><p>​ 数据区的前8个字节恰好覆盖了TCP报文或UDP报文中的端口号字段（前四个字节）</p><p>inbound方向根据内部ip的conn修改数据区目的端口为conn->dport，源端口改为conn->localport，</p><p>outbound方向将目的端口改为conn->cport，源端口改为conn->vport</p><p>​</p><p>client (cport ) &lt;&ndash;> (vport)lb(lport) &lt;&ndash;> rs(dport)</p><p>​ 重新计算icmp头的checksum，走ipv4_output</p></li></ul><p><img src=/img/dpvs/icmp%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87.png alt=报文格式></p><p><strong>实际应用上的问题</strong></p><p>某个rs突然下线，导致有时访问vip轮询到了不可达的rs，rs侧的网关发送了一个dest_unreach的icmp包</p><p>该rs的conn还未老化，__dp_vs_in_icmp4流程根据这个icmp的内部差错ip头找到了还未老化的conn，将icmp数据区的port进行修改发回给client</p><p>但是一般情况，rs下线后，该rs的conn会老化消失，内层conn未命中，还是走外层icmp的conn命中流程转给client。这样内部数据区的端口信息是错的（dport->lport，正确情况是vport->cport）</p><h2 id=非差错报文流程>非差错报文流程</h2><p>返回_dp_vs_in走普通conn命中流程</p><p>原本dp_vs_conn_new流程中，先查找svc。icmp的svc默认使用端口0进行查找。但是ipvsadm命令却对端口0的service添加做了限制，导致无法添加这类svc。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> svc <span style=color:#719e07>=</span> <span style=color:#268bd2>dp_vs_service_lookup</span>(iph<span style=color:#719e07>-&gt;</span>af, iph<span style=color:#719e07>-&gt;</span>proto, <span style=color:#719e07>&amp;</span>iph<span style=color:#719e07>-&gt;</span>daddr, <span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>,                               mbuf, <span style=color:#b58900>NULL</span>, <span style=color:#719e07>&amp;</span>outwall, <span style=color:#268bd2>rte_lcore_id</span>());
</span></span></code></pre></div><p>若未查到走INET_ACCEPT(也就是继续往下进行走到ipv4_output_fin2查到local路由，若使用dpip addr配上了vip或lip地址，则会触发本地代答)。</p><p>若查到svc，则进行conn的schedule，之后会走dp_vs_laddr_bind，但是dp_vs_laddr_bind不支持icmp协议(可以整改)，最终导致svc可以查到但是conn无法建立，最后走INET_DROP。</p><p>概括一下：</p><ul><li><ul><li>未命中svc，走后续local route，最终本地代答</li><li>命中svc后若conn无法建立，drop</li><li>命中svc且建立conn，发往rs或client</li></ul></li></ul><h3 id=icmp的conn>icmp的conn</h3><p>​</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>_ports[<span style=color:#2aa198>0</span>] <span style=color:#719e07>=</span> <span style=color:#268bd2>icmp4_id</span>(ich);
</span></span><span style=display:flex><span>_ports[<span style=color:#2aa198>1</span>] <span style=color:#719e07>=</span> ich<span style=color:#719e07>-&gt;</span>type <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>8</span> <span style=color:#719e07>|</span> ich<span style=color:#719e07>-&gt;</span>code;
</span></span></code></pre></div><p>Inbound hash和outboundhash的五元组都使用上述这两个port进行哈希，并与conn进行关联。</p><p>具体的laddr和lport保存在conn里面。其中只用到laddr做l3的fullnat。由于icmp协议没有定义proto->fnat_in_handler，因此fnat时，从sa_pool分配到的lport对于icmp来说没有用。</p><p>试想ping request和ping reply场景：</p><p>由于request和reply的ich->type不一样，outboundhash必定不命中(且fnat流程中的laddr_bind还会修改一次outboundhashtuple的dport，修改成sapool分配的port，因此也不会命中outbound hash)。</p><p><strong>一次来回的ping会创建两个conn，且都只命中inboundhash。</strong></p><h2 id=个人认为比较合理的方案>个人认为比较合理的方案</h2><h4 id=ipvsadm>ipvsadm</h4><p>放通port=0的svc的创建，用户需要fwd icmp to rs时，需要添加icmp类型的svc。否则icmp会被vip或者lip代答，不会透传到rs或client</p><h4 id=icmp差错报文>icmp差错报文</h4><p>保持原状，对找不到关联的conn连接的差错报文进行drop。</p></p><footer><a href=https://scottlx.github.io/posts/dpvs-icmp/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Feb 18, 2025
- 1 minute read
- <a href=https://scottlx.github.io/posts/dpvs-route%E8%BD%AC%E5%8F%91/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/dpvs-route%E8%BD%AC%E5%8F%91/>dpvs route转发</a></h1></header><p><p>ipv4_rcv_fin 是路由转发逻辑， INET_HOOKPRE_ROUTING 中走完hook逻辑后，根据dpvs返回值走ipv4_rcv_fin</p><h2 id=路由表结构体>路由表结构体</h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> route_entry {
</span></span><span style=display:flex><span>    <span style=color:#dc322f>uint8_t</span> netmask;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>short</span> metric;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>uint32_t</span> flag;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> mtu;
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> list_head list;
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> in_addr dest; <span style=color:#586e75>//cf-&gt;dst.in
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> in_addr gw;<span style=color:#586e75>// 下一跳地址，0说明是直连路由，下一跳地址就是报文自己的目的地址，对应配置的cf-&gt;via.in
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> in_addr src; <span style=color:#586e75>// cf-&gt;src.in， 源地址策略路由匹配
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>struct</span> netif_port <span style=color:#719e07>*</span>port;  <span style=color:#586e75>// 出接口
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#dc322f>rte_atomic32_t</span> refcnt;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=路由类型>路由类型</h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/* dpvs defined. */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>#define RTF_FORWARD     0x0400
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define RTF_LOCALIN     0x0800
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define RTF_DEFAULT     0x1000
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define RTF_KNI         0X2000
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define RTF_OUTWALL     0x4000
</span></span></span></code></pre></div><h2 id=路由表类型>路由表类型</h2><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>#define this_route_lcore        (RTE_PER_LCORE(route_lcore))
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define this_local_route_table  (this_route_lcore.local_route_table)
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define this_net_route_table    (this_route_lcore.net_route_table)
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define this_gfw_route_table    (this_route_lcore.gfw_route_table)
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define this_num_routes         (RTE_PER_LCORE(num_routes))
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define this_num_out_routes      (RTE_PER_LCORE(num_out_routes))
</span></span></span></code></pre></div><ul><li>Local 类型路由</li></ul><p>local 类型路由的作用和 Linux 下的 local 路由表的功能基本一样，主要是记录本地的 IP 地址。
我们知道进入的数据包，过了 prerouting 后是需要经过路由查找，如果确定是本地路由（本地 IP）就会进入 LocalIn 位置，否则丢弃或进入 Forward。</p></p><footer><a href=https://scottlx.github.io/posts/dpvs-route%E8%BD%AC%E5%8F%91/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Feb 18, 2025
- 1 minute read
- <a href=https://scottlx.github.io/posts/dpvs-session%E5%90%8C%E6%AD%A5/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/dpvs-session%E5%90%8C%E6%AD%A5/>dpvs session 同步</a></h1></header><p><h2 id=总体架构>总体架构</h2><h4 id=lb-session同步采用分布式架构session创建流程触发session数据发送依次向集群内所有其他节点发送>lb session同步采用分布式架构，session创建流程触发session数据发送，依次向集群内所有其他节点发送</h4><p>其他节点收到新的session数据修改本地session表。
session接收和发送各占一个独立线程。</p><h3 id=step1-向所有其他节点发送session数据>step1: 向所有其他节点发送session数据</h3><p>remote session：从别的节点同步来的session</p><p>local session：本节点收到数据包自己生成的session</p><h3 id=step2-session同步至worker>step2: session同步至worker</h3><h4 id=方案一有锁>方案一（有锁）：</h4><p><img src=/img/dpvs/session%E5%90%8C%E6%AD%A5%E6%9C%89%E9%94%81.png alt="Alt text"></p><p>• 独立进程和core处理session同步（per numa）
• 每个lcore分配local session和remote session，正常情况下都能直接从local session走掉
• 同步过来的session写到remote session表
• session ip根据fdir走到指定进程</p><h4 id=方案二无锁>方案二（无锁）：</h4><p><img src=/img/dpvs/session%E5%90%8C%E6%AD%A5%E6%97%A0%E9%94%81.png alt="Alt text">
• 独立进程和core处理session同步消息
• 每个lcore 有来local session和remote session，通过owner属性区分。
• 同步过来的session由session_sync core发消息给对应的slave，由对应的slave进行读写，因此可以做到无锁。
• session ip根据fdir走到指定core</p><h4 id=session同步具体实现>session同步具体实现</h4><h5 id=亟待解决的问题>亟待解决的问题：</h5><ol><li><p>同步过来的session什么时候老化？</p></li><li><p>别的节点上线，本节点要发送哪些session？</p></li><li><p>别的节点下线，本节点要删除哪些session？</p></li><li><p>是否要响应下线节点的删除/老化请求？</p></li><li><p>下线节点怎么知道自己已经下线（数据面）？</p></li></ol><h5 id=解决方案>解决方案：</h5><h6 id=方案一-session增加owner属性c>方案一： session增加owner属性c</h6><p>owner属性：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>conn.owner <span style=color:#586e75>// indicates who has this session
</span></span></span></code></pre></div><p>session 同步状态转移图</p><p><img src=/img/dpvs/session%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png alt="Alt text"></p><p>一条session在一个集群中，应当只有一台机器在使用，所以有一个owner属性，代表这条session被谁拥有，其它所有机器只对这条session的owner发起的增删改查请求做响应。</p><p><strong>同步动作</strong>
session同步应当时实时的。在以下场景被触发：
<strong>新建session</strong>
发送方：
session新建完成之后：对于tcp，是握手完毕的；对于udp，是第一条连接。
接收方：
接收来自发送方的session，在对应core上新建这条连接，开启老化，老化时间设定为默认时间（1小时）。
fin/rst
发送方：
发送删除session消息
接收方：
接收方接收session，做完校验后在对应core上删除session
<strong>老化</strong>
发送方：
老化时间超时之后，本地session删除，同时发布老化信息，告知其它lb，
接收方：
其它lb 做完校验后，开始老化这条session。
<strong>设备下线</strong>
下线后通过控制器更新其他lb的session同步地址信息，不再向该设备同步，同时开始老化全部属于该设备的session。
<strong>设备上线（包含设备扩容）</strong>
新设备：
新上线设备引流前要接收其他设备的存量session信息，这个功能通过控制器触发完成，控制器感知到新lb上线后通知集群内其他lb向它同步存量session，session数量达到一致时（阿里gw用70%阈值）允许新lb引流。
旧设备：
向目的方发送全部的属于自己的session。</p></p><footer><a href=https://scottlx.github.io/posts/dpvs-session%E5%90%8C%E6%AD%A5/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Feb 18, 2025
- 3 minute read
- <a href=https://scottlx.github.io/posts/dpvs%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/dpvs%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/>dpvs 数据流分析</a></h1></header><p><h2 id=dpvs-ingress流程分析>dpvs ingress流程分析</h2><p>从 <em>lcore_job_recv_fwd</em> 开始，这个是dpvs收取报文的开始</p><h3 id=设备层>设备层</h3><p>dev->flag & NETIF_PORT_FLAG_FORWARD2KNI &mdash;> 则拷贝一份mbuf到kni队列中，这个由命令行和配置文件决定（做流量镜像，用于抓包）</p><h3 id=eth层>eth层</h3><p><em>netif_rcv_mbuf</em> 这里面涉及到vlan的部分不做过多解析</p><ul><li><p>不支持的协议</p><p>目前dpvs支持的协议为ipv4, ipv6, arp。 其它报文类型直接丢给内核。其他类型可以看
<a href=https://en.wikipedia.org/wiki/EtherType#cite_note-ethtypes-3 target=_blank rel=noopener>eth_types</a>。
<a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p>RTE_ARP_OP_REPLY</p><p>复制 <em>nworks-1</em> 份mbuf，发送到其它worker的arp_ring上 ( <em><strong>to_other_worker</strong></em> ), 这份报文fwd到
<a href=#arp%e5%8d%8f%e8%ae%ae>arp协议</a>.</p></li><li><p>RTE_ARP_OP_REQUEST</p><p>这份报文fwd到
<a href=#arp%e5%8d%8f%e8%ae%ae>arp协议</a>.</p></li></ul><h3 id=arp协议>arp协议</h3><ul><li><p>arp协议处理 <em>neigh_resolve_input</em></p><ul><li><p>RTE_ARP_OP_REPLY</p><p>建立邻居表，记录信息，并且把这个报文送给内核。
<a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p>RTE_ARP_OP_REQUEST</p><p>无条件返回网卡的ip以及mac地址 (<em>free arp</em>), <em>netif_xmit</em> 发送到
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></p></li><li><p>其它op_code</p><p><a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li></ul></li></ul><h3 id=ip层>ip层</h3><ul><li>ipv4协议 (ipv6数据流程上一致)<ul><li><p><em>ipv4_rcv</em></p><ul><li><p>ETH_PKT_OTHERHOST</p><p>报文的dmac不是自己，
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>ipv4 协议校验</p><p>不通过，
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>下一层协议为 IPPROTO_OSPF</p><p><a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p><em>INET_HOOK_PRE_ROUTING hook</em></p><p>hook_list: <em>dp_vs_in</em> , <em>dp_vs_prerouting</em></p><p>这两个都与synproxy有关系，但是我们不会启用这个代理，不过需要注意的是syncproxy不通过时会丢包
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p><ul><li><p>dp_vs_in</p><ul><li><p>非 ETH_PKT_HOST(broadcast 或者 multicast报文)或ip报文交给 <em>ipv4_rcv_fin</em> 处理</p></li><li><p>非 udp, tcp, icmp, icmp6报文交给 <em>ipv4_rcv_fin</em> 处理</p></p><footer><a href=https://scottlx.github.io/posts/dpvs%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Dec 8, 2023
- 1 minute read
- <a href=https://scottlx.github.io/posts/dpdk-rcu/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/dpdk-rcu/>dpdk rcu lib</a></h1></header><p><p>linux的RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改。RCU适用于需要频繁的读取数据，而相应修改数据并不多的情景。</p><p>dpdk中由于writer和reader同时访问一段内存，删除元素的时候需要确保</p><ol><li>删除时不会将内存put回allocator，而是删掉这段内存的引用。这样确保了新的访问者不会拿到这个元素的引用，而老的访问者不会在访问过程中core掉</li><li>只有在元素没有任何引用计数时，才释放掉该元素的内存</li></ol><p>静默期是指线程没有持有共享内存的引用的时期，也就是下图绿色的时期</p><p><img src=https://doc.dpdk.org/guides/_images/rcu_general_info.svg alt=rcu></p><p>上图中，有三个read thread，T1， T2，T3。两条黑色竖线分别代表writer执行delete和free的时刻。</p><p>执行delete时，T1和T2还拿着entry1和entry2的reference，此时writer还不能free entry1或entry2的内存，只能删除元素的引用.</p><p>writer<em><strong>必须等到执行delete时，当时引用该元素的的线程，都完成了一个静默期之后</strong></em>，才可以free这个内存。</p><p>writer不需要等T3进入静默期，因为执行delete时，T3还在静默期。</p><p>如何实现RCU机制</p><ol><li>writer需要一直轮询reader的状态，看是否进入静默期。这样会导致一直循环轮询，造成额外的cpu消耗。由于需要等reader的静默期结束，reader的静默期越长，reader的数量越多，writer cpu的消耗会越大，因此我们需要短的grace period。但是如果将reader的critical section减小，虽然writer的轮询变快了，但是reader的报告次数增加，reader的cpu消耗会增加，因此我们需要长的critical section。这两者之间看似矛盾。</li><li>长的critical section：dpdk的lcore一般都是一个while循环。循环的开始和结束必定是静默期。循环的过程中肯定是在访问各种各样的共享内存。因此critical section的粒度可以不要很细，不要每次访问的时候退出静默期，不访问的时候进入静默期，而是将整个循环认为是critical section，只有在循环的开始退出静默期，循环的结束进入静默期。</li><li>短的grace period：如果是pipeline模型，并不是所有worker都会使用相同的数据结构。话句话说，同一个元素，只会被部分的worker所引用和读取。因此writer不需要等到所有worker的critical section结束，而是使用该元素的worker结束critical section。这样将grace period粒度变小之后，缩短了writer整体的grace period。这种粒度的控制是通过 qsbr 实现的</li></ol><h2 id=如何使用rcu库>如何使用rcu库</h2><p>dpdk-stable-20.11.1/app/test/test_rcu_qsbr.c test_rcu_qsbr_sw_sv_3qs</p><p>先创建出struct rte_rcu_qsbr</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    sz <span style=color:#719e07>=</span> <span style=color:#268bd2>rte_rcu_qsbr_get_memsize</span>(RTE_MAX_LCORE);
</span></span><span style=display:flex><span>    rv <span style=color:#719e07>=</span> (<span style=color:#719e07>struct</span> rte_rcu_qsbr <span style=color:#719e07>*</span>)<span style=color:#268bd2>rte_zmalloc</span>(<span style=color:#b58900>NULL</span>, sz, RTE_CACHE_LINE_SIZE);
</span></span></code></pre></div><p>再初始化QS variable</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#268bd2>rte_rcu_qsbr_init</span>(rv, RTE_MAX_LCORE);
</span></span></code></pre></div><p>Reader注册自己的线程号，并上线（将自己加到writer的轮询队列里面）
online时会原子读qsbr里的token，并设置到v->qsbr_cnt[thread_id].cnt中</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>(<span style=color:#dc322f>void</span>)<span style=color:#268bd2>rte_rcu_qsbr_thread_register</span>(rv, lcore_id);
</span></span><span style=display:flex><span><span style=color:#268bd2>rte_rcu_qsbr_thread_online</span>(rv, lcore_id);
</span></span></code></pre></div><p>每次读取共享数据后，更新自己的静默状态（rte_rcu_qsbr_quiescent）</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#719e07>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> (i <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; i <span style=color:#719e07>&lt;</span> num_keys; i <span style=color:#719e07>+=</span> j) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;</span> QSBR_REPORTING_INTERVAL; j<span style=color:#719e07>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#268bd2>rte_hash_lookup</span>(tbl_rwc_test_param.h,
</span></span><span style=display:flex><span>                        keys <span style=color:#719e07>+</span> i <span style=color:#719e07>+</span> j);
</span></span><span style=display:flex><span>            <span style=color:#586e75>/* Update quiescent state counter */</span>
</span></span><span style=display:flex><span>            <span style=color:#268bd2>rte_rcu_qsbr_quiescent</span>(rv, lcore_id);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#719e07>while</span> (<span style=color:#719e07>!</span>writer_done);
</span></span></code></pre></div><p>rte_rcu_qsbr_quiescent 是将qsbr->token更新到自己thread的token里去v->qsbr_cnt[thread_id].cnt</p></p><footer><a href=https://scottlx.github.io/posts/dpdk-rcu/ rel=full-article>继续阅读 →</a></footer></article><article><header><p class=meta>Apr 7, 2023
- 1 minute read
- <a href=https://scottlx.github.io/posts/contiv-memif/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/contiv-memif/>contiv memif</a></h1></header><p><h3 id=contiv-memif>contiv memif</h3><p>contiv的cni与device plugin相结合，实现了：</p><ol><li>Pod能同时接入不止一张网卡</li><li>Pod接入的网卡可以是tap，veth，memif</li></ol><h4 id=deviceplugin>devicePlugin</h4><p>Device Plugin实际是一个运行在Kubelet所在的Node上的gRPC server，通过Unix Socket、基于以下（简化的）API来和Kubelet的gRPC server通信，并维护对应设备资源在当前Node上的注册、发现、分配、卸载。
其中，<code>ListAndWatch()</code>负责对应设备资源的discovery和watch；<code>Allocate()</code>负责设备资源的分配。</p><p><img src=/img/vpp-agent/6F9684EB-7E5E-4b77-9316-32D5C92FD07E.png alt=6F9684EB-7E5E-4b77-9316-32D5C92FD07E></p><h4 id=insight>Insight</h4><p><img src=/img/vpp-agent/contiveCNI.drawio.png alt=contiveCNI.drawio></p><h5 id=kubelet>kubelet</h5><p>kubelet接收上图格式的API。API中的annotations定义了pod的网卡个数与类型，resources中定义了所需要的device plugin的资源，也就是memif。</p><p>kubelet执行常规的syncPod流程，调用contiv cni创建网络。此时会在请求中将annotation传递给cni。</p><p>同时，agent的DevicePluginServer会向kubelet注册rpc服务，注册contivpp.io/memif的设备资源，从而kubelet的device manager会grpc请求DevicePluginServer获取contivpp.io/memif设备资源。</p><h5 id=cni>cni</h5><p>cni实现了github.com/containernetworking/cni标准的add和del接口。实际上做的事情只是将cni请求转换为了对agent的grpc请求：解析args，并通过grpc调用agent的接口发送cniRequest，再根据grpc的返回结果，将结果再次转换成标准cni接口的返回格式</p><h5 id=agent>Agent</h5><h6 id=podmanager>podmanager</h6><p>podmanager实现了上述cni调用的grpc server，主要任务是将cni的request转换为内部的event数据格式，供event loop处理。</p><p>request是cni定义的请求数据类型，详见https://github.com/containernetworking/cni/blob/master/SPEC.md#parameters</p><p>event则是agent内部的关于pod事务模型，类似原生kvScheduler的针对vpp api的transaction。每一种event都会对应一个plugin去实现他的handler，供event loop调用。</p><h6 id=event-loop>event loop</h6><p>event loop是整个contiv agent的核心处理逻辑，北向对接event queue，南向调用各个EventHandler，将event转换为kvScheduler的事务。</p><p>执行了以下步骤：</p><ol><li>对事件的预处理，包括校验，判断事件类型，加载必要的配置等</li><li>判断是否是更新的事件</li><li>对事件的handler进行排序，并生成正向或回退的handler顺序</li><li>与本次事件无关的handler过滤掉</li><li>创建对这次事件的记录record</li><li>打印上述步骤生成的所有事件相关信息</li><li>执行事件更新或同步，生成vpp-agent里的事务</li><li>将contiv生成的配置与外部配置进行merge，得到最终配置</li><li>将最终配置的vpp-agent事务commit到agent的kvscheduler</li><li>若事务失败，将已经完成的操作进行回退</li><li>完成事件，输出记录record与计时</li><li>打印回退失败等不可恢复的异常</li><li>若开启一致性检查，则最好再执行一次同步校验</li></ol><h6 id=devicemanager>devicemanager</h6><p>devicemanager既实现了对接kublet的DevicePluginServer，又实现了AllocateDevice类型的event的handler。换句话说是自己产生并处理自己的event。</p><p>主要业务逻辑：</p><ol><li><p>创建memif socket文件的目录并挂载至容器</p></li><li><p>创建连接socket的secret。</p></li></ol><p>上述的创建并不是真实的创建，而是把需要的信息(event.Envs, event.Annotations, event.Mounts)通过grpc返回给kublet，让kubelet去创建。</p><p>devicemanager还会将上述memif的信息保存在缓存中，供其他插件来获取。若缓存中信息不存在，则会调用kubelet的api获取信息。</p><h6 id=ipnet>ipNet</h6><p>ipNet插件主要负责node和pod中各类网卡的创建销毁，vxlan的分配，vrf的分配等</p><p>更新网卡时，ipnet会读取annotation中kv，判断网卡类型。若类型为memif，则会向deviceManager获取当前pod里各容器的memifInfo，之后根据memifInfo里的socket地址和secret，创建memif类型的网卡事务，并 push 至kvscheduler</p></p></article><article><header><p class=meta>Mar 20, 2023
- 2 minute read
- <a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/>数位dp</a></h1></header><p><h2 id=题目特征>题目特征</h2><ul><li><p>要求统计满足一定条件的数的数量（即，最终目的为计数，若要结果则只能回溯爆搜得到）；</p></li><li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p></li><li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p></li><li><p>上界很大（比如 10^{18}），暴力枚举验证会超时。</p></li></ul><h2 id=思路>思路</h2><p>从高到低枚举每一位，统计符合target的个数，并记录到dp数组中。枚举完毕之后则得到答案。</p><p>因此数位dp的第一个状态都是数位的位置，第二个状态由题意来定</p><h2 id=模板>模板</h2><p>以leetcode1012为例，统计小于等于n的数字中每一位的数字至少重复一次的个数。</p><p>模板时灵神的模板。难点主要是mask，isLimit，isNum这几个标识</p><ul><li>mask即dp的第二个状态，这边用到了状态压缩的思想，将0到9选过的状态压缩成一个数字(否则要10个状态)</li><li>isLimit 标识了本次(i)选择的范围，是否受到n的影响。如果不引进这个变量，则需要考虑当前数字的最高位来决定本次的范围(最高位==n的最高位时，本次的范围是[0,s[i]],最高位&lt;n的最高位时，本次的范围是[0,9])。可以发现这个限制是有传递的性质的，因此引入这个变量能简化范围的选择过程。</li><li>isNum 标识了本次(i)之前是否有数字，换句话说本次(i)是否是第一个数字(最高位)。这个标识主要是解决前导0的问题，否则答案里会重复(前导两个0和前导三个0虽然是同个数字，但都会被记入答案)</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>numDupDigitsAtMostN</span>(n <span style=color:#dc322f>int</span>) (ans <span style=color:#dc322f>int</span>) {
</span></span><span style=display:flex><span>	s <span style=color:#719e07>:=</span> strconv.<span style=color:#268bd2>Itoa</span>(n) <span style=color:#586e75>// s[0]是最高位</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* 若需要从低到高的顺序，则按如下生成
</span></span></span><span style=display:flex><span><span style=color:#586e75>		for ; n &gt; 0; n = n / 10 {
</span></span></span><span style=display:flex><span><span style=color:#586e75>	        list = append(list, n%10)
</span></span></span><span style=display:flex><span><span style=color:#586e75>	    }
</span></span></span><span style=display:flex><span><span style=color:#586e75>	*/</span>
</span></span><span style=display:flex><span>	m <span style=color:#719e07>:=</span> <span style=color:#b58900>len</span>(s)
</span></span><span style=display:flex><span>	dp <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([][<span style=color:#2aa198>1</span> <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>10</span>]<span style=color:#dc322f>int</span>, m)
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 数位dp的第一个状态都是数位的位置，第二个状态由题意来定</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 问题转换为计算没有重复数字的个数，因此第二个状态记录已经选过数字的集合</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// i 表示从高到低第i位， j是前面已经选过的数字的集合,最大为[0,9]的子集个数</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 例如集合 {0,2,3} 对应的二进制数为 1101 （集合的思想就是状压）</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> dp {
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> j <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> dp[i] {
</span></span><span style=display:flex><span>			dp[i][j] = <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#586e75>// -1 表示没有计算过</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> f <span style=color:#268bd2>func</span>(<span style=color:#dc322f>int</span>, <span style=color:#dc322f>int</span>, <span style=color:#dc322f>bool</span>, <span style=color:#dc322f>bool</span>) <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// mask是dp数组中第二个状态</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// isLimit表示当前是否受到n的约束，若为true表示当前位最大填s[i]</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 若isLimit为true时填了s[i],则isLimit为true传递到下一位，下一位也受到n的约束</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// isNum主要是处理前导零的问题。isNum表示i前面是否填了数字</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 若isNum为true，则i位可以从0开始填；否则，说明i是第一位，i可以不填，或者至少填1(因为不能有前导0)</span>
</span></span><span style=display:flex><span>	f = <span style=color:#268bd2>func</span>(i, mask <span style=color:#dc322f>int</span>, isLimit, isNum <span style=color:#dc322f>bool</span>) (res <span style=color:#dc322f>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> i <span style=color:#719e07>==</span> m { <span style=color:#586e75>// base case，遍历完毕</span>
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> isNum { <span style=color:#586e75>// 且不是全部跳过不选的</span>
</span></span><span style=display:flex><span>				<span style=color:#719e07>return</span> <span style=color:#2aa198>1</span> <span style=color:#586e75>// 得到了一个合法数字</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isLimit <span style=color:#719e07>&amp;&amp;</span> isNum {
</span></span><span style=display:flex><span>			dv <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>dp[i][mask]
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> <span style=color:#719e07>*</span>dv <span style=color:#719e07>&gt;=</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#719e07>return</span> <span style=color:#719e07>*</span>dv <span style=color:#586e75>// dp匹配直接返回</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#719e07>defer</span> <span style=color:#268bd2>func</span>() { <span style=color:#719e07>*</span>dv = res }() <span style=color:#586e75>// 未匹配到，则在return之后更新dp数组</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isNum { <span style=color:#586e75>// 可以跳过当前数位</span>
</span></span><span style=display:flex><span>			res <span style=color:#719e07>+=</span> <span style=color:#268bd2>f</span>(i<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, mask, <span style=color:#cb4b16>false</span>, <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		d <span style=color:#719e07>:=</span> <span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isNum {
</span></span><span style=display:flex><span>			d = <span style=color:#2aa198>1</span> <span style=color:#586e75>// 如果前面没有填数字，必须从 1 开始（因为不能有前导零）</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		up <span style=color:#719e07>:=</span> <span style=color:#2aa198>9</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> isLimit {
</span></span><span style=display:flex><span>			up = <span style=color:#b58900>int</span>(s[i] <span style=color:#719e07>-</span> <span style=color:#2aa198>&#39;0&#39;</span>) <span style=color:#586e75>// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> ; d <span style=color:#719e07>&lt;=</span> up; d<span style=color:#719e07>++</span> { <span style=color:#586e75>// 枚举要填入的数字 d</span>
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> mask<span style=color:#719e07>&gt;&gt;</span>d<span style=color:#719e07>&amp;</span><span style=color:#2aa198>1</span> <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> { <span style=color:#586e75>// d 不在 mask 中</span>
</span></span><span style=display:flex><span>				res <span style=color:#719e07>+=</span> <span style=color:#268bd2>f</span>(i<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, mask|<span style=color:#2aa198>1</span><span style=color:#719e07>&lt;&lt;</span>d, isLimit <span style=color:#719e07>&amp;&amp;</span> d <span style=color:#719e07>==</span> up, <span style=color:#cb4b16>true</span>) <span style=color:#586e75>// d写入mask， isLimit传递</span>
</span></span><span style=display:flex><span>			} <span style=color:#586e75>// 否则该分支的结果为0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> n <span style=color:#719e07>-</span> <span style=color:#268bd2>f</span>(<span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>, <span style=color:#cb4b16>true</span>, <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></p></article><article><header><p class=meta>Oct 28, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/>raft选举流程</a></h1></header><p><h3 id=图解>图解</h3><p><a href=http://thesecretlivesofdata.com/raft/ target=_blank rel=noopener>Raft (thesecretlivesofdata.com)</a></p><p>算法目的：实现了分布式节点的数据一致性</p><p>节点有三个状态：follower，candidate，leader</p><h3 id=leader-election>leader election</h3><p>初始阶段所有节点处于follower状态</p><p>follower状态下节点存在一个election timeout（150ms—300ms之间的随机数，随机降低了多个节点同时升级为candidate的可能性），election timeout内没有收到leader的heartbeat后，会自动升级为candidate状态，并开始一个新的election term。term是全局的，表示整个集群发生过选举的轮次(任期)。</p><p>candidate状态下，节点会向集群内所有节点发送requests votes请求。其他节点收到requests votes请求后，如果在本次term内还没有投过票，则会返回选票，如果candidate收到的选票占集群节点的大多数，则升级为本次term的leader节点。升级为leader之后向他的follower 发送append entries消息（也就是包含entry消息的心跳），follower也会返回消息的response，系统正常情况下维持在该状态</p><p>如果选举时，在一个term内发生了两个节点有同样的选票，会在超时过后进入下一轮进行重新选举</p><h3 id=log-replication>log replication</h3><p>client的请求只会发往leader。leader收到改动后，将改动写入日志（还未持久化commit），并将改动通过heartbeat广播至follower节点。follower节点写了entry之后（此时还未commit），返回ack。leader收到大于集群节点一半的ack之后，认为已经可以commit了，广播commit的通知。最终集群内所有follower触发commit，向leader返回ack。最后leader认为集群已经达成一致性了，向client返回ack</p><p>如果集群中产生网络隔离，每个隔离域中会产生一个新的leader，整个集群会存在多个leader。follower少的leader由于获取不到majority ack，他的entry不会被commit。此时client往另一个follower多的leader发送数据改变请求，该隔离域的节点会被commit</p><p>此时去掉网络隔离后，之前follower少的隔离域内未commit的entry会被刷成之前follower多的隔离域的entry,随后commit，此时集群再次达成一致性</p></p></article><div class=pagination><a href=/ aria-label=First class=label-pagination><i class="fa fa-angle-double-left fa-lg"></i></a>
<a href=/ class=label-pagination>1</a>
<a href=/page/2/ class=label-pagination>2</a>
<a href=/page/3/ class=label-pagination>3</a>
<a href=/page/2/ aria-label=Next class=label-pagination><i class="fa fa-angle-right fa-lg"></i></a>
<a href=/page/3/ aria-label=Last><i class="fa fa-angle-double-right fa-lg"></i></a></div></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>