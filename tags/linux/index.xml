<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on windseek</title><link>https://scottlx.github.io/tags/linux/</link><description>Recent content in linux on windseek</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 30 May 2025 13:53:00 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>bpftrace注入kfunc</title><link>https://scottlx.github.io/posts/bpftrace/</link><pubDate>Fri, 30 May 2025 13:53:00 +0800</pubDate><guid>https://scottlx.github.io/posts/bpftrace/</guid><description>四种探针类型 kprobe 定义：动态内核探针，允许在任意内核函数的入口（kprobe）或退出（kretprobe）插入断点。 特点： 动态性：无需修改内核代码，运行时动态注入。 灵活性：可跟踪几乎所有内核函数（包括未导出的符号）。 开销：较高（需修改指令、处理陷阱），可能影响性能。 稳定性：内核函数可能随版本变化，导致跟踪点失效。 用途：调试、性能分析、动态跟踪未预设的事件。 kfunc 定义：eBPF程序可调用的内核函数，由内核显式导出供安全调用。 特点： 安全性：仅允许调用内核标记为BTF_ID的特定函数（通过BPF Type Format, BTF）。 性能：直接调用内核函数，比eBPF Helper更高效。 依赖eBPF：需通过eBPF验证器确保安全性。 用途：允许eBPF程序安全访问内核内部数据结构或功能（如操作链表、修改特定字段）。 tracepoint 定义：内核静态跟踪点，由开发者预置在代码中的稳定事件接口。 特点： 静态性：需内核开发者预先定义，位置和参数格式固定。 稳定性：接口向后兼容，适合生产环境。 结构化数据：参数以明确结构体传递（如trace_sched_switch）。 低开销：相比kprobe，性能影响较小。 用途：监控系统调用、调度事件等预定义内核事件。 ** rawtracepoint** 定义：直接访问tracepoint的原始参数，跳过内核封装层。 特点： 底层访问：直接读取寄存器或原始参数，无需解析结构体。 性能优势：比常规tracepoint更高效（减少封装开销）。 不稳定性：参数格式可能随内核变化，需手动适配。 依赖eBPF：常用于eBPF程序（如BPF_PROG_TYPE_RAW_TRACEPOINT类型）。 用途：需要极致性能的场景（如高频事件跟踪），同时接受潜在兼容性风险。 btf支持 BPF 类型格式 (BTF) — Linux 内核文档 - Linux 内核
系统若有btf支持，结构体格式就可以通过btf传给工具，用户无需去查阅内核源码
sudo bpftrace --info |&amp;amp; grep -i btf kfunc probe 调试ebpf代码时，遇到icmp request接收了，但是内核协议栈不返回icmp reply
下面给出上述问题的排查思路
查看/proc/net/snmp发现有InHdrErrors
或者执行
netstat -s 发现Ip协议栈有invalid headers的报错
查看icmp_开头的kfunc点
bpftrace -lv &amp;#39;kfunc:icmp_*&amp;#39; 输出</description></item></channel></rss>