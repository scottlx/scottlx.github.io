<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>中间件 on windseek</title><link>https://scottlx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/</link><description>Recent content in 中间件 on windseek</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 03 Oct 2022 15:00:00 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>redis Server</title><link>https://scottlx.github.io/posts/redisserver/</link><pubDate>Mon, 03 Oct 2022 15:00:00 +0800</pubDate><guid>https://scottlx.github.io/posts/redisserver/</guid><description>数据库切换 默认会创建16个数据库，客户端通过select选取。但一般情况只用第0个数据库，切换容易导致误操作
typedef struct redisDb { dict *dict; //键空间 dict *expires; //过期字典 int id; } redisDb; 所有键空间存储在redisDb的dict中，称为key space
每个键是字符串对象，值是各种对象
读写键操作 更新keyspace_hits和keyspace_misses，用来输出统计数据 更新键的LRU时间 若发现该键已经过期，则删除键 若该键被watch，标记键为dirty，使得监听者发现后重新拉数据 dirty计数器++，用来触发持久化和复制操作 过期字典的键是键空间的键字符串对象的指针（不会新分配空间），值是longlong类型的过期时间（毫秒精度的unix时间戳）
判断是否过期：
先在过期字典里取key的过期时间，再与当前时间比较
删除策略 （redis同时采用惰性删除和定期删除策略，其中定期删除是随机取出一定数量的键做检查）：
定时删除：过期时立刻删除（问题：要创建大量定时器，占用太多CPU，因此不合理） 惰性删除：获取键时若过期才删除 （问题：内存最不友好） 定期删除：定期对所有key进行检查并删除 （问题：如何确定定期时间，太快或太慢都不好） 持久化 解密Redis持久化 - justjavac - 博客园 (cnblogs.com)
rdb 记录键值
主服务器初始化加载时不会加载过期的键值，从服务器会加载过期的键值，但同步之后也会被清空掉
主节点统一管理过期删除，从节点只能被动接收del命令，保证了数据一致性，但从节点里可能会有过期键值
SAVE阻塞保存，BGSAVE用子进程保存
自动保存：自动保存规则设置在一个列表中，表示一段时间内进行了多少次改动就满足保存规则
每次写入会将db的dirty计数器加1，且每次保存会保存的时间戳lastsave。当距离lastsave的时间超过条件中设置的时间，比较dirty与规则中设置的改动次数，若满足则触发BGSAVE
RDB数据格式
REDIS db_version database 0 database 3 EOF check_sum 格式细节包括压缩算法略过
aof 记录写命令（启动时优先选择加载aof）
命令追加：按redis协议追加到aof_buf缓冲区中
文件写入和同步：redis server主线程每次循环结束前，将缓冲区写入aof文件，并调用fsync落盘
同步策略：always（每次都落盘），everysec(离上次落盘超过一秒触发落盘), no（靠操作系统自己落盘，一般是30s）
过期但还未被删除的键值不会追加到aof中，只有惰性删除或定期删除显示调用del后才会追加DEL命令
aof重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。</description></item><item><title>redis 多节点</title><link>https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 03 Oct 2022 15:00:00 +0800</pubDate><guid>https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/</guid><description>主从（复制） 同步 slave刚上线或断线重连时的第一次全量同步
slave的客户端主动发送sync命令，触发master的BGSAVE，BGSAVE过程中将命令存入缓冲区，BGSAVE完成后发送RDB文件，slave完成RDB载入后再发送缓冲区的指令
命令传播 完成同步后的增量同步
master主动发送命令
psync 优化后的sync，作为断线重连后的增量同步 slave发送psync命令，master返回+continue，之后发送断开期间执行的写命令
偏移量 主节点和从节点各自维护一个偏移量，表示当前已接收数据的字节数。当从节点发现自身偏移量与主节点不一致时，主动向主节点发送psync命令
复制缓冲区 主节点进行命令传播时(增量同步),会将写命令复制一份到缓冲区。且每个写命令都绑定一个对应的偏移量。从节点发送的psync中带有偏移量， 通过该偏移量在复制缓冲区中查找偏移量之后的写命令。如果查不到，则执行完整同步(sync)
服务器运行ID 从节点向主节点注册自己的分布式ID，新上线的从节点若不在注册表内，则进行完整同步(sync)，否则进行部分重同步。
同步过程 slaveof命令设置redisServer中的masterhost和masterport字段，之后主从连接由cron定时器任务里触发
anetTcpConnect建立一个新的tcp连接 ping-pong命令测试连接 auth鉴权 发送端口号，主节点刷新client信息 psyn/sync 同步 命令传播 心跳 发送REPLCONF ACK命令，其中带有从节点的偏移量，可以检测命令丢失（命令丢失后主节点和从节点的偏移量会不一样）；收到心跳的时间戳用来监测网络延迟状态，若一定数量的从服务器的lag超过一定值，表示该主从集合不健康，不允许client写入 一致性 不是强一致性（cap），是最终一致性。用最终一致性换取了高吞吐量
master与slave的同步存在数据不一致的时间窗口期 网络分区后哨兵模式或者集群模式的选主会产生脑裂 哨兵 多了一个哨兵节点进行主节点选举，触发从同步等工作，数据的同步还是主从模式 哨兵节点运行的是一个特殊模式的redis服务器，里面没有数据库。
连接类型 命令连接
订阅连接
/*实例不是 Sentinel （主服务器或者从服务器） 并且以下条件的其中一个成立： 1）SENTINEL 未收到过这个服务器的 INFO 命令回复 2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔 那么向实例发送 INFO 命令 */ if ((ri-&amp;gt;flags &amp;amp; SRI_SENTINEL) == 0 &amp;amp;&amp;amp; ​ (ri-&amp;gt;info_refresh == 0 || ​ (now - ri-&amp;gt;info_refresh) &amp;gt; info_period)) { ​ /* Send INFO to masters and slaves, not sentinels.</description></item><item><title>redis 数据结构</title><link>https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 03 Oct 2022 15:00:00 +0800</pubDate><guid>https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>此系列作为redis设计与实现的笔记，会将本人自认为重点部分单独拎出来，并加入本人的一些理解。
SDS （simple dynamic string）
等同于go里的slice
struct sdshdr { int len; int free; char buf[]; } 优点：
杜绝缓冲区溢出（free检验） 减少修改字符串时的内存分配次数（策略：小于1MB时，len=free，大于1MB时，free=1MB） 惰性空间释放（删除时实际空间并未缩减） 二进制安全（C字符串视/0为结束，不能用来存带/0的二进制数据） 部分兼容C字符串函数（默认在char数组最后加入/0，来兼容C字符串函数） 链表 双向链表，无环，保存头指针和尾指针，保存链表长度字段，链表节点的数据为void*指针
字典 字典有type，每个type实现了一系列操作kv的函数（对比，生成哈希，删除，复制等）
每个字典存有两个哈希表，一般用第一个ht[0]，第二个ht[1]用作rehash时的暂存容器
哈希表由数组实现，数组存放kv链表头节点，链地址法解决冲突，冲突的新键值往表头加（由于没有指向表尾的指针）
rehash标志位，当没有进行rehash时为-1
key&amp;ndash;&amp;gt;(hashfunc)&amp;ndash;&amp;gt;hash&amp;ndash;&amp;gt;(hashmask)&amp;ndash;&amp;gt;index
murmurhash算法：输入有规律情况还是能生成随机分布性的hash
rehash 为ht[1]哈希表分配空间，空间的大小取决于当前ht[0]包含的键值数量以及要进行的操作，重新计算所有键值在ht[1]的索引并插入，插入后将ht[1]设置为ht[0]，并ht[1]指向新创的空白hash表
负载因子=ht[0].used/ht[0].size
何时进行扩展? 在进行持久化操作时(BGSAVE,BGREWRITEAOF)，负载因子&amp;gt;=5，普通场景下负载因子&amp;gt;=1
何时进行收缩? 负载因子&amp;lt;0.1
渐进式rehash 开始时rehashidx为0，表示正在进行rehash，rehash期间对字典的CRUD会顺带将ht[0]上的KV rehash到ht[1]，完成后rehashidx置为-1,表示已经完成。rehash期间的CRUD会先在ht[0]上查，查不到再去ht[1]查
跳表 用来实现有序集合键，用作集群节点内部数据结构
优点，相较于平衡树，实现简单，且rebalance的效率高（局部rebalance，只修改搜索路径上的节点）
链表的扩展，维护了多个指向其他节点的指针，类似二分查找
每个节点的层数是随机生成的，遍历时先走最上层的前进指针，若下一条节点的分值比要查找的分值高，则通过回退指针回到原来的节点并走下一层的前进指针，以此类推
前进指针中存有跨度，累加所有跨度，当找到该节点后作为该节点在跳表中的排位（数组的index）
比较分值时，分值可能相同，相同时比较value值（obj指向的sds的字典序）
节点更新时，若score的改变未影响排序，则查找并直接改score，否则进行先删除后插入操作，会进行两次路径搜索
整数集合 底层保存的整数为byte数组(int8)，按照解码类型(encoding)存入int16，int32或int64的数据
只能存一种类型的数据，短int集合中插入长int后，往长int类型兼容（升级）
节约内存，int16不需要分配int64的空间
自适应灵活性，集合中添加长度更长的新元素，会自动升级，但不支持降级
压缩列表 为了节约内存，将键值为小整数值和短字符串的entry按照特殊编排压缩为一段内存块
先略过
对象 创建键值对时，键和值都被封装成对象，并指明对象的类型，编码以及底层数据结构的指针
key总是字符串对象，value可以是字符串对象，列表对象，哈希对象，集合对象，有序集合对象(zset)
编码指定了底层数据结构, 每种对象类型有多种编码的实现
字符串对象 long：value是数字，可以用long存
raw：value是字符串，长度大于32byte，用sds存，sds的内存是另外一块，和redisObject不连续
embstr：value是字符串，长度小于32byte，用sds存，sds的内存与redisObject的内存连续 （好处：减少分配和释放内存的次数，增加缓存命中率；坏处：没有实现写方法，只读，修改的话需要先转raw）
列表对象 ziplist：redisObject的ptr指向压缩列表（条件：每个字符串长度&amp;lt;64byte且列表长度&amp;lt;512）
linkedlist：构造元素为字符串对象的双向链表（列表对象中嵌套了字符串对象）</description></item></channel></rss>