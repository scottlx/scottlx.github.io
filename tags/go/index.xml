<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on windseek的博客</title><link>https://scottlx.github.io/tags/go/</link><description>Recent content in go on windseek的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 08 Oct 2022 10:36:00 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>优势洗牌(田忌赛马)</title><link>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</link><pubDate>Sat, 08 Oct 2022 10:36:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</guid><description>870. 优势洗牌 - 力扣（LeetCode） 思路 将nums1(自己的马)进行升序排序，得到下等马-&amp;gt;上等马的序列 贪心策略 若某个位置上自己的马比对手的马强，由于已经排过序了，已经是最下等的马了，因此使用这匹马 若某个位置上自己的马比对手的马弱，将该下等马放到最后的位置（对手的上等马的位</description></item><item><title>拓扑排序(选课)</title><link>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link><pubDate>Sat, 08 Oct 2022 10:36:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid><description>207. 课程表 - 力扣（LeetCode） 思路 课程之间的依赖关系可以用图来表示 顶点：课程 边：有向的边，起点是前置课程，终点是后置课程 这种图叫做AOV（Activity On Vertex）网络，字面意思就是边代表了节点之间的活动的先后关系。 按照题意，这个图是无环的（课程不能循环依赖），也就是D</description></item><item><title>单调栈</title><link>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Mon, 03 Oct 2022 09:18:21 +0800</pubDate><guid>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。 标准模板 第一个for循环内循环输入数组， 第二个for循环维持栈内单调特性，不满足单调的元素依次出栈 第一个for循环内对元</description></item></channel></rss>