<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on windseek</title><link>https://scottlx.github.io/tags/go/</link><description>Recent content in Go on windseek</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 20 Mar 2023 11:50:00 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>数位dp</title><link>https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/</link><pubDate>Mon, 20 Mar 2023 11:50:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/</guid><description>&lt;h2 id="题目特征">题目特征&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>要求统计满足一定条件的数的数量（即，最终目的为计数，若要结果则只能回溯爆搜得到）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这些条件经过转化后可以使用「数位」的思想去理解和判断；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>上界很大（比如 10^{18}），暴力枚举验证会超时。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>从高到低枚举每一位，统计符合target的个数，并记录到dp数组中。枚举完毕之后则得到答案。&lt;/p>
&lt;p>因此数位dp的第一个状态都是数位的位置，第二个状态由题意来定&lt;/p>
&lt;h2 id="模板">模板&lt;/h2>
&lt;p>以leetcode1012为例，统计小于等于n的数字中每一位的数字至少重复一次的个数。&lt;/p>
&lt;p>模板时灵神的模板。难点主要是mask，isLimit，isNum这几个标识&lt;/p>
&lt;ul>
&lt;li>mask即dp的第二个状态，这边用到了状态压缩的思想，将0到9选过的状态压缩成一个数字(否则要10个状态)&lt;/li>
&lt;li>isLimit 标识了本次(i)选择的范围，是否受到n的影响。如果不引进这个变量，则需要考虑当前数字的最高位来决定本次的范围(最高位==n的最高位时，本次的范围是[0,s[i]],最高位&amp;lt;n的最高位时，本次的范围是[0,9])。可以发现这个限制是有传递的性质的，因此引入这个变量能简化范围的选择过程。&lt;/li>
&lt;li>isNum 标识了本次(i)之前是否有数字，换句话说本次(i)是否是第一个数字(最高位)。这个标识主要是解决前导0的问题，否则答案里会重复(前导两个0和前导三个0虽然是同个数字，但都会被记入答案)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> &lt;span style="color:#268bd2">numDupDigitsAtMostN&lt;/span>(n &lt;span style="color:#dc322f">int&lt;/span>) (ans &lt;span style="color:#dc322f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	s &lt;span style="color:#719e07">:=&lt;/span> strconv.&lt;span style="color:#268bd2">Itoa&lt;/span>(n) &lt;span style="color:#586e75">// s[0]是最高位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">/* 若需要从低到高的顺序，则按如下生成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">		for ; n &amp;gt; 0; n = n / 10 {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">	 list = append(list, n%10)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">	 }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#586e75">	*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	m &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	dp &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>([][&lt;span style="color:#2aa198">1&lt;/span> &lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#2aa198">10&lt;/span>]&lt;span style="color:#dc322f">int&lt;/span>, m)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// 数位dp的第一个状态都是数位的位置，第二个状态由题意来定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// 问题转换为计算没有重复数字的个数，因此第二个状态记录已经选过数字的集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// i 表示从高到低第i位， j是前面已经选过的数字的集合,最大为[0,9]的子集个数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// 例如集合 {0,2,3} 对应的二进制数为 1101 （集合的思想就是状压）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#719e07">for&lt;/span> i &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span> dp {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">for&lt;/span> j &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span> dp[i] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			dp[i][j] = &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span> &lt;span style="color:#586e75">// -1 表示没有计算过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#268bd2">var&lt;/span> f &lt;span style="color:#268bd2">func&lt;/span>(&lt;span style="color:#dc322f">int&lt;/span>, &lt;span style="color:#dc322f">int&lt;/span>, &lt;span style="color:#dc322f">bool&lt;/span>, &lt;span style="color:#dc322f">bool&lt;/span>) &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// mask是dp数组中第二个状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// isLimit表示当前是否受到n的约束，若为true表示当前位最大填s[i]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// 若isLimit为true时填了s[i],则isLimit为true传递到下一位，下一位也受到n的约束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// isNum主要是处理前导零的问题。isNum表示i前面是否填了数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#586e75">// 若isNum为true，则i位可以从0开始填；否则，说明i是第一位，i可以不填，或者至少填1(因为不能有前导0)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	f = &lt;span style="color:#268bd2">func&lt;/span>(i, mask &lt;span style="color:#dc322f">int&lt;/span>, isLimit, isNum &lt;span style="color:#dc322f">bool&lt;/span>) (res &lt;span style="color:#dc322f">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> i &lt;span style="color:#719e07">==&lt;/span> m { &lt;span style="color:#586e75">// base case，遍历完毕&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#719e07">if&lt;/span> isNum { &lt;span style="color:#586e75">// 且不是全部跳过不选的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#2aa198">1&lt;/span> &lt;span style="color:#586e75">// 得到了一个合法数字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#719e07">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> !isLimit &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> isNum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			dv &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">&amp;amp;&lt;/span>dp[i][mask]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#719e07">*&lt;/span>dv &lt;span style="color:#719e07">&amp;gt;=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">return&lt;/span> &lt;span style="color:#719e07">*&lt;/span>dv &lt;span style="color:#586e75">// dp匹配直接返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#719e07">defer&lt;/span> &lt;span style="color:#268bd2">func&lt;/span>() { &lt;span style="color:#719e07">*&lt;/span>dv = res }() &lt;span style="color:#586e75">// 未匹配到，则在return之后更新dp数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> !isNum { &lt;span style="color:#586e75">// 可以跳过当前数位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			res &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>(i&lt;span style="color:#719e07">+&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>, mask, &lt;span style="color:#cb4b16">false&lt;/span>, &lt;span style="color:#cb4b16">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		d &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> !isNum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			d = &lt;span style="color:#2aa198">1&lt;/span> &lt;span style="color:#586e75">// 如果前面没有填数字，必须从 1 开始（因为不能有前导零）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		up &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#2aa198">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> isLimit {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			up = &lt;span style="color:#b58900">int&lt;/span>(s[i] &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#2aa198">&amp;#39;0&amp;#39;&lt;/span>) &lt;span style="color:#586e75">// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">for&lt;/span> ; d &lt;span style="color:#719e07">&amp;lt;=&lt;/span> up; d&lt;span style="color:#719e07">++&lt;/span> { &lt;span style="color:#586e75">// 枚举要填入的数字 d&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#719e07">if&lt;/span> mask&lt;span style="color:#719e07">&amp;gt;&amp;gt;&lt;/span>d&lt;span style="color:#719e07">&amp;amp;&lt;/span>&lt;span style="color:#2aa198">1&lt;/span> &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span> { &lt;span style="color:#586e75">// d 不在 mask 中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				res &lt;span style="color:#719e07">+=&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>(i&lt;span style="color:#719e07">+&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>, mask|&lt;span style="color:#2aa198">1&lt;/span>&lt;span style="color:#719e07">&amp;lt;&amp;lt;&lt;/span>d, isLimit &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> d &lt;span style="color:#719e07">==&lt;/span> up, &lt;span style="color:#cb4b16">true&lt;/span>) &lt;span style="color:#586e75">// d写入mask， isLimit传递&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			} &lt;span style="color:#586e75">// 否则该分支的结果为0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#719e07">return&lt;/span> n &lt;span style="color:#719e07">-&lt;/span> &lt;span style="color:#268bd2">f&lt;/span>(&lt;span style="color:#2aa198">0&lt;/span>, &lt;span style="color:#2aa198">0&lt;/span>, &lt;span style="color:#cb4b16">true&lt;/span>, &lt;span style="color:#cb4b16">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>raft选举流程</title><link>https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Oct 2022 09:30:00 +0800</pubDate><guid>https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/</guid><description>&lt;h3 id="图解">图解&lt;/h3>
&lt;p>
&lt;a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft (thesecretlivesofdata.com)&lt;/a>&lt;/p>
&lt;p>算法目的：实现了分布式节点的数据一致性&lt;/p>
&lt;p>节点有三个状态：follower，candidate，leader&lt;/p>
&lt;h3 id="leader-election">leader election&lt;/h3>
&lt;p>初始阶段所有节点处于follower状态&lt;/p>
&lt;p>follower状态下节点存在一个election timeout（150ms—300ms之间的随机数，随机降低了多个节点同时升级为candidate的可能性），election timeout内没有收到leader的heartbeat后，会自动升级为candidate状态，并开始一个新的election term。term是全局的，表示整个集群发生过选举的轮次(任期)。&lt;/p>
&lt;p>candidate状态下，节点会向集群内所有节点发送requests votes请求。其他节点收到requests votes请求后，如果在本次term内还没有投过票，则会返回选票，如果candidate收到的选票占集群节点的大多数，则升级为本次term的leader节点。升级为leader之后向他的follower 发送append entries消息（也就是包含entry消息的心跳），follower也会返回消息的response，系统正常情况下维持在该状态&lt;/p>
&lt;p>如果选举时，在一个term内发生了两个节点有同样的选票，会在超时过后进入下一轮进行重新选举&lt;/p>
&lt;h3 id="log-replication">log replication&lt;/h3>
&lt;p>client的请求只会发往leader。leader收到改动后，将改动写入日志（还未持久化commit），并将改动通过heartbeat广播至follower节点。follower节点写了entry之后（此时还未commit），返回ack。leader收到大于集群节点一半的ack之后，认为已经可以commit了，广播commit的通知。最终集群内所有follower触发commit，向leader返回ack。最后leader认为集群已经达成一致性了，向client返回ack&lt;/p>
&lt;p>如果集群中产生网络隔离，每个隔离域中会产生一个新的leader，整个集群会存在多个leader。follower少的leader由于获取不到majority ack，他的entry不会被commit。此时client往另一个follower多的leader发送数据改变请求，该隔离域的节点会被commit&lt;/p>
&lt;p>此时去掉网络隔离后，之前follower少的隔离域内未commit的entry会被刷成之前follower多的隔离域的entry,随后commit，此时集群再次达成一致性&lt;/p></description></item><item><title>etcd client v3 连接流程</title><link>https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Oct 2022 09:15:00 +0800</pubDate><guid>https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>首先需要了解grpc框架的一些概念，这边引用网上的一张图
&lt;img src="https://scottlx.github.io/img/blobs/etcdclient.png" alt="Alt text">&lt;/p>
&lt;h3 id="resolver">Resolver&lt;/h3>
&lt;p>提供一个用户自定义的解析、修改地址的方法，使得用户可以自己去实现地址解析的逻辑、做服务发现、地址更新等等功能。&lt;/p>
&lt;ol>
&lt;li>将Endpoints里的ETCD服务器地址(127.0.0.1:2379这种格式)做一次转换传给grpc框架。也可以自己重新写此resolver，做服务发现功能。例如etcd服务器地址写nacos之类的地址，在resolver中写好转换逻辑。&lt;/li>
&lt;li>调用ClientConn的ParseServiceConfig接口告诉endpoints的负载策略是轮询&lt;/li>
&lt;/ol>
&lt;h3 id="balancer">Balancer&lt;/h3>
&lt;ol>
&lt;li>管理subConns，并收集各conn信息，更新状态至ClientConn&lt;/li>
&lt;li>生成picker(balancer)的快照，从而ClientConn可以选择发送rpc请求的subConn&lt;/li>
&lt;/ol>
&lt;p>此处etcd client没有实现balancer，默认使用grpc提供的轮询的balancer&lt;/p>
&lt;h3 id="重试策略">重试策略&lt;/h3>
&lt;p>与一般的c-s模型不同，etcd client的重试是针对集群的重试。单个节点的断连不会造成所有节点的重连。&lt;/p>
&lt;h4 id="重试机制">重试机制&lt;/h4>
&lt;p>一般的重试是对同一个节点进行重试，但etcd client的自动重试不会在ETCD集群的同一节点上进行，是轮询重试集群的每个节点。重试时不会重新建连，而是使用balancer提供的transport。transport的状态更新与这一块的重试是通过balancer解耦的。&lt;/p>
&lt;h4 id="重试条件">重试条件&lt;/h4>
&lt;h5 id="etcd-unary拦截器">etcd unary拦截器&lt;/h5>
&lt;p>拦截器类似http里的中间件的概念，在发送实际请求之前对报文进行篡改。一般用来添加认证，日志记录，缓存之类的功能。&lt;/p>
&lt;p>此处etcd的一元拦截器主要做了自动重试的功能，且只会重试一些特定的错误(DeadlineExceeded, Canceled,ErrInvalidAuthToken)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> (c &lt;span style="color:#719e07">*&lt;/span>Client) &lt;span style="color:#268bd2">unaryClientInterceptor&lt;/span>(optFuncs &lt;span style="color:#719e07">...&lt;/span>retryOption) grpc.UnaryClientInterceptor {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#719e07">if&lt;/span> &lt;span style="color:#268bd2">isContextError&lt;/span>(lastErr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">if&lt;/span> ctx.&lt;span style="color:#268bd2">Err&lt;/span>() &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#586e75">// its the context deadline or cancellation.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#719e07">return&lt;/span> lastErr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#586e75">// its the callCtx deadline or cancellation, in which case try again.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> callOpts.retryAuth &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> rpctypes.&lt;span style="color:#268bd2">Error&lt;/span>(lastErr) &lt;span style="color:#719e07">==&lt;/span> rpctypes.ErrInvalidAuthToken {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#586e75">// clear auth token before refreshing it.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#586e75">// call c.Auth.Authenticate with an invalid token will always fail the auth check on the server-side,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#586e75">// if the server has not apply the patch of pr #12165 (https://github.com/etcd-io/etcd/pull/12165)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#586e75">// and a rpctypes.ErrInvalidAuthToken will recursively call c.getToken until system run out of resource.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				c.authTokenBundle.&lt;span style="color:#268bd2">UpdateAuthToken&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				gterr &lt;span style="color:#719e07">:=&lt;/span> c.&lt;span style="color:#268bd2">getToken&lt;/span>(ctx)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">if&lt;/span> gterr &lt;span style="color:#719e07">!=&lt;/span> &lt;span style="color:#cb4b16">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					c.&lt;span style="color:#268bd2">GetLogger&lt;/span>().&lt;span style="color:#268bd2">Warn&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						&lt;span style="color:#2aa198">&amp;#34;retrying of unary invoker failed to fetch new auth token&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						zap.&lt;span style="color:#268bd2">String&lt;/span>(&lt;span style="color:#2aa198">&amp;#34;target&amp;#34;&lt;/span>, cc.&lt;span style="color:#268bd2">Target&lt;/span>()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						zap.&lt;span style="color:#268bd2">Error&lt;/span>(gterr),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#719e07">return&lt;/span> gterr &lt;span style="color:#586e75">// lastErr must be invalid auth token&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#719e07">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="重试次数">重试次数&lt;/h4>
&lt;p>此处Invoke的大循环里，默认callOpts.max是0，也就是说尝试一次Invoke后就会return错误&lt;/p></description></item><item><title>单调栈</title><link>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Thu, 13 Oct 2022 10:21:21 +0800</pubDate><guid>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>&lt;p>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。&lt;/p>
&lt;h4 id="标准模板">标准模板&lt;/h4>
&lt;ol>
&lt;li>第一个for循环内循环输入数组，&lt;/li>
&lt;li>第二个for循环维持栈内单调特性，不满足单调的元素依次出栈&lt;/li>
&lt;li>第一个for循环内对元素入栈&lt;/li>
&lt;/ol>
&lt;h4 id="496-下一个更大元素-i">
&lt;a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I&lt;/a>&lt;/h4>
&lt;p>直接输入出栈元素即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> &lt;span style="color:#268bd2">nextGreaterElement&lt;/span>(nums1 []&lt;span style="color:#dc322f">int&lt;/span>, nums2 []&lt;span style="color:#dc322f">int&lt;/span>) []&lt;span style="color:#dc322f">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//单调递减栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> stack,res []&lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//标准模板，首个元素先入栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = &lt;span style="color:#b58900">append&lt;/span>(stack, &lt;span style="color:#2aa198">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1 &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>(&lt;span style="color:#268bd2">map&lt;/span>[&lt;span style="color:#dc322f">int&lt;/span>]&lt;span style="color:#dc322f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> i,v &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span>(nums1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1[v] = i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//顺便初始化res，查不到的为-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res = &lt;span style="color:#b58900">append&lt;/span>(res, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> i&lt;span style="color:#719e07">:=&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>; i &amp;lt; &lt;span style="color:#b58900">len&lt;/span>(nums2); i&lt;span style="color:#719e07">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 单调递减，所以&amp;gt;=的都出栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(stack) &amp;gt; &lt;span style="color:#2aa198">0&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> nums2[stack[&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]] &lt;span style="color:#719e07">&amp;lt;=&lt;/span> nums2[i] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 查表，需要输出的加入res&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> idx, ok &lt;span style="color:#719e07">:=&lt;/span> map1[nums2[stack[&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]]]; ok {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[idx] = nums2[i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//pop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = stack[:&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = &lt;span style="color:#b58900">append&lt;/span>(stack, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="42-接雨水">
&lt;a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水&lt;/a>&lt;/h4>
&lt;p>出栈后计算出栈元素高度所在层的面积&lt;/p></description></item><item><title>拓扑排序(选课)</title><link>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 12 Oct 2022 21:42:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid><description>&lt;p>
&lt;a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表 - 力扣（LeetCode）&lt;/a>&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>课程之间的依赖关系可以用图来表示&lt;/p>
&lt;ul>
&lt;li>顶点：课程&lt;/li>
&lt;li>边：有向的边，起点是前置课程，终点是后置课程&lt;/li>
&lt;/ul>
&lt;p>这种图叫做AOV（Activity On Vertex）网络，字面意思就是边代表了节点之间的活动的先后关系。&lt;/p>
&lt;p>按照题意，这个图是无环的（课程不能循环依赖），也就是DAG图。DAG图其实就是一颗树，只不过根节点是一个虚拟根节点（可以有多个起始根节点，但外面可以用一个虚拟根节点作为他们的父节点）。&lt;/p>
&lt;p>因此，可以用广度优先遍历（BFS）来求解。队列存放可以选的课程（入度为0），依次出队列（选课）。直到队列为空（没有课可以选了），看是否已经学完所有的课程&lt;/p>
&lt;ul>
&lt;li>入度：指向自己的边的数量，入度为0表示自己没有前置课程，可以入队列&lt;/li>
&lt;li>出度：指向别人的边。用一个数据结构记录每个节点的出度列表。当某个节点出队列时，更新本节点的出度列表里所有节点的入度（-1）&lt;/li>
&lt;/ul>
&lt;h2 id="代码">代码&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> &lt;span style="color:#268bd2">canFinish&lt;/span>(numCourses &lt;span style="color:#dc322f">int&lt;/span>, prerequisites [][]&lt;span style="color:#dc322f">int&lt;/span>) &lt;span style="color:#dc322f">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//保存各课程的入度 空间O(v)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>([]&lt;span style="color:#dc322f">int&lt;/span>, numCourses)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 保存各课程的出度列表 空间O(e)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> courseMp &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>(&lt;span style="color:#268bd2">map&lt;/span>[&lt;span style="color:#dc322f">int&lt;/span>][]&lt;span style="color:#dc322f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//时间 O(e)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> _, pre &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span>(prerequisites) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree[pre[&lt;span style="color:#2aa198">0&lt;/span>]]&lt;span style="color:#719e07">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> courseMp[pre[&lt;span style="color:#2aa198">1&lt;/span>]] = &lt;span style="color:#b58900">append&lt;/span>(courseMp[pre[&lt;span style="color:#2aa198">1&lt;/span>]], pre[&lt;span style="color:#2aa198">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> q []&lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 已经学习了的课程的计数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> num &lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 初始入度为0的课程加入队列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> course, depends &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span>(indegree) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> depends &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q = &lt;span style="color:#b58900">append&lt;/span>(q, course)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//循环直到队列为空 时间O(v)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(q) &amp;gt; &lt;span style="color:#2aa198">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 出队列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> finished &lt;span style="color:#719e07">:=&lt;/span> q[&lt;span style="color:#2aa198">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q = q[&lt;span style="color:#2aa198">1&lt;/span>:]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num&lt;span style="color:#719e07">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 更新入度数据结构(slice)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 从出度课程列表中直接取受影响的课程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> _, course &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span>(courseMp[finished]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> indegree[course]&lt;span style="color:#719e07">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 入度-1后若为0，则可以入队列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> indegree[course] &lt;span style="color:#719e07">==&lt;/span> &lt;span style="color:#2aa198">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> q = &lt;span style="color:#b58900">append&lt;/span>(q, course)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//是否学完&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> num &lt;span style="color:#719e07">==&lt;/span> numCourses
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>时间复杂度：O (v+e)&lt;/li>
&lt;li>空间复杂度: O(v+e)&lt;/li>
&lt;/ul>
&lt;p>若需要省空间，不需要省时间，可以不使用courseMp存放出度数组，每次重新遍历prerequisites 获取出度数组。此时处理每个节点都需要重新遍历所有的边，因此：&lt;/p></description></item><item><title>优势洗牌(田忌赛马)</title><link>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</link><pubDate>Sat, 08 Oct 2022 10:36:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</guid><description>&lt;p>
&lt;a href="https://leetcode.cn/problems/advantage-shuffle/" target="_blank" rel="noopener">870. 优势洗牌 - 力扣（LeetCode）&lt;/a>&lt;/p>
&lt;h3 id="思路">思路&lt;/h3>
&lt;ol>
&lt;li>将nums1(自己的马)进行升序排序，得到下等马-&amp;gt;上等马的序列&lt;/li>
&lt;li>贪心策略
&lt;ul>
&lt;li>若某个位置上自己的马比对手的马强，由于已经排过序了，已经是最下等的马了，因此使用这匹马&lt;/li>
&lt;li>若某个位置上自己的马比对手的马弱，将该下等马放到最后的位置（对手的上等马的位置）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>由于nums2的顺序固定（已知对手上场顺序），因此使用nums2的元素值对nums2的index进行排序，得到上场顺序（ids）&lt;/li>
&lt;li>按照上场顺序(ids)依次写入ans数组中&lt;/li>
&lt;/ol>
&lt;h3 id="代码">代码&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> &lt;span style="color:#268bd2">advantageCount&lt;/span>(nums1 []&lt;span style="color:#dc322f">int&lt;/span>, nums2 []&lt;span style="color:#dc322f">int&lt;/span>) []&lt;span style="color:#dc322f">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sort.&lt;span style="color:#268bd2">Ints&lt;/span>(nums1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	n &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(nums1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ans &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>([]&lt;span style="color:#dc322f">int&lt;/span>, n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ids &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>([]&lt;span style="color:#dc322f">int&lt;/span>, n)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#719e07">for&lt;/span> i &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>; i &amp;lt; n; i&lt;span style="color:#719e07">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ids[i] = i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	sort.&lt;span style="color:#268bd2">Slice&lt;/span>(ids, &lt;span style="color:#268bd2">func&lt;/span>(i, j &lt;span style="color:#dc322f">int&lt;/span>) &lt;span style="color:#dc322f">bool&lt;/span> { &lt;span style="color:#719e07">return&lt;/span> nums2[ids[i]] &amp;lt; nums2[ids[j]] })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	left, right &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#2aa198">0&lt;/span>, n&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#719e07">for&lt;/span> _, v &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span> nums1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#719e07">if&lt;/span> v &amp;gt; nums2[ids[left]] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			ans[ids[left]] = v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			left&lt;span style="color:#719e07">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		} &lt;span style="color:#719e07">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			ans[ids[right]] = v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			right&lt;span style="color:#719e07">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#719e07">return&lt;/span> ans
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="总结">总结&lt;/h3>
&lt;p>灵活运用不对数组进行真正的排序，而是获得排序后的index的顺序这一技巧&lt;/p></description></item></channel></rss>