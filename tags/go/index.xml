<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on windseek</title><link>https://scottlx.github.io/tags/go/</link><description>Recent content in go on windseek</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 20 Mar 2023 11:50:00 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>数位dp</title><link>https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/</link><pubDate>Mon, 20 Mar 2023 11:50:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/</guid><description>题目特征 要求统计满足一定条件的数的数量（即，最终目的为计数，若要结果则只能回溯爆搜得到）；
这些条件经过转化后可以使用「数位」的思想去理解和判断；
输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；
上界很大（比如 10^{18}），暴力枚举验证会超时。
思路 从高到低枚举每一位，统计符合target的个数，并记录到dp数组中。枚举完毕之后则得到答案。
因此数位dp的第一个状态都是数位的位置，第二个状态由题意来定
模板 以leetcode1012为例，统计小于等于n的数字中每一位的数字至少重复一次的个数。
模板时灵神的模板。难点主要是mask，isLimit，isNum这几个标识
mask即dp的第二个状态，这边用到了状态压缩的思想，将0到9选过的状态压缩成一个数字(否则要10个状态) isLimit 标识了本次(i)选择的范围，是否受到n的影响。如果不引进这个变量，则需要考虑当前数字的最高位来决定本次的范围(最高位==n的最高位时，本次的范围是[0,s[i]],最高位&amp;lt;n的最高位时，本次的范围是[0,9])。可以发现这个限制是有传递的性质的，因此引入这个变量能简化范围的选择过程。 isNum 标识了本次(i)之前是否有数字，换句话说本次(i)是否是第一个数字(最高位)。这个标识主要是解决前导0的问题，否则答案里会重复(前导两个0和前导三个0虽然是同个数字，但都会被记入答案) func numDupDigitsAtMostN(n int) (ans int) { s := strconv.Itoa(n) // s[0]是最高位 /* 若需要从低到高的顺序，则按如下生成 for ; n &amp;gt; 0; n = n / 10 { list = append(list, n%10) } */ m := len(s) dp := make([][1 &amp;lt;&amp;lt; 10]int, m) // 数位dp的第一个状态都是数位的位置，第二个状态由题意来定 // 问题转换为计算没有重复数字的个数，因此第二个状态记录已经选过数字的集合 // i 表示从高到低第i位， j是前面已经选过的数字的集合,最大为[0,9]的子集个数 // 例如集合 {0,2,3} 对应的二进制数为 1101 （集合的思想就是状压） for i := range dp { for j := range dp[i] { dp[i][j] = -1 // -1 表示没有计算过 } } var f func(int, int, bool, bool) int // mask是dp数组中第二个状态 // isLimit表示当前是否受到n的约束，若为true表示当前位最大填s[i] // 若isLimit为true时填了s[i],则isLimit为true传递到下一位，下一位也受到n的约束 // isNum主要是处理前导零的问题。isNum表示i前面是否填了数字 // 若isNum为true，则i位可以从0开始填；否则，说明i是第一位，i可以不填，或者至少填1(因为不能有前导0) f = func(i, mask int, isLimit, isNum bool) (res int) { if i == m { // base case，遍历完毕 if isNum { // 且不是全部跳过不选的 return 1 // 得到了一个合法数字 } return } if !</description></item><item><title>raft选举流程</title><link>https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Oct 2022 09:30:00 +0800</pubDate><guid>https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/</guid><description>图解 Raft (thesecretlivesofdata.com)
算法目的：实现了分布式节点的数据一致性
节点有三个状态：follower，candidate，leader
leader election 初始阶段所有节点处于follower状态
follower状态下节点存在一个election timeout（150ms—300ms之间的随机数，随机降低了多个节点同时升级为candidate的可能性），election timeout内没有收到leader的heartbeat后，会自动升级为candidate状态，并开始一个新的election term。term是全局的，表示整个集群发生过选举的轮次(任期)。
candidate状态下，节点会向集群内所有节点发送requests votes请求。其他节点收到requests votes请求后，如果在本次term内还没有投过票，则会返回选票，如果candidate收到的选票占集群节点的大多数，则升级为本次term的leader节点。升级为leader之后向他的follower 发送append entries消息（也就是包含entry消息的心跳），follower也会返回消息的response，系统正常情况下维持在该状态
如果选举时，在一个term内发生了两个节点有同样的选票，会在超时过后进入下一轮进行重新选举
log replication client的请求只会发往leader。leader收到改动后，将改动写入日志（还未持久化commit），并将改动通过heartbeat广播至follower节点。follower节点写了entry之后（此时还未commit），返回ack。leader收到大于集群节点一半的ack之后，认为已经可以commit了，广播commit的通知。最终集群内所有follower触发commit，向leader返回ack。最后leader认为集群已经达成一致性了，向client返回ack
如果集群中产生网络隔离，每个隔离域中会产生一个新的leader，整个集群会存在多个leader。follower少的leader由于获取不到majority ack，他的entry不会被commit。此时client往另一个follower多的leader发送数据改变请求，该隔离域的节点会被commit
此时去掉网络隔离后，之前follower少的隔离域内未commit的entry会被刷成之前follower多的隔离域的entry,随后commit，此时集群再次达成一致性</description></item><item><title>etcd client v3 连接流程</title><link>https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 28 Oct 2022 09:15:00 +0800</pubDate><guid>https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/</guid><description>首先需要了解grpc框架的一些概念，这边引用网上的一张图 Resolver 提供一个用户自定义的解析、修改地址的方法，使得用户可以自己去实现地址解析的逻辑、做服务发现、地址更新等等功能。
将Endpoints里的ETCD服务器地址(127.0.0.1:2379这种格式)做一次转换传给grpc框架。也可以自己重新写此resolver，做服务发现功能。例如etcd服务器地址写nacos之类的地址，在resolver中写好转换逻辑。 调用ClientConn的ParseServiceConfig接口告诉endpoints的负载策略是轮询 Balancer 管理subConns，并收集各conn信息，更新状态至ClientConn 生成picker(balancer)的快照，从而ClientConn可以选择发送rpc请求的subConn 此处etcd client没有实现balancer，默认使用grpc提供的轮询的balancer
重试策略 与一般的c-s模型不同，etcd client的重试是针对集群的重试。单个节点的断连不会造成所有节点的重连。
重试机制 一般的重试是对同一个节点进行重试，但etcd client的自动重试不会在ETCD集群的同一节点上进行，是轮询重试集群的每个节点。重试时不会重新建连，而是使用balancer提供的transport。transport的状态更新与这一块的重试是通过balancer解耦的。
重试条件 etcd unary拦截器 拦截器类似http里的中间件的概念，在发送实际请求之前对报文进行篡改。一般用来添加认证，日志记录，缓存之类的功能。
此处etcd的一元拦截器主要做了自动重试的功能，且只会重试一些特定的错误(DeadlineExceeded, Canceled,ErrInvalidAuthToken)
func (c *Client) unaryClientInterceptor(optFuncs ...retryOption) grpc.UnaryClientInterceptor { ... if isContextError(lastErr) { if ctx.Err() != nil { // its the context deadline or cancellation. return lastErr } // its the callCtx deadline or cancellation, in which case try again. continue } if callOpts.retryAuth &amp;amp;&amp;amp; rpctypes.Error(lastErr) == rpctypes.ErrInvalidAuthToken { // clear auth token before refreshing it.</description></item><item><title>单调栈</title><link>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Thu, 13 Oct 2022 10:21:21 +0800</pubDate><guid>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。
标准模板 第一个for循环内循环输入数组， 第二个for循环维持栈内单调特性，不满足单调的元素依次出栈 第一个for循环内对元素入栈 496. 下一个更大元素 I 直接输入出栈元素即可
func nextGreaterElement(nums1 []int, nums2 []int) []int { //单调递减栈 var stack,res []int //标准模板，首个元素先入栈 stack = append(stack, 0) //由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询 map1 := make(map[int]int) for i,v := range(nums1) { map1[v] = i //顺便初始化res，查不到的为-1 res = append(res, -1) } for i:=1; i &amp;lt; len(nums2); i++ { // 单调递减，所以&amp;gt;=的都出栈 for len(stack) &amp;gt; 0 &amp;amp;&amp;amp; nums2[stack[len(stack)-1]] &amp;lt;= nums2[i] { // 查表，需要输出的加入res if idx, ok := map1[nums2[stack[len(stack)-1]]]; ok { res[idx] = nums2[i] } //pop stack = stack[:len(stack)-1] } // push stack = append(stack, i) } return res } 42.</description></item><item><title>拓扑排序(选课)</title><link>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link><pubDate>Wed, 12 Oct 2022 21:42:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid><description>207. 课程表 - 力扣（LeetCode）
思路 课程之间的依赖关系可以用图来表示
顶点：课程 边：有向的边，起点是前置课程，终点是后置课程 这种图叫做AOV（Activity On Vertex）网络，字面意思就是边代表了节点之间的活动的先后关系。
按照题意，这个图是无环的（课程不能循环依赖），也就是DAG图。DAG图其实就是一颗树，只不过根节点是一个虚拟根节点（可以有多个起始根节点，但外面可以用一个虚拟根节点作为他们的父节点）。
因此，可以用广度优先遍历（BFS）来求解。队列存放可以选的课程（入度为0），依次出队列（选课）。直到队列为空（没有课可以选了），看是否已经学完所有的课程
入度：指向自己的边的数量，入度为0表示自己没有前置课程，可以入队列 出度：指向别人的边。用一个数据结构记录每个节点的出度列表。当某个节点出队列时，更新本节点的出度列表里所有节点的入度（-1） 代码 func canFinish(numCourses int, prerequisites [][]int) bool { //保存各课程的入度 空间O(v) indegree := make([]int, numCourses) // 保存各课程的出度列表 空间O(e) courseMp := make(map[int][]int) //时间 O(e) for _, pre := range(prerequisites) { indegree[pre[0]]++ courseMp[pre[1]] = append(courseMp[pre[1]], pre[0]) } var q []int // 已经学习了的课程的计数 var num int // 初始入度为0的课程加入队列 for course, depends := range(indegree) { if depends == 0 { q = append(q, course) } } //循环直到队列为空 时间O(v) for len(q) &amp;gt; 0 { // 出队列 finished := q[0] q = q[1:] num++ // 更新入度数据结构(slice) // 从出度课程列表中直接取受影响的课程 for _, course := range(courseMp[finished]) { indegree[course]-- // 入度-1后若为0，则可以入队列 if indegree[course] == 0 { q = append(q, course) } } } //是否学完 return num == numCourses } 时间复杂度：O (v+e) 空间复杂度: O(v+e) 若需要省空间，不需要省时间，可以不使用courseMp存放出度数组，每次重新遍历prerequisites 获取出度数组。此时处理每个节点都需要重新遍历所有的边，因此：</description></item><item><title>优势洗牌(田忌赛马)</title><link>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</link><pubDate>Sat, 08 Oct 2022 10:36:00 +0800</pubDate><guid>https://scottlx.github.io/posts/%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C%E7%94%B0%E5%BF%8C%E8%B5%9B%E9%A9%AC/</guid><description>870. 优势洗牌 - 力扣（LeetCode）
思路 将nums1(自己的马)进行升序排序，得到下等马-&amp;gt;上等马的序列 贪心策略 若某个位置上自己的马比对手的马强，由于已经排过序了，已经是最下等的马了，因此使用这匹马 若某个位置上自己的马比对手的马弱，将该下等马放到最后的位置（对手的上等马的位置） 由于nums2的顺序固定（已知对手上场顺序），因此使用nums2的元素值对nums2的index进行排序，得到上场顺序（ids） 按照上场顺序(ids)依次写入ans数组中 代码 func advantageCount(nums1 []int, nums2 []int) []int { sort.Ints(nums1) n := len(nums1) ans := make([]int, n) ids := make([]int, n) for i := 0; i &amp;lt; n; i++ { ids[i] = i } sort.Slice(ids, func(i, j int) bool { return nums2[ids[i]] &amp;lt; nums2[ids[j]] }) left, right := 0, n-1 for _, v := range nums1 { if v &amp;gt; nums2[ids[left]] { ans[ids[left]] = v left++ } else { ans[ids[right]] = v right-- } } return ans } 总结 灵活运用不对数组进行真正的排序，而是获得排序后的index的顺序这一技巧</description></item></channel></rss>