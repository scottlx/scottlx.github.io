<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>单调栈 on windseek</title><link>https://scottlx.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/</link><description>Recent content in 单调栈 on windseek</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Thu, 13 Oct 2022 10:21:21 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/index.xml" rel="self" type="application/rss+xml"/><item><title>单调栈</title><link>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Thu, 13 Oct 2022 10:21:21 +0800</pubDate><guid>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>&lt;p>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。&lt;/p>
&lt;h4 id="标准模板">标准模板&lt;/h4>
&lt;ol>
&lt;li>第一个for循环内循环输入数组，&lt;/li>
&lt;li>第二个for循环维持栈内单调特性，不满足单调的元素依次出栈&lt;/li>
&lt;li>第一个for循环内对元素入栈&lt;/li>
&lt;/ol>
&lt;h4 id="496-下一个更大元素-i">
&lt;a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I&lt;/a>&lt;/h4>
&lt;p>直接输入出栈元素即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#268bd2">func&lt;/span> &lt;span style="color:#268bd2">nextGreaterElement&lt;/span>(nums1 []&lt;span style="color:#dc322f">int&lt;/span>, nums2 []&lt;span style="color:#dc322f">int&lt;/span>) []&lt;span style="color:#dc322f">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//单调递减栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#268bd2">var&lt;/span> stack,res []&lt;span style="color:#dc322f">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//标准模板，首个元素先入栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = &lt;span style="color:#b58900">append&lt;/span>(stack, &lt;span style="color:#2aa198">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1 &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#b58900">make&lt;/span>(&lt;span style="color:#268bd2">map&lt;/span>[&lt;span style="color:#dc322f">int&lt;/span>]&lt;span style="color:#dc322f">int&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> i,v &lt;span style="color:#719e07">:=&lt;/span> &lt;span style="color:#719e07">range&lt;/span>(nums1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1[v] = i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//顺便初始化res，查不到的为-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res = &lt;span style="color:#b58900">append&lt;/span>(res, &lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> i&lt;span style="color:#719e07">:=&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>; i &amp;lt; &lt;span style="color:#b58900">len&lt;/span>(nums2); i&lt;span style="color:#719e07">++&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 单调递减，所以&amp;gt;=的都出栈&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">for&lt;/span> &lt;span style="color:#b58900">len&lt;/span>(stack) &amp;gt; &lt;span style="color:#2aa198">0&lt;/span> &lt;span style="color:#719e07">&amp;amp;&amp;amp;&lt;/span> nums2[stack[&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]] &lt;span style="color:#719e07">&amp;lt;=&lt;/span> nums2[i] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// 查表，需要输出的加入res&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">if&lt;/span> idx, ok &lt;span style="color:#719e07">:=&lt;/span> map1[nums2[stack[&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]]]; ok {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res[idx] = nums2[i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">//pop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = stack[:&lt;span style="color:#b58900">len&lt;/span>(stack)&lt;span style="color:#719e07">-&lt;/span>&lt;span style="color:#2aa198">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#586e75">// push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = &lt;span style="color:#b58900">append&lt;/span>(stack, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#719e07">return&lt;/span> res
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="42-接雨水">
&lt;a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水&lt;/a>&lt;/h4>
&lt;p>出栈后计算出栈元素高度所在层的面积&lt;/p></description></item></channel></rss>