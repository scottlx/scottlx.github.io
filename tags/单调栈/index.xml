<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>单调栈 on windseek</title><link>https://scottlx.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/</link><description>Recent content in 单调栈 on windseek</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 13 Oct 2022 10:21:21 +0800</lastBuildDate><atom:link href="https://scottlx.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/index.xml" rel="self" type="application/rss+xml"/><item><title>单调栈</title><link>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</link><pubDate>Thu, 13 Oct 2022 10:21:21 +0800</pubDate><guid>https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/</guid><description>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。
标准模板 第一个for循环内循环输入数组， 第二个for循环维持栈内单调特性，不满足单调的元素依次出栈 第一个for循环内对元素入栈 496. 下一个更大元素 I 直接输入出栈元素即可
func nextGreaterElement(nums1 []int, nums2 []int) []int { //单调递减栈 var stack,res []int //标准模板，首个元素先入栈 stack = append(stack, 0) //由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询 map1 := make(map[int]int) for i,v := range(nums1) { map1[v] = i //顺便初始化res，查不到的为-1 res = append(res, -1) } for i:=1; i &amp;lt; len(nums2); i++ { // 单调递减，所以&amp;gt;=的都出栈 for len(stack) &amp;gt; 0 &amp;amp;&amp;amp; nums2[stack[len(stack)-1]] &amp;lt;= nums2[i] { // 查表，需要输出的加入res if idx, ok := map1[nums2[stack[len(stack)-1]]]; ok { res[idx] = nums2[i] } //pop stack = stack[:len(stack)-1] } // push stack = append(stack, i) } return res } 42.</description></item></channel></rss>