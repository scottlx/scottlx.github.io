<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>肖臻区块链公开课笔记</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>May 30, 2025
- 3 minute read
- <a href=https://scottlx.github.io/posts/%E8%82%96%E8%87%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>肖臻区块链公开课笔记</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><ul><li><a href=#密码学原理>密码学原理</a></li><li><a href=#数据结构>数据结构</a></li><li><a href=#比特币协议>比特币协议</a></li><li><a href=#btc-网络>BTC-网络</a></li><li><a href=#btc-挖矿难度的调整>BTC-挖矿难度的调整</a></li><li><a href=#btc-脚本>BTC-脚本</a></li><li><a href=#btc-分叉>BTC-分叉</a></li><li><a href=#匿名性>匿名性</a></li><li><a href=#qa>Q&amp;A</a></li></ul></li></ul></nav><h3 id=密码学原理>密码学原理</h3><p>主要两个技术：</p><h4 id=哈希>哈希</h4><p>密码学中用到的哈希函数： <strong>cryptographic hash function</strong></p><p>需要满足的性质：</p><ul><li><p>collision（哈希碰撞） resistance
$$
x 不等于y，H(x) = H(y)
$$
对一个message求digest（H(m)）</p><p>必定会出现哈希碰撞，没办法篡改内容使得哈希值一样（除非暴力遍历，但是工作量很大）</p><p>md5, 最开始认为collision resistance，但是后面知道如何人为制造哈希碰撞了</p></li><li><p>hiding</p><p>没法从哈希值H(x)反推出x</p><p>前提：输入空间足够大，输入空间足够均匀</p><p>与collision resistance结合，实现digital commitment（ditital equavalent of a sealed envelope）</p></li></ul><p>sealed envelope: 预测股市的结果，但是预测信息不能提前公布（会影响最终的结果），需要放在信封里先封存起来，等到第二天休市了再公布</p><p>将预测结果，哈希完之后公布出去。hiding：不能通过哈希值反推。collision resistance：预测结果不能篡改，改了对不上哈希值</p><p>要求：输入空间要足够大，一般接上随机数，保证输入足够随机且分布均匀，一起做哈希：<code>H(x || nonce)</code></p><p>puzzle friendly（比特币要求的性质）</p><p>H(x)落在的范围不可预测</p><p>000…0XX…X 事先是不知道哪个输入能算出这种类型的哈希值</p><p><strong>挖矿</strong>：找一个nonce，和区块的块头拼在一起，使得哈希值要小于等于某个指定的目标阈值</p><p>H(block header(nonce)) &lt;= target</p><p>这个挖矿的过程没有捷径，所以才可以作为工作量证明proof of work</p><p>一旦有人找到这个nonce，其他人的验证很容易，只要算一次（difficult to solve, easy to verify），设计mining puzzle需要注意这个性质</p><p><strong>SHA-256</strong>(比特币的哈希函数)</p><p>secure hash algorithm</p><h4 id=签名>签名</h4><p>比特币开户：创建公钥私钥对儿（public key, private key），来源于非对称加密体系（asymmetric encryption algorithm）</p><p>加密的公钥不需要保密，解密的私钥保密</p><p>别人转账只要知道你的公钥就可以，私钥相当于密码</p><p>用私钥来签名交易，链上用公钥去解密验证，证明交易是某人的</p><p>万一两人生成的公私钥相同？实际概率微乎其微</p><p>生成公私钥对，需要好的随机源。</p><p>不仅生成公私钥对需要好的随机源，每次签名的时候也需要好的随机源，否则可能会泄露私钥</p><h3 id=数据结构>数据结构</h3><h4 id=哈希指针>哈希指针</h4><p>保存结构体的地址和结构体的哈希值，防止结构体被篡改</p><p>不光找到结构体的地址，还能检测结构体的内容是否被篡改</p><h4 id=区块链>区块链</h4><p>Block chain is a linked list using hash pointers</p><p>哈希指针代替了普通的指针</p><p>第一个区块叫genesis block，最后一个区块是most recent block(最近产生区块)，由hash pointer连接起来，最后一个区块也有一个哈希值，保存在系统里，供下一个产生的区块直接引用，注意hash值是对前一个区块整体取hash得到的（包括里面的hash pointer）——tamper-evident log</p><p>只要记住最后一个系统里的哈希值，就能检测区块链里所有的块是否被改动</p><p>普通链表修改一个节点，对其他节点是没有影响的</p><p>由于这个性质，比特币里的区块可以不用保存以前所有的区块的hash pointer，只要前面几千个就可以。如果要用到之前的区块，向之前的区块要hash pointer就行。但是如果某个区块是有恶意的，也可以通过自己区块的hash pointer校验，看他是否发生改动。</p><p><img src=D:%5CUsers%5Clinxun2%5CDesktop%5Cbitcoin%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841.png alt=bitcoin数据结构1></p><p>如果有环哈希指针会有问题（循环依赖，哪个区块都定不下来）</p><p>Merkle Tree</p><p>和Binary Tree的区别是用hash pointer代替binary tree的指针</p><p><img src=D:%5CUsers%5Clinxun2%5CDesktop%5Cbitcoin%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.png alt=bitcoin数据结构2></p><p>内部节点都是hash pointer，leaf是data block（交易数据transaction），对根节点取hash就是root hash</p><p>只要记住root hash，就能检测出树中任何部位的修改</p><p>底下每个数据块是交易（transaction）</p><p>block header：只有根哈希值，没有交易内容</p><p>block body：交易内容</p><p>全节点（保存block header和block body）和轻节点（只保存block header，比如手机比特币钱包应用）</p><p>向轻节点如何证明某个交易是写到区块链的？</p><p>Merkel proof：找到这个交易所在的位置，从这个交易往上往根节点就是merkel proof</p><p><img src=D:%5CUsers%5Clinxun2%5CDesktop%5Cmerkel_tree.png alt=merkel_tree></p><p>merkel proof是转钱者要提供的，收钱方的钱包的的轻节点，向全节点请求merkel proof路径上这些红色的哈希值，就能往上算出每一层的哈希值，最后算到根哈希值与自己轻节点的哈希头的根哈希值做对比</p><p>proof of membership (proof of inclusion)</p><p>时间复杂度：O（logn）</p><p>proof of non-membership</p><p>若叶子节点按照哈希值排序（sorted merkel tree），就可以找到要查找的交易是在哪两个叶子之间。只要证明这两个边上的叶子是membership，就能证明要查找的交易不存在（如果存在不应该夹在中间）</p><p>时间复杂度：O（logn）代价是sorted merkel tree（比特币没用到，不需要这个性质）</p><h3 id=比特币协议>比特币协议</h3><p>数字货币存在double spending attack</p><p>区块链：每个交易要包含输入和输出，输入包含钱的来源——铸币交易coinbase transaction（使用hash指针）以及<strong>转账人的公钥</strong>，输出包含收款人公钥的hash，还需要转账人的签名</p><p>每个节点都需要知道转账人的公钥，因为交易签名使用的是转账人的私钥，大家验证需要使用其公钥验证</p><p>铸币交易的输出包含获得人的公钥，后续交易的输入公钥需要和最初的coinbase交易的公钥对得上</p><p>实际上BTC上每个区块链上都也很多交易组成Merkle Tree</p><p>每个区块分成Block header和Block body</p><table><thead><tr><th><strong>Block header</strong></th><th><strong>Block body</strong></th></tr></thead><tbody><tr><td>version</td><td>transaction list</td></tr><tr><td>hash of previous block header (only caculate block header)</td><td></td></tr><tr><td>Merkle root hash</td><td></td></tr><tr><td>nBits（256位target的压缩编码 4bytes）</td><td></td></tr><tr><td>nonce</td><td></td></tr></tbody></table><p>BTC每个节点可分为full node (fully validating node) 和 light node (只保存block header)，主要是后者</p><p>账本内容要取得分布式的共识distributed consensus，共同维护distributed hash table</p><p>有人提出FLP impossibility result，即在一个异步且时延没有上限的网络中，只要有一个人是faulty，整个网络就无法达成共识；另外有人提出CAP Theorem (Consistency, Availability, Partition tolerance)，即这三个性质最多得到两个</p><p>BTC的共识协议：</p><p>若采用投票，需要确定membership（如hyperledger fabric联盟链，只有某些大公司能参与，投票可以），BTC中恶意者不断产生公私钥就一直获得投票权sybil attack。</p><p>在BTC中，$H(block~header)\le target$中有一个4bytes的$nonce$，求出符合该式的$nonce$即可获得记账权</p><p>当hash of previous block header不是指向longest valid chain的最后的时候，这个区块就新开了一个分支（分叉攻击forking attack），正常情况应该是接在最长合法链的后面。</p><p>但是还有一种情况，两个区块同时获得记账权，都接在longest valid chain的最后产生分叉，此时各个本地区块会根据网络延迟先接上两者之一。之后如果在两者其中之一继续先扩展下一个区块（看算力和运气）就变成了最长合法链，另外一个就变成了orphan block被丢弃掉</p><p>BTC设置block reward来让大家争夺记账权，因为这是铸币的唯一方式</p><h4 id=btc-系统实现>BTC-系统实现</h4><p>BTC：transaction-base ledger</p><p>全节点在内存中维护UTXO (Unspent Transaction Output)，防止double spending</p><p>除了出块奖励之外，为了防止某人在打包区块链的时候只打包自己的交易记录，于是提供了transaction fee作为奖励</p><p>为了增大nonce的搜索空间，可以使用coinbase txn的前几个字节作为extra nonce，因为coinbase txn的内容是随意的但是修改它会导致Merkle Tree Root的hash值发生改变</p><p>尝试nonce成功是伯努利过程，接近于Possion分布，无记忆性（将来挖的时间和过去挖的时间没有关系），系统平均出块时间为10min</p><p>BTC的数量： $$ 210000<em>50+210000</em>25+\dots=210000<em>50</em>(1+\frac12+\frac14+\dots)=21000000 $$ 挖矿求解过程没有意义，但是Bitcoin is secured by mining：当大部分算力掌握在诚实节点上的时候就是安全的（用算力投票）</p><p>记账权的获得有时候看运气，所以可能会落入恶意节点，此时</p><ul><li>不能偷币（因为没有转账人的私钥签名，即使写到链上，它不是最长<strong>合法</strong>链所以诚实节点不会接上去，所以此恶意攻击者甚至拿不到出块奖励）</li><li>可能出现double spending——难度较大（forking attack，同时写入转账和回滚产生分支，交易平台看到写入转账的区块就认为交易成功，但是之后可能回滚分支成为最长合法链，如果本来转账分支之后就已经接着很多区块了，这种方法就比较困难，所以BTC的防范方法是six confirmation，需要1小时时间，故BTC的不可篡改性是概率上的保证；另一种方法是zero confirmation，直接选择最先被接受的节点，或者电商平台本来交易完到发货就有时间差可以用来检验合法性）</li><li>故意不包含合法交易，但是总有合法的区块会发布这些交易</li><li>selfish mining——正常情况下挖到区块直接发布，但是也可以挖到多块区块连在一起然后forking attack一次性接上去。但是前提是恶意算力比较大的时候才比较容易成功篡改。但是这种方法也有好处，减少竞争，关键还是需要算力比较大，风险在于当别人比你早挖出来的时候要赶紧接上去</li></ul><p>ETH：account-based ledger</p><p>系统显式地记录每个账户上的币</p><h3 id=btc-网络>BTC-网络</h3><p>BTC工作在application layer，底层network layer是P2P Overlay Network，在这个网络里所有节点都是平等的，没有super node/master node，加入网络需要知道seed node种子节点</p><p>BTC网络的目标：简单，鲁棒而不是高效</p><p>BTC协议对区块大小的限制为1M</p><p>best effort，一个交易不一定让所有节点都收到，顺序也不一定一样，有些节点可能转发错误的交易</p><h3 id=btc-挖矿难度的调整>BTC-挖矿难度的调整</h3><p>Double subscripts: use braces to clarify</p><p>$difficulty=\frac{difficulty_1_target}{target}$</p><p>分子是当难度为1（最低）的时候的目标阈值，是一个很大的数</p><p>出块时间太短导致：这个区块在网络上来不及广播，使得多分叉变成常态，一旦出现多分叉，善意的算力被分散，而恶意算力可以集中在一个分叉上使得其不断延伸成为最长合法链，使得51% attack的数字会变小</p><p>每2016个区块调整一下难度，大概是14天一次，$target=target\times \frac{actualtime}{expectedtime}$</p><p>恶意节点无法执行调整nBits来降低难度因为别的区块验证会通不过</p><h3 id=btc-脚本>BTC-脚本</h3><p>基于栈的语言</p><p>&ldquo;result&rdquo;: {
&ldquo;txid&rdquo;:&ldquo;921a&mldr;dd24&rdquo;,
&ldquo;hash&rdquo;:&ldquo;921a&mldr;dd24&rdquo;,
&ldquo;version&rdquo;:1,
&ldquo;size&rdquo;:226,
&ldquo;locktime&rdquo;:0,
&ldquo;vin&rdquo;:[],
&ldquo;vout&rdquo;:[],
&ldquo;blockhash&rdquo;:&ldquo;00000000002c510d&mldr;5c0b&rdquo;,
&ldquo;confirmations&rdquo;:23,
&ldquo;time&rdquo;:1530846727,
&ldquo;blocktime&rdquo;:1530846727}
// locktime为0表示立刻生效"vin": [{
&ldquo;txid&rdquo;:"",
&ldquo;vout&rdquo;:0,
&ldquo;scriptSig&rdquo;: {
&ldquo;asm&rdquo;:"",
&ldquo;hex&rdquo;:""}
}]
// 上面vout的值表示是txid交易的第几个输出"vout": [{
&ldquo;value&rdquo;:0.1,
&ldquo;n&rdquo;:0,
&ldquo;scriptPubKey&rdquo;: {
&ldquo;asm&rdquo;:&ldquo;DUP HASH160 628e&mldr; EQUALVERIFY CHECKSIG&rdquo;,
&ldquo;hex&rdquo;:&ldquo;76a9&mldr;&rdquo;,
&ldquo;reqSigs&rdquo;:1,
&ldquo;type&rdquo;:&ldquo;pubkeyhash&rdquo;,
&ldquo;addresses&rdquo;:["&mldr;."]
}
}]
// 上面n表示为当前输出的第几个，asm输出脚本的内容，reqSigs表示需要的签名数量</p><p>某个区块A的输入来源于区块B的输出，那么将A的input script和B的output script（注意<strong>不是</strong>A的output script）拼接在一起，先执行前者，后执行后者，如果结果为true就表示合法</p><p>几种类型：</p><ul><li><p>P2PK (Pay to Public Key)</p></li><li><ul><li><p>input script</p></li><li><ul><li>PUSHDATA (Sig)</li></ul></li><li><p>output script</p></li><li><ul><li>PUSHDATA (PubKey)</li><li>CHECKSIG</li></ul></li></ul></li><li><p>P2PKH (Pay to Public Key Hash) 最常用</p></li><li><ul><li><p>input script</p></li><li><ul><li>PUSHDATA (Sig) 压栈</li><li>PUSHDATA (PubKey) 压栈</li></ul></li><li><p>output script</p></li><li><ul><li>DUP 复制一份栈顶并压栈</li><li>HASH160 弹出栈顶pubkey取hash压入栈</li><li>PUSHDATA (PubKeyHash) 压入pubkeyhash</li><li>EQUALVERIFY 弹出栈顶两个hash值是否相等，防止某人以自己的公钥顶替</li><li>CHECKSIG 最后将sig和pubkey进行check正确就返回true</li></ul></li></ul></li><li><p>P2SH (Pay to Script Hash)</p></li><li><ul><li><p>input script</p></li><li><ul><li>&mldr;</li><li>PUSHDATA (Sig)</li><li>&mldr;</li><li>PUSHDATA (serialized redeemScript)</li></ul></li><li><p>output script</p></li><li><ul><li>HASH160</li><li>PUSHDATA (redeemScriptHash)</li><li>EQUAL</li></ul></li><li><p>简单来说就是另外有一个redeem script，首先执行input和output，最后执行redeem的内容</p></li><li><p>支持多重签名
将input script中改成</p></li><li><ul><li>false (Bitcoin的实现BUG，这里多压入一个没用的元素)</li><li>PUSHDATA (Sig_1)</li><li>&mldr;</li><li>PUSHDATA (Sig_M)</li><li>PUSHDATA (serialized redeemScript)
将redeemScript写成</li><li>M 表示总的签名数</li><li>PUSHDATA (pubkey_1)</li><li>&mldr;</li><li>PUSHDATA (pubkey_N)</li><li>N</li><li>CHECKMULTISIG</li></ul></li></ul></li><li><p>Proof of Burn</p></li><li><ul><li><p>output script</p></li><li><ul><li>RETURN [zero or more ops or text]</li><li>这种形式的output被称为Provably Unspendable/Prunable Outputs</li></ul></li><li><p>脚本说明：return直接返回false，这个output无法被花出去，UTXO可以剪枝</p></li><li><p>应用</p></li><li><ul><li>AltCoin (Alternative Coin) 销毁Bitcoin获得小币</li><li>花费非常少的BTC将某些内容取hash放到return后面，这样就能放到区块链上 （coinbase中也是随意记东西的，但是只有获得记账权的节点才能写东西）</li></ul></li></ul></li></ul><h3 id=btc-分叉>BTC-分叉</h3><ul><li><p>state fork 状态分叉，意见分歧</p></li><li><ul><li>包括forking attack，也被称为deliberate fork</li></ul></li><li><p>protocol fork 协议分叉</p></li><li><ul><li><p>不同协议造成的分叉</p></li><li><p>进一步分成hard fork和soft fork</p></li><li><p>hard fork</p></li><li><ul><li>扩展新的特性（如修改block size为4M）时如果不认可新的特性就会产生硬分叉</li><li>旧节点在原来的链上不断延伸，新节点在新的链上延伸，产生永久性的分叉</li><li>当前交易速度约为每秒7笔交易</li><li>由此社区分裂成两帮人，一个币拆成了两个币，各自有自己的chain id</li></ul></li><li><p>soft fork</p></li><li><ul><li>临时的分叉（如修改block size为1M）</li><li>旧节点会放弃旧链，在新链上延伸，但是此时新节点又不会认当前链为最长合法链而新开一个分叉，使得旧节点一直是白挖</li><li>最终还是会变成一条链</li><li>例子：给原来的某些域一些新的含义，比如给coinbase域增加含义extra nonce+UTXO的根hash</li></ul></li></ul></li></ul><h3 id=匿名性>匿名性</h3><p>pseudonymity 匿名性不如纸币高于银行</p><p>不同账户之间可以建立关联、BTC和现实世界也可以形成关联</p><p>在network layer上实现匿名性：使用TOR</p><p>在application layer上实现匿名性：coin mixing、在线钱包本身可能带有coin mixing功能、交易所天然有coin mixing功能（如果交易所不暴露提币存币的记录）</p><h3 id=qa>Q&amp;A</h3><ul><li>如果收款人没有连接到BTC网络？
没有关系</li><li>OP_RETURN永远返回false为啥会写到区块链上？
因为这个RETURN语句是写在output script，因此在验证这笔交易的时候并不执行</li><li>交易费给哪位？
交易费等于总输入减总输出，剩下的直接给挖到的矿工即可</li></ul><p>证明者向验证者证明一个陈述是正确的，而无需透露该陈述是正确的外任何信息</p><p>数学基础：同态隐藏</p><ul><li>如果$x,y$不同，那么$E(x)$和$E(y)$也不同</li><li>给定$E(x)$，很难反对出$x$的值（类似hiding）</li><li>同态运算：同态加法、同态乘法、扩展到多项式</li></ul><p>为匿名性设计的加密货币：零币和零钞</p><ul><li>hash pointer只有本地的地址，发布到区块链网络上会咋样？
网络上没有指针，只有hash，全节点维护一个数据库保存(key, value)，常用的是levelDB</li><li>分布式共识
BTC实际上也没有取得 真正的共识，但是实际和理论是不一样的</li></ul></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>May 30, 2025</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/%e5%8c%ba%e5%9d%97%e9%93%be>区块链</a> <a class=category href=https://scottlx.github.io/tags/bitcoin>“bitcoin"</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/nfv%E5%8C%96dpvs%E7%9A%84cpu-fdir/ title="nfv化dpvs的cpu fdir">nfv化dpvs的cpu fdir</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>