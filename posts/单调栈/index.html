<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>单调栈</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek的博客</a></h1><h2>golang、云计算、SDN、NFV、软件架构</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/tools/>» 工具</option><option value=https://scottlx.github.io/archives/>» 归档</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/tools/ title=工具 target=_blank rel="noopener noreferrer">工具</a></li><li><a href=https://scottlx.github.io/archives/ title=归档 target=_blank rel="noopener noreferrer">归档</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Oct 13, 2022
- 3 minute read
- <a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title><a href=https://scottlx.github.io/posts/%E5%8D%95%E8%B0%83%E6%A0%88/>单调栈</a></h1></header><div class=entry-content><p>由于数据在栈内是单调递增或单调递减的，单调栈适合用来找出数组中第一个大于或小于某个元素的场景。元素出栈后，再根据题意对出栈元素进行处理，更新数据至result。</p><h4 id=标准模板>标准模板</h4><ol><li>第一个for循环内循环输入数组，</li><li>第二个for循环维持栈内单调特性，不满足单调的元素依次出栈</li><li>第一个for循环内对元素入栈</li></ol><h4 id=496-下一个更大元素-i><a href=https://leetcode.cn/problems/next-greater-element-i/ target=_blank rel=noopener>496. 下一个更大元素 I</a></h4><p>直接输入出栈元素即可</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>nextGreaterElement</span>(nums1 []<span style=color:#dc322f>int</span>, nums2 []<span style=color:#dc322f>int</span>) []<span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>//单调递减栈</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>var</span> stack,res []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//标准模板，首个元素先入栈</span>
</span></span><span style=display:flex><span>    stack = <span style=color:#b58900>append</span>(stack, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//由于只需要输出num1的元素，构造nums1的map作为需要输出数据的查询</span>
</span></span><span style=display:flex><span>    map1 <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>(<span style=color:#268bd2>map</span>[<span style=color:#dc322f>int</span>]<span style=color:#dc322f>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> i,v <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span>(nums1) {
</span></span><span style=display:flex><span>        map1[v] = i
</span></span><span style=display:flex><span>        <span style=color:#586e75>//顺便初始化res，查不到的为-1</span>
</span></span><span style=display:flex><span>        res = <span style=color:#b58900>append</span>(res, <span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> i<span style=color:#719e07>:=</span><span style=color:#2aa198>1</span>; i &lt; <span style=color:#b58900>len</span>(nums2); i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#586e75>// 单调递减，所以&gt;=的都出栈</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> nums2[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] <span style=color:#719e07>&lt;=</span> nums2[i] {
</span></span><span style=display:flex><span>            <span style=color:#586e75>// 查表，需要输出的加入res</span>
</span></span><span style=display:flex><span>            <span style=color:#719e07>if</span> idx, ok <span style=color:#719e07>:=</span> map1[nums2[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]]]; ok {
</span></span><span style=display:flex><span>                res[idx] = nums2[i]
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#586e75>//pop</span>
</span></span><span style=display:flex><span>            stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#586e75>// push</span>
</span></span><span style=display:flex><span>        stack = <span style=color:#b58900>append</span>(stack, i)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=42-接雨水><a href=https://leetcode.cn/problems/trapping-rain-water/ target=_blank rel=noopener>42. 接雨水</a></h4><p>出栈后计算出栈元素高度所在层的面积</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#586e75>/*
</span></span></span><span style=display:flex><span><span style=color:#586e75>
</span></span></span><span style=display:flex><span><span style=color:#586e75>{2, 1, 0, 1, 3}
</span></span></span><span style=display:flex><span><span style=color:#586e75>                  3
</span></span></span><span style=display:flex><span><span style=color:#586e75>                +---+
</span></span></span><span style=display:flex><span><span style=color:#586e75>  2             |   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>+---+           +   +
</span></span></span><span style=display:flex><span><span style=color:#586e75>    | 1       1 |   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>    +---+   +---+   +
</span></span></span><span style=display:flex><span><span style=color:#586e75>        | 0 |       |
</span></span></span><span style=display:flex><span><span style=color:#586e75>  	    +---+       +
</span></span></span><span style=display:flex><span><span style=color:#586e75> 0    1   2   3   4
</span></span></span><span style=display:flex><span><span style=color:#586e75>
</span></span></span><span style=display:flex><span><span style=color:#586e75> 1. 按照下标0-&gt;1-&gt;2入栈
</span></span></span><span style=display:flex><span><span style=color:#586e75> 2. 下标3入栈前依次对2-&gt;1进行出栈，出栈结束后下标0还在栈内
</span></span></span><span style=display:flex><span><span style=color:#586e75>   a. 下标2出栈时，res += (min(height[3], height[1]) - height[2])*(3-1-1)
</span></span></span><span style=display:flex><span><span style=color:#586e75>   b. 下标1出栈时，res += (min(height[3], height[0]) - height[1])*(3-0-1)
</span></span></span><span style=display:flex><span><span style=color:#586e75> 3. 下标4入栈前依次对3进行出栈，res += (min(height[4], height[0]) - height[3])*(4-0-1)
</span></span></span><span style=display:flex><span><span style=color:#586e75>
</span></span></span><span style=display:flex><span><span style=color:#586e75>res的加入是从右向左，按层的方式加入的
</span></span></span><span style=display:flex><span><span style=color:#586e75>*/</span>
</span></span><span style=display:flex><span><span style=color:#586e75>// @lc code=start</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>trap</span>(height []<span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> stack []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> res <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	min <span style=color:#719e07>:=</span> <span style=color:#268bd2>func</span>(a, b <span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> a &lt; b {
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> a
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> b
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	stack = <span style=color:#b58900>append</span>(stack, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#2aa198>1</span>; i &lt; <span style=color:#b58900>len</span>(height); i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> height[i] <span style=color:#719e07>&gt;=</span> height[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] {
</span></span><span style=display:flex><span>			cachedTop <span style=color:#719e07>:=</span> height[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]]
</span></span><span style=display:flex><span>			stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> <span style=color:#b58900>len</span>(stack) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#719e07>break</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			res <span style=color:#719e07>+=</span> (i <span style=color:#719e07>-</span> stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>] <span style=color:#719e07>-</span> <span style=color:#2aa198>1</span>) <span style=color:#719e07>*</span> (<span style=color:#b58900>min</span>(height[i], height[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]]) <span style=color:#719e07>-</span> cachedTop)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		stack = <span style=color:#b58900>append</span>(stack, i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=739-每日温度><a href=https://leetcode.cn/problems/daily-temperatures/ target=_blank rel=noopener>739. 每日温度</a></h4><p>出栈后记录于外层循环中入栈元素下标的差值</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>dailyTemperatures</span>(temperatures []<span style=color:#dc322f>int</span>) []<span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#586e75>//由于最后求idx的距离，stack存下标</span>
</span></span><span style=display:flex><span>    <span style=color:#268bd2>var</span> stack []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//res不是按顺序append的（出栈的顺序）</span>
</span></span><span style=display:flex><span>    res <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([]<span style=color:#dc322f>int</span>, <span style=color:#b58900>len</span>(temperatures))
</span></span><span style=display:flex><span>    stack = <span style=color:#b58900>append</span>(stack, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#719e07>for</span> i<span style=color:#719e07>:=</span><span style=color:#2aa198>1</span>; i&lt;<span style=color:#b58900>len</span>(temperatures);i<span style=color:#719e07>++</span>{
</span></span><span style=display:flex><span>    <span style=color:#586e75>//一直出栈，直到栈空或满足单调递减了</span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>//并做记录，写入res</span>
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> temperatures[i] &gt; temperatures[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] {
</span></span><span style=display:flex><span>            <span style=color:#586e75>//记录出栈的位置，值为新入栈的位置减去出栈的位置</span>
</span></span><span style=display:flex><span>            res[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] = i <span style=color:#719e07>-</span> stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>            stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        stack = <span style=color:#b58900>append</span>(stack, i)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#586e75>//初始化时后面的数已经补零了</span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=84-柱状图中最大的矩形><a href=https://leetcode.cn/problems/largest-rectangle-in-histogram/ target=_blank rel=noopener>84. 柱状图中最大的矩形</a></h4><p>与接雨水相反（接雨水算的是矩形外面的面积），这题算的是矩形的面积</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>largestRectangleArea</span>(heights []<span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>	max <span style=color:#719e07>:=</span> <span style=color:#268bd2>func</span>(a, b <span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> a &gt; b {
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> a
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> b
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	heights = <span style=color:#b58900>append</span>([]<span style=color:#dc322f>int</span>{<span style=color:#2aa198>0</span>}, heights<span style=color:#719e07>...</span>)
</span></span><span style=display:flex><span>	heights = <span style=color:#b58900>append</span>(heights, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> res <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>//单调递增栈</span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> stack []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	stack = <span style=color:#b58900>append</span>(stack, <span style=color:#2aa198>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#2aa198>1</span>; i &lt; <span style=color:#b58900>len</span>(heights); i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> heights[i] &lt; heights[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]] {
</span></span><span style=display:flex><span>			res = <span style=color:#b58900>max</span>(res, (i<span style=color:#719e07>-</span>stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>2</span>]<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>)<span style=color:#719e07>*</span>heights[stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]])
</span></span><span style=display:flex><span>			stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		stack = <span style=color:#b58900>append</span>(stack, i)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> res
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=769-最多能完成排序的块---力扣leetcode><a href=https://leetcode.cn/problems/max-chunks-to-make-sorted/ target=_blank rel=noopener>769. 最多能完成排序的块 - 力扣（LeetCode）</a></h4><p>子区间的最大值是单调递增的，因此栈保存每个子区间最大的元素值</p><ul><li>新元素比栈顶元素大：入栈新区间</li><li>新元素比栈顶元素小：子区间最大值比新元素小的出栈（出栈的子区间合并到栈顶的子区间）</li></ul><p><img src=/img/algorithm/leetcode769.png alt=image-20221013101902399></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>maxChunksToSorted</span>(arr []<span style=color:#dc322f>int</span>) <span style=color:#dc322f>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 单调递增栈，存放各个子区间的最大值</span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> stack []<span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	stack = <span style=color:#b58900>append</span>(stack, arr[<span style=color:#2aa198>0</span>])
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#2aa198>1</span>; i &lt; <span style=color:#b58900>len</span>(arr); i<span style=color:#719e07>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> arr[i] &gt; stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>] {
</span></span><span style=display:flex><span>			<span style=color:#586e75>//若新元素比栈顶元素大， 入栈新区间的最大值</span>
</span></span><span style=display:flex><span>			stack = <span style=color:#b58900>append</span>(stack, arr[i])
</span></span><span style=display:flex><span>		} <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#586e75>//暂存最大的区间</span>
</span></span><span style=display:flex><span>			mx <span style=color:#719e07>:=</span> stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>			<span style=color:#719e07>for</span> <span style=color:#b58900>len</span>(stack) &gt; <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span> arr[i] <span style=color:#719e07>&lt;=</span> stack[<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>] {
</span></span><span style=display:flex><span>				stack = stack[:<span style=color:#b58900>len</span>(stack)<span style=color:#719e07>-</span><span style=color:#2aa198>1</span>]
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#586e75>//重新入栈这个区间的最大值</span>
</span></span><span style=display:flex><span>			stack = <span style=color:#b58900>append</span>(stack, mx)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> <span style=color:#b58900>len</span>(stack)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Oct 13, 2022</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/go>go</a> <a class=category href=https://scottlx.github.io/tags/%e5%8d%95%e8%b0%83%e6%a0%88>单调栈</a> <a class=category href=https://scottlx.github.io/tags/%e7%ae%97%e6%b3%95>算法</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/ title=拓扑排序(选课)>拓扑排序(选课)</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/etcd-client-v3%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B/ title="etcd client v3 连接流程">etcd client v3 连接流程</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Sidebar Header</h1><p><p>Here&rsquo;s a
<a href=https://www.google.com target=_blank rel=noopener>link to google</a></p><p>New paragraph</p><p>Another paragraph which has two spaces in the end to create a new line using markdown<br>New line but not a new paragraph</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a></li></ul><section class=odd><h1>Sidebar Links</h1><li><a href=https://scottlx.github.io/about title="About me">About me</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>