<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>cilium endpoint 创建流程</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>May 30, 2025
- 1 minute read
- <a href=https://scottlx.github.io/posts/cilium-endpoint-%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>cilium endpoint 创建流程</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><ul><li><a href=#cilium-controller>cilium controller</a></li><li><a href=#ebpf程序加载流程>ebpf程序加载流程</a></li></ul></li></ul></nav><p>pod创建后，cilium打通网络涉及以下内容：</p><ol><li>lxc网卡的创建（cni插件）</li><li>bpf代码的加载（agent）</li><li>ipam 地址分配（agent）</li><li>endpoint CR的创建（agent）</li><li>endpoint生命周期管理（agent）</li></ol><p>具体流程如下图</p><p><img src=/img/blobs/cilium_cni%E6%B5%81%E7%A8%8B.png alt=cilium_cni流程></p><blockquote><p>流程说明</p></blockquote><p>cni add流程主要分三步：</p><ol><li>调用ipam接口从agent获取ip信息</li><li>创建lxc网卡（veth），根据ip信息配置网卡（mtu，gso，gro配置），容器命名空间内路由等</li><li>调用endpointCreate接口通知agent开始接管lxc网卡（加载bpf代码等）</li></ol><p>如果启用了cniChaning，还会去执行chaining的动作</p><p>ipam流程将在后期详细介绍，本篇主要分析endpointCreate之后的流程，也就是bpf代码是如何加载到lxc网卡上的。</p><h3 id=cilium-controller>cilium controller</h3><p>cilium agent代码内部，对于资源同步的场景，设计了一套controller框架。</p><p>controller可以理解为异步任务控制器，在后台尝试某一对象的同步任务直到成功，并记录成功失败次数，错误日志等监控数据。每个controller对应一个协程。</p><p>controller需要被manager绑定，而manager则绑定到某一特定资源，比如endpoint</p><p>由于资源的变配会需要多个异步任务的执行，因此一个manager可以关联多个controller，单个controller只负责某一特定的异步任务(只要是可能失败并需要重试的任务都适用，例如给k8s资源打annotation，同步对象到某个存储，kvstore，bpfmap等）</p><p>controller之间通信通过eventqueue进行异步解耦。每个evq对应一个协程</p><h4 id=endpoint-manager的架构图>endpoint manager的架构图</h4><p>![cilium agent](/img/blobs/cilium agent.png)</p><blockquote><p>说明</p></blockquote><p>上图中，endpoint manager维护了本节点endpoint列表，并实现了</p><ul><li>gc controller：endpoint定期清理，清理不健康的endpoint。</li><li>regenerate controller：endpoint定期全量重建，重建ep对应的policy和configuration</li></ul><p>CNI创建endpoint后，endpoint对象会被创建。每个endpoint初始化时会有一个eventQueue和处理该eventQueue的一个controller。endpoint manager会将regen事件入队到endpoint的eventQueue中，并启动endpoint的sync Controller。sync Controller会同步ep信息到k8s cep CR，这样用户就可以从apiserver获取endpoint状态了</p><h3 id=ebpf程序加载流程>ebpf程序加载流程</h3><p>eventQueue中的regeneration event会触发endpoint的重建，也就是相关ebpf程序的编译加载和ebpf map数据的插入。</p><p>bpf程序加载会发生在几种情况下：</p><ol><li>第一次创建时进行初始化</li><li>cilium重启时，会进行一次regenerate（按需初始化）</li><li>用户执行cilium endpoint regenerate 时（按需）</li><li>用户执行ciluim config时（按需）</li></ol><p>程序是否加载由编译级别来控制</p><ul><li><p>0 -> “invalid” (未设置)</p></li><li><p>1：RegenerateWithoutDatapath -> “no-rebuild” （更新policy，dns，只需更新map，不重新编译加载bpf）</p></li><li><p>2：RegenerateWithDatapath -> &ldquo;rewrite+load&rdquo; （新创建endpoint）</p></li></ul><p>这边可能会有个疑问，为什么更新policy不是更新lxc代码。这是因为policy代码是在bpf_lxc的最后使用尾调用执行的。因此更新policy只要更新prog bpf，而不需要动已经加载在lxc上的代码</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>static</span> __always_inline <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>l3_local_delivery</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx, __u32 seclabel,
</span></span><span style=display:flex><span>		  __u32 magic __maybe_unused,
</span></span><span style=display:flex><span>		  <span style=color:#719e07>const</span> <span style=color:#719e07>struct</span> endpoint_info <span style=color:#719e07>*</span>ep __maybe_unused,
</span></span><span style=display:flex><span>		  __u8 direction __maybe_unused,
</span></span><span style=display:flex><span>		  <span style=color:#dc322f>bool</span> from_host __maybe_unused,
</span></span><span style=display:flex><span>		  <span style=color:#dc322f>bool</span> from_tunnel __maybe_unused, __u32 cluster_id __maybe_unused)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#586e75>/*省略一些代码*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Jumps to destination pod&#39;s BPF program to enforce ingress policies. */</span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ctx_store_meta</span>(ctx, CB_SRC_LABEL, seclabel);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ctx_store_meta</span>(ctx, CB_DELIVERY_REDIRECT, <span style=color:#2aa198>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ctx_store_meta</span>(ctx, CB_FROM_HOST, from_host <span style=color:#719e07>?</span> <span style=color:#2aa198>1</span> <span style=color:#719e07>:</span> <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ctx_store_meta</span>(ctx, CB_FROM_TUNNEL, from_tunnel <span style=color:#719e07>?</span> <span style=color:#2aa198>1</span> <span style=color:#719e07>:</span> <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>ctx_store_meta</span>(ctx, CB_CLUSTER_ID_INGRESS, cluster_id);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> <span style=color:#268bd2>tail_call_policy</span>(ctx, ep<span style=color:#719e07>-&gt;</span>lxc_id);
</span></span><span style=display:flex><span><span style=color:#719e07>#endif
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>}
</span></span></code></pre></div><p>EndpointRegenerationEvent handler流程</p><p><img src=/img/blobs/emvs-regenerate.png alt=emvs-regenerate></p><p>endpoint的配置（例如开启debug，trace）是通过修改编译时的头文件来实现的</p><p>下面是state目录</p><p><img src=/img/blobs/endpoint%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.PNG alt=endpoint编译文件目录></p><p>可以看到每个endpoint会有一个ep id对应的目录，目录里包含该ep的配置生成的头文件<code>ep_config.h</code>。</p><p>代码仓库里的<code>ep_config.h</code>只是一个样例，实际的是以state目录下生成的为准。</p><p>相应的，netdev也有配置文件<code>node-config.h</code></p><p>编译过程中，会生成tmpDir，用来保存编译时的headers。只有整个generation完全成功后，tmpDir才会覆盖origDir。</p><p>可以在state目录下执行<code>inotifywait -r -m . -e open -e move -e create -e delete</code> 查看相关文件的生成情况</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>May 30, 2025</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/ebpf>ebpf</a> <a class=category href=https://scottlx.github.io/tags/cilium>cilium</a> <a class=category href=https://scottlx.github.io/tags/k8s>k8s</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/dpdk%E8%BD%AC%E5%8F%91%E9%9D%A2trace/ title=dpdk转发面trace>dpdk转发面trace</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>