<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>数位dp</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek的博客</a></h1><h2>golang、云计算、SDN、NFV、软件架构</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/tools/>» 工具</option><option value=https://scottlx.github.io/archives/>» 归档</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/tools/ title=工具 target=_blank rel="noopener noreferrer">工具</a></li><li><a href=https://scottlx.github.io/archives/ title=归档 target=_blank rel="noopener noreferrer">归档</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Mar 20, 2023
- 2 minute read
- <a href=https://scottlx.github.io/posts/%E6%95%B0%E4%BD%8Ddp/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e7%ae%97%e6%b3%95%e7%ac%94%e8%ae%b0/>算法笔记</a></p><h1 class=entry-title>数位dp</h1></header><div class=entry-content><h2 id=题目特征>题目特征</h2><ul><li><p>要求统计满足一定条件的数的数量（即，最终目的为计数，若要结果则只能回溯爆搜得到）；</p></li><li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p></li><li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p></li><li><p>上界很大（比如 10^{18}），暴力枚举验证会超时。</p></li></ul><h2 id=思路>思路</h2><p>从高到低枚举每一位，统计符合target的个数，并记录到dp数组中。枚举完毕之后则得到答案。</p><p>因此数位dp的第一个状态都是数位的位置，第二个状态由题意来定</p><h2 id=模板>模板</h2><p>以leetcode1012为例，统计小于等于n的数字中每一位的数字至少重复一次的个数。</p><p>模板时灵神的模板。难点主要是mask，isLimit，isNum这几个标识</p><ul><li>mask即dp的第二个状态，这边用到了状态压缩的思想，将0到9选过的状态压缩成一个数字(否则要10个状态)</li><li>isLimit 标识了本次(i)选择的范围，是否受到n的影响。如果不引进这个变量，则需要考虑当前数字的最高位来决定本次的范围(最高位==n的最高位时，本次的范围是[0,s[i]],最高位&lt;n的最高位时，本次的范围是[0,9])。可以发现这个限制是有传递的性质的，因此引入这个变量能简化范围的选择过程。</li><li>isNum 标识了本次(i)之前是否有数字，换句话说本次(i)是否是第一个数字(最高位)。这个标识主要是解决前导0的问题，否则答案里会重复(前导两个0和前导三个0虽然是同个数字，但都会被记入答案)</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#268bd2>func</span> <span style=color:#268bd2>numDupDigitsAtMostN</span>(n <span style=color:#dc322f>int</span>) (ans <span style=color:#dc322f>int</span>) {
</span></span><span style=display:flex><span>	s <span style=color:#719e07>:=</span> strconv.<span style=color:#268bd2>Itoa</span>(n) <span style=color:#586e75>// s[0]是最高位</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* 若需要从低到高的顺序，则按如下生成
</span></span></span><span style=display:flex><span><span style=color:#586e75>		for ; n &gt; 0; n = n / 10 {
</span></span></span><span style=display:flex><span><span style=color:#586e75>	        list = append(list, n%10)
</span></span></span><span style=display:flex><span><span style=color:#586e75>	    }
</span></span></span><span style=display:flex><span><span style=color:#586e75>	*/</span>
</span></span><span style=display:flex><span>	m <span style=color:#719e07>:=</span> <span style=color:#b58900>len</span>(s)
</span></span><span style=display:flex><span>	dp <span style=color:#719e07>:=</span> <span style=color:#b58900>make</span>([][<span style=color:#2aa198>1</span> <span style=color:#719e07>&lt;&lt;</span> <span style=color:#2aa198>10</span>]<span style=color:#dc322f>int</span>, m)
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 数位dp的第一个状态都是数位的位置，第二个状态由题意来定</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 问题转换为计算没有重复数字的个数，因此第二个状态记录已经选过数字的集合</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// i 表示从高到低第i位， j是前面已经选过的数字的集合,最大为[0,9]的子集个数</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 例如集合 {0,2,3} 对应的二进制数为 1101 （集合的思想就是状压）</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> i <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> dp {
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> j <span style=color:#719e07>:=</span> <span style=color:#719e07>range</span> dp[i] {
</span></span><span style=display:flex><span>			dp[i][j] = <span style=color:#719e07>-</span><span style=color:#2aa198>1</span> <span style=color:#586e75>// -1 表示没有计算过</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#268bd2>var</span> f <span style=color:#268bd2>func</span>(<span style=color:#dc322f>int</span>, <span style=color:#dc322f>int</span>, <span style=color:#dc322f>bool</span>, <span style=color:#dc322f>bool</span>) <span style=color:#dc322f>int</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// mask是dp数组中第二个状态</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// isLimit表示当前是否受到n的约束，若为true表示当前位最大填s[i]</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 若isLimit为true时填了s[i],则isLimit为true传递到下一位，下一位也受到n的约束</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// isNum主要是处理前导零的问题。isNum表示i前面是否填了数字</span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>// 若isNum为true，则i位可以从0开始填；否则，说明i是第一位，i可以不填，或者至少填1(因为不能有前导0)</span>
</span></span><span style=display:flex><span>	f = <span style=color:#268bd2>func</span>(i, mask <span style=color:#dc322f>int</span>, isLimit, isNum <span style=color:#dc322f>bool</span>) (res <span style=color:#dc322f>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> i <span style=color:#719e07>==</span> m { <span style=color:#586e75>// base case，遍历完毕</span>
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> isNum { <span style=color:#586e75>// 且不是全部跳过不选的</span>
</span></span><span style=display:flex><span>				<span style=color:#719e07>return</span> <span style=color:#2aa198>1</span> <span style=color:#586e75>// 得到了一个合法数字</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isLimit <span style=color:#719e07>&amp;&amp;</span> isNum {
</span></span><span style=display:flex><span>			dv <span style=color:#719e07>:=</span> <span style=color:#719e07>&amp;</span>dp[i][mask]
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> <span style=color:#719e07>*</span>dv <span style=color:#719e07>&gt;=</span> <span style=color:#2aa198>0</span> {
</span></span><span style=display:flex><span>				<span style=color:#719e07>return</span> <span style=color:#719e07>*</span>dv <span style=color:#586e75>// dp匹配直接返回</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#719e07>defer</span> <span style=color:#268bd2>func</span>() { <span style=color:#719e07>*</span>dv = res }() <span style=color:#586e75>// 未匹配到，则在return之后更新dp数组</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isNum { <span style=color:#586e75>// 可以跳过当前数位</span>
</span></span><span style=display:flex><span>			res <span style=color:#719e07>+=</span> <span style=color:#268bd2>f</span>(i<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, mask, <span style=color:#cb4b16>false</span>, <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		d <span style=color:#719e07>:=</span> <span style=color:#2aa198>0</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> !isNum {
</span></span><span style=display:flex><span>			d = <span style=color:#2aa198>1</span> <span style=color:#586e75>// 如果前面没有填数字，必须从 1 开始（因为不能有前导零）</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		up <span style=color:#719e07>:=</span> <span style=color:#2aa198>9</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> isLimit {
</span></span><span style=display:flex><span>			up = <span style=color:#b58900>int</span>(s[i] <span style=color:#719e07>-</span> <span style=color:#2aa198>&#39;0&#39;</span>) <span style=color:#586e75>// 如果前面填的数字都和 n 的一样，那么这一位至多填数字 s[i]（否则就超过 n 啦）</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>for</span> ; d <span style=color:#719e07>&lt;=</span> up; d<span style=color:#719e07>++</span> { <span style=color:#586e75>// 枚举要填入的数字 d</span>
</span></span><span style=display:flex><span>			<span style=color:#719e07>if</span> mask<span style=color:#719e07>&gt;&gt;</span>d<span style=color:#719e07>&amp;</span><span style=color:#2aa198>1</span> <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> { <span style=color:#586e75>// d 不在 mask 中</span>
</span></span><span style=display:flex><span>				res <span style=color:#719e07>+=</span> <span style=color:#268bd2>f</span>(i<span style=color:#719e07>+</span><span style=color:#2aa198>1</span>, mask|<span style=color:#2aa198>1</span><span style=color:#719e07>&lt;&lt;</span>d, isLimit <span style=color:#719e07>&amp;&amp;</span> d <span style=color:#719e07>==</span> up, <span style=color:#cb4b16>true</span>) <span style=color:#586e75>// d写入mask， isLimit传递</span>
</span></span><span style=display:flex><span>			} <span style=color:#586e75>// 否则该分支的结果为0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> n <span style=color:#719e07>-</span> <span style=color:#268bd2>f</span>(<span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>, <span style=color:#cb4b16>true</span>, <span style=color:#cb4b16>false</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Mar 20, 2023</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/go>go</a> <a class=category href=https://scottlx.github.io/tags/%e6%95%b0%e4%bd%8ddp>数位dp</a> <a class=category href=https://scottlx.github.io/tags/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92>动态规划</a> <a class=category href=https://scottlx.github.io/tags/%e7%ae%97%e6%b3%95>算法</a> <a class=category href=https://scottlx.github.io/tags/%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9>状态压缩</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/raft%E9%80%89%E4%B8%BE%E6%B5%81%E7%A8%8B/ title=raft选举流程>raft选举流程</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/contiv-memif/ title="contiv memif">contiv memif</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Sidebar Header</h1><p><p>Here&rsquo;s a
<a href=https://www.google.com target=_blank rel=noopener>link to google</a></p><p>New paragraph</p><p>Another paragraph which has two spaces in the end to create a new line using markdown<br>New line but not a new paragraph</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a></li></ul><section class=odd><h1>Sidebar Links</h1><li><a href=https://scottlx.github.io/about title="About me">About me</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>