<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>redis 多节点</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/redis%E5%A4%9A%E8%8A%82%E7%82%B9/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>redis 多节点</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><a href=#同步>同步</a></li><li><a href=#命令传播>命令传播</a></li><li><a href=#psync>psync</a><ul><li><a href=#偏移量>偏移量</a></li><li><a href=#复制缓冲区>复制缓冲区</a></li><li><a href=#服务器运行id>服务器运行ID</a></li></ul></li><li><a href=#同步过程>同步过程</a><ul><li><a href=#一致性>一致性</a></li></ul></li></ul><ul><li><ul><li><a href=#连接类型>连接类型</a></li><li><a href=#节点的连接>节点的连接</a></li><li><a href=#下线状态>下线状态</a></li><li><a href=#领头选举>领头选举</a></li><li><a href=#故障转移>故障转移</a></li><li><a href=#存在的问题>存在的问题</a></li></ul></li></ul></nav><h1 id=主从复制>主从（复制）</h1><h2 id=同步>同步</h2><p>slave刚上线或断线重连时的第一次全量同步</p><p>slave的客户端主动发送sync命令，触发master的BGSAVE，BGSAVE过程中将命令存入缓冲区，BGSAVE完成后发送RDB文件，slave完成RDB载入后再发送缓冲区的指令</p><h2 id=命令传播>命令传播</h2><p>完成同步后的增量同步</p><p>master主动发送命令</p><h2 id=psync>psync</h2><p>优化后的sync，作为断线重连后的增量同步
slave发送psync命令，master返回+continue，之后发送断开期间执行的写命令</p><h3 id=偏移量>偏移量</h3><p>主节点和从节点各自维护一个偏移量，表示当前已接收数据的字节数。当从节点发现自身偏移量与主节点不一致时，主动向主节点发送psync命令</p><h3 id=复制缓冲区>复制缓冲区</h3><p>主节点进行命令传播时(增量同步),会将写命令复制一份到缓冲区。且每个写命令都绑定一个对应的偏移量。从节点发送的psync中带有偏移量，
通过该偏移量在复制缓冲区中查找偏移量之后的写命令。如果查不到，则执行完整同步(sync)</p><h3 id=服务器运行id>服务器运行ID</h3><p>从节点向主节点注册自己的分布式ID，新上线的从节点若不在注册表内，则进行完整同步(sync)，否则进行部分重同步。</p><h2 id=同步过程>同步过程</h2><p>slaveof命令设置redisServer中的masterhost和masterport字段，之后主从连接由cron定时器任务里触发</p><ul><li>anetTcpConnect建立一个新的tcp连接</li><li>ping-pong命令测试连接</li><li>auth鉴权</li><li>发送端口号，主节点刷新client信息</li><li>psyn/sync 同步</li><li>命令传播</li><li>心跳 发送REPLCONF ACK命令，其中带有从节点的偏移量，可以检测命令丢失（命令丢失后主节点和从节点的偏移量会不一样）；收到心跳的时间戳用来监测网络延迟状态，若一定数量的从服务器的lag超过一定值，表示该主从集合不健康，不允许client写入</li></ul><h3 id=一致性>一致性</h3><p>不是强一致性（cap），是最终一致性。用最终一致性换取了高吞吐量</p><ul><li>master与slave的同步存在数据不一致的时间窗口期</li><li>网络分区后哨兵模式或者集群模式的选主会产生脑裂</li></ul><h1 id=哨兵>哨兵</h1><p>多了一个哨兵节点进行主节点选举，触发从同步等工作，数据的同步还是主从模式
哨兵节点运行的是一个特殊模式的redis服务器，里面没有数据库。</p><h3 id=连接类型>连接类型</h3><p>命令连接</p><p>订阅连接</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/*实例不是 Sentinel （主服务器或者从服务器）
</span></span></span><span style=display:flex><span><span style=color:#586e75>并且以下条件的其中一个成立：
</span></span></span><span style=display:flex><span><span style=color:#586e75>    1）SENTINEL 未收到过这个服务器的 INFO 命令回复
</span></span></span><span style=display:flex><span><span style=color:#586e75>    2）距离上一次该实例回复 INFO 命令已经超过 info_period 间隔
</span></span></span><span style=display:flex><span><span style=color:#586e75>   那么向实例发送 INFO 命令
</span></span></span><span style=display:flex><span><span style=color:#586e75>*/</span>
</span></span><span style=display:flex><span>  <span style=color:#719e07>if</span> ((ri<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>&amp;</span> SRI_SENTINEL) <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> <span style=color:#719e07>&amp;&amp;</span>
</span></span><span style=display:flex><span>​    (ri<span style=color:#719e07>-&gt;</span>info_refresh <span style=color:#719e07>==</span> <span style=color:#2aa198>0</span> <span style=color:#719e07>||</span>
</span></span><span style=display:flex><span>​    (now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>info_refresh) <span style=color:#719e07>&gt;</span> info_period))
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* Send INFO to masters and slaves, not sentinels. */</span>
</span></span><span style=display:flex><span>​    retval <span style=color:#719e07>=</span> <span style=color:#268bd2>redisAsyncCommand</span>(ri<span style=color:#719e07>-&gt;</span>cc,
</span></span><span style=display:flex><span>​      sentinelInfoReplyCallback, <span style=color:#b58900>NULL</span>, <span style=color:#2aa198>&#34;INFO&#34;</span>);
</span></span><span style=display:flex><span>​    <span style=color:#719e07>if</span> (retval <span style=color:#719e07>==</span> REDIS_OK) ri<span style=color:#719e07>-&gt;</span>pending_commands<span style=color:#719e07>++</span>;
</span></span><span style=display:flex><span>  } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> ((now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>last_pong_time) <span style=color:#719e07>&gt;</span> ping_period) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* Send PING to all the three kinds of instances. */</span>
</span></span><span style=display:flex><span>​    <span style=color:#268bd2>sentinelSendPing</span>(ri);
</span></span><span style=display:flex><span>  } <span style=color:#719e07>else</span> <span style=color:#719e07>if</span> ((now <span style=color:#719e07>-</span> ri<span style=color:#719e07>-&gt;</span>last_pub_time) <span style=color:#719e07>&gt;</span> SENTINEL_PUBLISH_PERIOD) {
</span></span><span style=display:flex><span>​    <span style=color:#586e75>/* PUBLISH hello messages to all the three kinds of instances. */</span>
</span></span><span style=display:flex><span>​    <span style=color:#268bd2>sentinelSendHello</span>(ri);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><h3 id=节点的连接>节点的连接</h3><p>哨兵主定时任务开始时，以1s或10s的间隔发送INFO命令，得到主节点的回复，并处理INFO回复的信息。回复中包含该主节点的从节点ip+port。处理函数中更新主节点的实例sentinelRedisInstance，并创建从节点，进行从节点的连接，获取从节点的详细信息。</p><p>连接完成后，哨兵每隔2s向所有节点(主和从)的命令连接发送hello格式消息，消息中包含接收节点对应的主节点的信息（若接收节点是主节点，则是它自己的信息）。同时在订阅连接中接收hello的回复信息</p><p>往订阅连接发送的回复信息会备所有监视该节点的哨兵接收到，接收到后哨兵更新自己的sentinel字典和masters字典。因此监视相同的节点的sentinel之间可以互相发现，但互相发现后的sentinel之间只会创建命令连接不会创订阅连接</p><h3 id=下线状态>下线状态</h3><p>主观下线</p><p>哨兵主定时任务会向所有节点（主，从，哨兵）发送ping命令，若在主观下线时常结束后没有收到有效回复（+PONG，-LOADING，-MASTERDOWN），则主观认为该节点下线（SDOWN）</p><p>客观下线</p><p>向同样监视该节点的哨兵询问（发送 SENTINEL is-master-down-by-addr 命令并接收回复），接收到一定数量的下线判断后(主观客观都算)，则将该节点置为客观下线状态(ODOWN)，并进行故障转移操作</p><p>不同sentinel对客观下线的判断标准会不同，由初始配置决定</p><h3 id=领头选举>领头选举</h3><p>主节点客观下线后，所有监听该主节点的sentinel将进行领头选举。之后领头对该下线的master进行故障转移操作。成为领头的条件是自己被半数以上的sentinel设置成局部领头。选举开始时所有节点进行广播SENTINEL is-master-down-by-addr命令，接受到该广播命令的sentinel只对第一个命令进行回复，后续的命令直接drop（类似发起dhcp请求后对dhcp回复报文的处理）。收到回复后sentinel在本次epoch(一个选举次数计数器，记录了选举的轮次，类似etcd的election term)将自己的局部领头数加一。其实就是raft算法里的leader选举机制，类似etcd的实现，因此哨兵的个数不能是偶数（1个是不是也可以？）</p><h3 id=故障转移>故障转移</h3><ol><li><p>在已下线的主服务器的从服务器中选出一台作为新的主服务器</p><p>依据从服务器数据的新旧状态，优先级，复制偏移量以及运行ID综合选出新的主服务器，发送SLAVEOF no one 命令切主，并用INFO命令检查是否已经切主</p></li><li><p>让已下线的主服务器的从服务器改为复制这台新的主服务器</p><p>依次对所有从服务器发送SLAVEOF命令</p></li><li><p>将这台下线的主服务器作为新的主服务器的从服务器，重新上线后就成为了从服务器</p><p>因为已经下线，所以发布了命令，改为在该server的实例结构里保存设置，重新上线后发送SLAVEOF命令</p></li></ol><h3 id=存在的问题>存在的问题</h3><h4 id=主节点脑裂>主节点脑裂</h4><p>若存在网络分区，会生成两个主节点。此时若client往其中小分区的主节点写数据，当网络恢复之后，该主节点降级回从节点，会丢失所有网络分区后写入的数据。可以采用min-replica选项限制client的写入（要求写入的主节点必须有一个从节点）</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Oct 3, 2022</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/cache>cache</a> <a class=category href=https://scottlx.github.io/tags/redis>redis</a> <a class=category href=https://scottlx.github.io/tags/%e4%b8%ad%e9%97%b4%e4%bb%b6>中间件</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ title="redis 数据结构">redis 数据结构</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/redisserver/ title="redis Server">redis Server</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>