<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>dpvs 数据流分析</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek的博客</a></h1><h2>golang、云计算、SDN、NFV、软件架构</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/tools/>» 工具</option><option value=https://scottlx.github.io/archives/>» 归档</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/tools/ title=工具 target=_blank rel="noopener noreferrer">工具</a></li><li><a href=https://scottlx.github.io/archives/ title=归档 target=_blank rel="noopener noreferrer">归档</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Feb 18, 2025
- 3 minute read
- <a href=https://scottlx.github.io/posts/dpvs%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>dpvs 数据流分析</h1></header><div class=entry-content><h2 id=dpvs-ingress流程分析>dpvs ingress流程分析</h2><p>从 <em>lcore_job_recv_fwd</em> 开始，这个是dpvs收取报文的开始</p><h3 id=设备层>设备层</h3><p>dev->flag & NETIF_PORT_FLAG_FORWARD2KNI &mdash;> 则拷贝一份mbuf到kni队列中，这个由命令行和配置文件决定（做流量镜像，用于抓包）</p><h3 id=eth层>eth层</h3><p><em>netif_rcv_mbuf</em> 这里面涉及到vlan的部分不做过多解析</p><ul><li><p>不支持的协议</p><p>目前dpvs支持的协议为ipv4, ipv6, arp。 其它报文类型直接丢给内核。其他类型可以看
<a href=https://en.wikipedia.org/wiki/EtherType#cite_note-ethtypes-3 target=_blank rel=noopener>eth_types</a>。
<a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p>RTE_ARP_OP_REPLY</p><p>复制 <em>nworks-1</em> 份mbuf，发送到其它worker的arp_ring上 ( <em><strong>to_other_worker</strong></em> ), 这份报文fwd到
<a href=#arp%e5%8d%8f%e8%ae%ae>arp协议</a>.</p></li><li><p>RTE_ARP_OP_REQUEST</p><p>这份报文fwd到
<a href=#arp%e5%8d%8f%e8%ae%ae>arp协议</a>.</p></li></ul><h3 id=arp协议>arp协议</h3><ul><li><p>arp协议处理 <em>neigh_resolve_input</em></p><ul><li><p>RTE_ARP_OP_REPLY</p><p>建立邻居表，记录信息，并且把这个报文送给内核。
<a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p>RTE_ARP_OP_REQUEST</p><p>无条件返回网卡的ip以及mac地址 (<em>free arp</em>), <em>netif_xmit</em> 发送到
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></p></li><li><p>其它op_code</p><p><a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li></ul></li></ul><h3 id=ip层>ip层</h3><ul><li>ipv4协议 (ipv6数据流程上一致)<ul><li><p><em>ipv4_rcv</em></p><ul><li><p>ETH_PKT_OTHERHOST</p><p>报文的dmac不是自己，
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>ipv4 协议校验</p><p>不通过，
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>下一层协议为 IPPROTO_OSPF</p><p><a href=#dpvs_kni_ingress>to_kni</a></p></li><li><p><em>INET_HOOK_PRE_ROUTING hook</em></p><p>hook_list: <em>dp_vs_in</em> , <em>dp_vs_prerouting</em></p><p>这两个都与synproxy有关系，但是我们不会启用这个代理，不过需要注意的是syncproxy不通过时会丢包
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p><ul><li><p>dp_vs_in</p><ul><li><p>非 ETH_PKT_HOST(broadcast 或者 multicast报文)或ip报文交给 <em>ipv4_rcv_fin</em> 处理</p></li><li><p>非 udp, tcp, icmp, icmp6报文交给 <em>ipv4_rcv_fin</em> 处理</p></li><li><p>分片报文, 黑名单地址报文
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>非本core 报文，
<a href=#dpvs_redirect%e5%88%86%e6%9e%90>redirect</a>到对应core上</p></li><li><p>conn超时，
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>xmit_inbound</p><ul><li><p>接收速率限速
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>这条连接的发送函数没有定义，走 <em>ipv4_rcv_fin</em></p><p>定义的发送函数： dp_vs_xmit_nat，dp_vs_xmit_tunnel， dp_vs_xmit_dr， dp_vs_xmit_fnat， dp_vs_xmit_snat</p></li><li><p>其它的包发送到
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></p></li></ul></li><li><p>xmit_outbound</p><ul><li><p>发送速率限速
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></p></li><li><p>这条连接的发送函数没有定义，走 <em>ipv4_rcv_fin</em></p><p>定义的发送函数： dp_vs_out_xmit_nat， dp_vs_out_xmit_fnat， dp_vs_out_xmit_snat</p></li><li><p>其它的包发送到
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></p></li></ul></li></ul></li></ul></li></ul></li><li><p><em>ipv4_rcv_fin</em> 和内核处理流程基本一致</p><ul><li>找不到路由，
<a href=#dpvs_kni_ingress>to_kni</a></li><li>localin， <em>ipv4_local_in</em></li><li>RTF_KNI路由(下发时配置)，
<a href=#dpvs_kni_ingress>to_kni</a></li><li>RTF_FORWARD<ul><li>非ETH_PKT_HOST, multicast or broadcast
<a href=#dpvs_kni_ingress>to_kni</a></li><li>ETH_PKT_HOST，<em>ipv4_forward</em></li></ul></li><li>其它类型的路由(RTF_OUTWALL)丢给内核，
<a href=#dpvs_kni_ingress>to_kni</a></li></ul></li><li><p><em>ipv4_local_in</em> 是发给自己的报文</p><ul><li>ip报文reassemble， 失败就
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></li><li>INET_HOOK_LOCAL_IN hook_list: none</li><li><em>ipv4_local_in_fin</em> 交给协议层处理<ul><li><p>当前支持的协议</p><ul><li><p><a href=https://blog.csdn.net/sinat_20184565/article/details/83280247 target=_blank rel=noopener>IPPROTO_GRE</a> <em>gre_rcv</em></p><p>gre协议的处理，处理通过之后，复用
<a href=#eth%e5%b1%82>eth层</a>处理</p></li><li><p>IPPROTO_IPIP <em>ipip_rcv</em></p><p>ipip协议的处理，处理通过之后，复用
<a href=#eth%e5%b1%82>eth层</a>处理</p></li><li><p>IPPROTO_ICMP</p><p>icmp协议的处理，除了icmp_echo,别的都交给
<a href=#dpvs_kni_ingress>to_kni</a>。</p><p>icmp最终 <em>ipv4_local_out</em></p></li></ul></li><li><p>其它协议udp，tcp等
<a href=#dpvs_kni_ingress>to_kni</a></p></li></ul></li></ul></li><li><p><em>ipv4_forward</em> 走路由</p><ul><li>ttl check, fail,
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></li><li>mtu check, fail,
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></li><li>ipv4_forward_switch check, fail,
<a href=#%e6%8a%a5%e6%96%87drop>drop</a></li><li>INET_HOOK_FORWARD hook_list: none</li><li>to <em>ipv4_output</em></li></ul></li><li><p><em>ipv4_local_out</em></p><ul><li>INET_HOOK_LOCAL_OUT hook_list: none</li><li>to <em>ipv4_output</em></li></ul></li><li><p><em>ipv4_output</em></p><ul><li>INET_HOOK_POST_ROUTING hook_list: none</li><li>to <em>ipv4_output_fin</em></li></ul></li><li><p><em>ipv4_output_fin</em></p><ul><li>ip 报文分片，失败会<strong>drop</strong>*</li><li>to <em>ipv4_output_fin2</em></li></ul></li><li><p><em>ipv4_output_fin2</em></p><p>查找路由，mbuf发送到
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></p></li></ul></li></ul><h2 id=dpvs_egress报文分析>dpvs_egress报文分析</h2><p>也就是
<a href=#dpvs_kni_egress>core_tx_queue</a> 的数据流向，从<em>netif_tx_burst</em>开始分析。这里mbuf中的内容都已经填充完成，调用了 <em>rte_eth_tx_burst</em>，
<a href=#%e7%94%a8%e6%88%b7%e6%80%81%e7%bd%91%e5%8d%a1%e9%a9%b1%e5%8a%a8>发送至网卡</a>。</p><h2 id=dpvs_redirect分析>dpvs_redirect分析</h2><p><em>dp_vs_redirect_ring_proc</em>, 从 dp_vs_redirect_ring[cid][peer_id]中获取数据报文，导向
<a href=#dpvs-ingress%e6%b5%81%e7%a8%8b%e5%88%86%e6%9e%90>dpvs_ingress</a></p><h2 id=dpvs_kni>dpvs_kni</h2><p>入口函数: <em>kni_lcore_loop</em></p><ul><li><em>kni_ingress_flow_process</em>: kni接管的队列的所有包都往
<a href=#kernel_kni_ingress>kernel_kni_in</a>上送 (非master core)</li><li><em>lcore_job_xmit</em>: 发送kni_core上的网络包(非master core),
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></li></ul><p>dpvs 内部kni队列的处理如下两个流程。</p><h3 id=dpvs_kni_ingress>dpvs_kni_ingress</h3><p><em>kni_ingress_process</em>:</p><ul><li><em>rte_ring_dequeue_burst(dev->kni.rx_ring)</em>: 收取所有dev上的kni报文接收队列的报文</li><li><em>rte_kni_tx_burst</em>: 发送到
<a href=#kernel_kni_ingress>kernel_kni_in</a></li></ul><h3 id=dpvs_kni_egress>dpvs_kni_egress</h3><p><em>kni_egress_process</em>:</p><ul><li>rte_kni_handle_request: 分配mbuf给kni.resp_q</li><li>rte_kni_rx_burst(dev->kni.kni): 接收kni设备中的报文,
<a href=#kernel_kni_egress>kernel_kni_out</a></li><li>netif_xmit: 发送到对应worker的发送队列,
<a href=#dpvs_egress%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90>core_tx_queue</a></li></ul><h1 id=kni设备>kni设备</h1><p><img src=https://pic3.zhimg.com/v2-e16e6eafac76d995f5b70b854c2d3f42_r.jpg alt=kni_module></p><h2 id=kni_init>kni_init</h2><ul><li><em>rte_kni_alloc</em> 用户态kni设备申请</li></ul><h2 id=kernellinuxkni_miscc>kernel/linux/kni_misc.c</h2><p>用于管理kni设备的。 简单的来说，这个文件创建了一个kni_misc设备，提供了ioctl方法创建相应的队列，可以简单的来看下ioctl的实现。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>kni_ioctl:
</span></span><span style=display:flex><span>    <span style=color:#719e07>case</span> <span style=color:#268bd2>_IOC_NR</span>(RTE_KNI_IOCTL_CREATE)<span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>        kni_ioctl_create:
</span></span><span style=display:flex><span>            <span style=color:#268bd2>param_check</span>() <span style=color:#586e75>// 参数检查
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>            <span style=color:#268bd2>alloc_netdev</span>() <span style=color:#586e75>// 申请一个net_dev
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                params: priv<span style=color:#719e07>=</span><span style=color:#719e07>struct</span> kni_dev, name<span style=color:#719e07>=</span>kni.name, init_func <span style=color:#719e07>=</span> kni_net_init <span style=color:#586e75>// 由kni_net.c 提供
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                addr_translation <span style=color:#586e75>//地址转换，将物理地址转换为内核虚拟地址
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                register_netdev
</span></span><span style=display:flex><span>                kni_run_thread
</span></span><span style=display:flex><span>                    <span style=color:#586e75>//根据 multiple_kthread_on 创建相应的kernel线程，并绑核
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                    <span style=color:#586e75>// 对于multiple mode，每一个kni_net_dev都创建一个线程
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                    <span style=color:#586e75>// 对于single mode，只有第一次会创建线程，后面都只是把这个kni_net_dev加入队列中
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                    kni_thread_multiple: <span style=color:#586e75>// 就收发自己的kni_net_dev
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                    kni_thread_single: <span style=color:#586e75>// 收发这个kni所管理的全部net_dev
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                        <span style=color:#268bd2>kni_net_rx</span>(kni_dev) <span style=color:#586e75>// kni_net.c 提供
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                        <span style=color:#268bd2>kni_net_poll_resp</span>(kni_dev)
</span></span></code></pre></div><h2 id=kernellinuxkni_netc>kernel/linux/kni_net.c</h2><p>实际的kni_net设备,实现了报文的收发</p><p><img src=https://pic4.zhimg.com/v2-0b2066b331faa8907efad69e84e754b3_1440w.jpg alt=kni_packets></p><h3 id=kni_net_init>kni_net_init</h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>kni_net_init
</span></span><span style=display:flex><span>    dev<span style=color:#719e07>-&gt;</span>netdev_ops      <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>kni_net_netdev_ops; <span style=color:#586e75>// 关键的open, tx，close 函数都在这儿
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        kni_net_open
</span></span><span style=display:flex><span>        kni_net_release
</span></span><span style=display:flex><span>        kni_net_tx
</span></span><span style=display:flex><span>	dev<span style=color:#719e07>-&gt;</span>header_ops      <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>kni_net_header_ops; <span style=color:#586e75>// 填充以太网头eth用的
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	dev<span style=color:#719e07>-&gt;</span>ethtool_ops     <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>kni_net_ethtool_ops; <span style=color:#586e75>//获得驱动信息
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	dev<span style=color:#719e07>-&gt;</span>watchdog_timeo <span style=color:#719e07>=</span> WD_TIMEOUT;
</span></span></code></pre></div><h3 id=kernel_kni_ingress>kernel_kni_ingress</h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>kni_net_rx
</span></span><span style=display:flex><span>    kni_net_rx_normal <span style=color:#586e75>// normal mode, 在lo，lo_skb模式下会有变化 将dpdk发送来的数据发送到内核中
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#268bd2>kni_fifo_get</span>(kni<span style=color:#719e07>-&gt;</span>rx_q, kni<span style=color:#719e07>-&gt;</span>pa, num_rx); <span style=color:#586e75>// 从rx_q从接收数据
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#268bd2>get_kva</span>(kni, kni<span style=color:#719e07>-&gt;</span>pa[i]); <span style=color:#586e75>// 将mbuf的phy_addr转换为内核的virtaddr
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#268bd2>get_data_kva</span>(kni, kva); <span style=color:#586e75>//将mbuf data_addr的phy_addr转换为kva
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#586e75>// mbuf-&gt;skb 处理
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#268bd2>netif_rx</span>(skb) <span style=color:#586e75>//将处理后的skb发送给内核
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#268bd2>kni_fifo_put</span>(kni<span style=color:#719e07>-&gt;</span>free_q, kni<span style=color:#719e07>-&gt;</span>va, num_rx); <span style=color:#586e75>// 把mbuf送到free_q，让dpdk释放它
</span></span></span></code></pre></div><h3 id=kernel_kni_egress>kernel_kni_egress</h3><p>内核发送给kni_thread， 对于内核来说最终调用kni_net_tx函数</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>kni_net_tx
</span></span><span style=display:flex><span>    <span style=color:#268bd2>kni_fifo_get</span>(kni<span style=color:#719e07>-&gt;</span>alloc_q, <span style=color:#719e07>&amp;</span>pkt_pa, <span style=color:#2aa198>1</span>); <span style=color:#586e75>//从alloc_q 获取一个mbuf
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	pkt_kva <span style=color:#719e07>=</span> <span style=color:#268bd2>get_kva</span>(kni, pkt_pa); <span style=color:#586e75>// mbuf转换为内核地址
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	data_kva <span style=color:#719e07>=</span> <span style=color:#268bd2>get_data_kva</span>(kni, pkt_kva); <span style=color:#586e75>// mbuf的数据转换为内核地址
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	pkt_va <span style=color:#719e07>=</span> <span style=color:#268bd2>pa2va</span>(pkt_pa, pkt_kva); <span style=color:#586e75>// 转换为虚拟地址？ 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#268bd2>kni_fifo_put</span>(kni<span style=color:#719e07>-&gt;</span>tx_q, <span style=color:#719e07>&amp;</span>pkt_va, <span style=color:#2aa198>1</span>); <span style=color:#586e75>// 放入tx_q
</span></span></span></code></pre></div><h1 id=用户态网卡驱动>用户态网卡驱动</h1><h2 id=igb_uio-mnlx-cx5等物理网卡>igb_uio， mnlx cx5等物理网卡</h2><ul><li><em>rte_eth_tx_burst</em></li><li><em>rte_eth_rx_burst</em></li></ul><h2 id=kni>kni</h2><ul><li>rte_kni_tx_burst(struct rte_kni *kni, struct rte_mbuf **mbufs, unsigned int num)</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>num <span style=color:#719e07>=</span> <span style=color:#268bd2>RTE_MIN</span>(<span style=color:#268bd2>kni_fifo_free_count</span>(kni<span style=color:#719e07>-&gt;</span>rx_q), num);
</span></span><span style=display:flex><span>phy_mbufs <span style=color:#719e07>=</span> <span style=color:#268bd2>va2pa_all</span>(mbufs);
</span></span><span style=display:flex><span><span style=color:#268bd2>kni_fifo_put</span>(kni<span style=color:#719e07>-&gt;</span>rx_q, phy_mbufs, num); <span style=color:#586e75>// 发送到rx_q中
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>ret <span style=color:#719e07>=</span> <span style=color:#268bd2>kni_fifo_get</span>(kni<span style=color:#719e07>-&gt;</span>free_q, (<span style=color:#dc322f>void</span> <span style=color:#719e07>**</span>)pkts, MAX_MBUF_BURST_NUM); <span style=color:#586e75>// 从free_q中取出mbuf后释放
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>rte_pktmbuf_free</span>();
</span></span></code></pre></div><ul><li>rte_kni_rx_burst(struct rte_kni *kni, struct rte_mbuf **mbufs, unsigned int num)</li></ul><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> ret <span style=color:#719e07>=</span> <span style=color:#268bd2>kni_fifo_get</span>(kni<span style=color:#719e07>-&gt;</span>tx_q, (<span style=color:#dc322f>void</span> <span style=color:#719e07>**</span>)mbufs, num);
</span></span><span style=display:flex><span><span style=color:#268bd2>kni_allocate_mbufs</span>(); <span style=color:#586e75>// 在alloc_q里面放入mbuf，防止kernel_kni_tx thread取不到mbuf
</span></span></span></code></pre></div></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Feb 18, 2025</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/dpdk>dpdk</a> <a class=category href=https://scottlx.github.io/tags/dpvs>dpvs</a> <a class=category href=https://scottlx.github.io/tags/%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c>高性能网络</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/dpdk-rcu/ title="dpdk rcu lib">dpdk rcu lib</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/dpvs-session%E5%90%8C%E6%AD%A5/ title="dpvs session 同步">dpvs session 同步</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Sidebar Header</h1><p><p>Here&rsquo;s a
<a href=https://www.google.com target=_blank rel=noopener>link to google</a></p><p>New paragraph</p><p>Another paragraph which has two spaces in the end to create a new line using markdown<br>New line but not a new paragraph</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a></li></ul><section class=odd><h1>Sidebar Links</h1><li><a href=https://scottlx.github.io/about title="About me">About me</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>