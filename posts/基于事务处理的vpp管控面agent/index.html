<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>基于事务处理的vpp管控面agent</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Oct 3, 2022
- 1 minute read
- <a href=https://scottlx.github.io/posts/%E5%9F%BA%E4%BA%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84vpp%E7%AE%A1%E6%8E%A7%E9%9D%A2agent/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>基于事务处理的vpp管控面agent</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><ul><li><a href=#问题背景>问题背景</a></li><li><a href=#事务处理>事务处理</a></li><li><a href=#事务处理视角看待vpp管控面>事务处理视角看待vpp管控面</a></li><li><a href=#agent设计思想>agent设计思想</a></li><li><a href=#事务流程创建bridge-domain为例>事务流程（创建bridge domain为例）</a></li><li><a href=#总结>总结</a></li><li><a href=#参考文档>参考文档</a></li></ul></li></ul></nav><h3 id=问题背景>问题背景</h3><p>vpp作为vrouter，类似物理交换机，各配置项依赖关系复杂。以下为vpp配置abf策略路由的例子：</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>typedef</span> abf_policy
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u32 policy_id;
</span></span><span style=display:flex><span>  u32 acl_index;  <span style=color:#586e75>//依赖acl
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  u8 n_paths;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_fib_path_t</span> paths[n_paths];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>autoreply define abf_policy_add_del
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  option status<span style=color:#719e07>=</span><span style=color:#2aa198>&#34;in_progress&#34;</span>;
</span></span><span style=display:flex><span>  u32 client_index;
</span></span><span style=display:flex><span>  u32 context;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>bool</span> is_add;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_abf_policy_t</span> policy;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>typedef</span> abf_itf_attach
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  u32 policy_id;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>vl_api_interface_index_t</span> sw_if_index; <span style=color:#586e75>//依赖interface，interface又会依赖其他资源
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  u32 priority;
</span></span><span style=display:flex><span>  <span style=color:#dc322f>bool</span> is_ipv6;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>可以看到，策略路由首先依赖acl规则，之后将abf绑定至接口时需要依赖对应interface的index，且创建interface又需要依赖其他资源（绑定vrf等）。</p><p>除此之外，vpp配置写入存在中间状态与崩溃的问题，且无法避免。“崩溃”类似数据库写入的概念。数据必须要成功写入磁盘、磁带等持久化存储器后才能拥有持久性，只存储在，内存中的数据，一旦遇到应用程序忽然崩溃，或者数据库、操作系统一侧的崩溃，甚至是机器突然断电宕机等情况就会丢失，这些意外情况都统称为“崩溃”。</p><p>因此，为了解决vpp（物理交换机也适用）各配置项的依赖关系，以及保证原子性和持久性，实现崩溃恢复，需要在管控面agent侧处理好上述问题。</p><h3 id=事务处理>事务处理</h3><p>本人对分布式事务领域涉及不深，以下摘自于</p><p>本地事务（也可称为局部事务），是单个服务使用单个数据源场景，也就是最基本的本地数据落盘的事务。本地事务要求底层数据源需要支持事务的开启、终止、提交、回滚、嵌套等。在数据库领域（ARIES理论，基于语义的恢复与隔离），感兴趣的可以研究下commiting logging机制（OceanBase）和shadow paging</p><p>全局事务，是单个服务多个数据源场景。主要目的是为了解决事务一致性问题，并做到统一提交，统一回滚的功能。例如我有一个全局事务需要在A表中写入记录a（本地事务A），再在B表中写入记录b（本地事务B），A表和B表分别在两台物理机的磁盘上。在数据存储领域由X/Open XA对此发布了一个事务处理架构，且当前很多分布式事务处理框架都是基于此来设计的。主要核心如下：</p><ul><li>全局事务管理器（Transaction Manager，TM）：协调全局事务</li><li>局部资源管理器（Resource Manaeger，RM）：驱动本地事务</li><li>模型：XA，TCC，SAGA，AT 。。。</li></ul><p>感兴趣的可以研究下阿里的seata。</p><h3 id=事务处理视角看待vpp管控面>事务处理视角看待vpp管控面</h3><h4 id=本地事务>本地事务</h4><ul><li>vpp的配置是内存上的配置，不需要落盘。</li><li>vpp的每个资源的api可视为一个数据源</li><li>数据源没有实现事务的开启、终止、提交、回滚、嵌套、设置隔离级别等能力，只提供了下发，删除，读取接口</li><li>上述数据源未提供的能力需要agent来补齐</li></ul><h4 id=全局事务>全局事务</h4><ul><li>agent暴露给上层的接口可视为全局事务</li><li>有些全局事务只涉及单个数据源，有些全局事务涉及多个数据源</li><li>agent内部需要实现TM，将全局事务转为有序的本地事务列表</li><li>agent内部需要实现RM，调用vpp api，驱动本地事务的执行</li></ul><p>举例：</p><p>全局事务：创建策略路由</p><p>本地事务：创建acl &ndash;>创建abf &ndash;> 创建接口 &ndash;> 绑定接口IP &ndash;> 绑定abf至接口</p><p>那么问题来了：如何处理单个数据源（本地事务）的回滚？如何实现TM的功能（全局事务到本地事务的转换）？</p><h3 id=agent设计思想>agent设计思想</h3><p><img src=/img/vpp-agent/kvscheduler.svg alt=image-kvscheduler></p><h4 id=rm的实现>RM的实现</h4><p><strong>配置描述符（descriptors）</strong></p><ul><li>单条vpp配置（数据源）定义配置描述符</li><li>配置描述符中定义了数据源的基本操作CRUD，以及与其他配置描述符的关系（依赖depend，派生derive）</li><li>派生机制：将一个本地事务分割成多个本地事务，分割后的本地事务有自己的CRUD，依赖，派生</li><li>全局事务：”根节点”</li><li>本地事务：”其他节点”</li></ul><h4 id=tm的实现>TM的实现</h4><p><strong>调度器 （KVscheduler）</strong></p><ul><li>充当TM的角色</li><li>根据descriptors定义的关系（依赖，派生）创建关系图，编排配置的下发顺序</li><li>按照saga事务模型处理事务一致性问题（单条本地事务异常，涉及到的数据源全部回退）</li></ul><p>事实上agent内的本地事务与全局事务并没有像数据库领域那样明显的区分。以上均为个人便于理解加以区分，实际代码内部并没有上述的区分。一个事务可以同时有全局事务和本地事务的属性，取决于是否存在衍生。全局事务内部也有与vpp交互的本地事务</p><p><img src=/img/vpp-agent/image-20221003140631624.png alt=image-20221003140631624></p><h3 id=事务流程创建bridge-domain为例>事务流程（创建bridge domain为例）</h3><p><img src="/img/vpp-agent/add_bd_before_interface.svg?sanitize=true" alt=image-txn></p><h4 id=初始化阶段>初始化阶段</h4><ol><li>配置描述符（descriptor, RM）向调度器（Schedluer, TM）注册本地事务逻辑</li><li>Descriptors在定义了对应资源CRUD的回调函数，</li><li>回调函数内部使用unix socket与vpp通信</li></ol><h4 id=全量同步tx0南向同步阶段>全量同步（TX0，南向同步阶段）</h4><ol><li>编排器（Orchestrator）作为全局事务来源，北向收集etcd，http请求，grpc请求等接口中的全局事务，下发至调度器</li><li>启动阶段编排器默认下发全量同步事务0（假设此时ETCD中只有一个key）</li><li>retrieve调用vpp提供各数据源的dump接口，同步上一次本地事务的执行状态至内存</li></ol><p>全局事务类型</p><ul><li><strong>北向同步</strong>：只同步北向所有全局事务至缓存</li><li><strong>南向同步</strong>：只同步南向所有数据源至缓存</li><li><strong>全量同步</strong>：北向同步 + 南向同步</li><li><strong>增量同步</strong>：同步北向单个全局事务至缓存 + 同步缓存中单个全局事务涉及到的数据源到vpp</li></ul><h4 id=全量同步-tx0北向同步阶段>全量同步（ TX0，北向同步阶段）</h4><ol><li>扫描所有已注册的描述符，找到全局事务涉及的本地事务的描述符</li><li>依次调用配置描述符的依赖，派生，校验，创建等回调函数</li><li>全局事务涉及的数据源，根据描述符的派生机制，按照DAG的形式，<strong>动态生成</strong> （首先只有BD Descriptor本地事务，之后派生出BD-Interface本地事务）</li><li>再次扫描所有已注册的描述符，找到上一步衍生出的本地事务对应的描述符</li><li>依次调用配置描述符的依赖，派生，校验，创建等回调函数</li><li>由于该描述符存在依赖，且内存中不存在此依赖，本次全局事务结束 (依赖不满足不代表全局事务执行失败，本地事务进入挂起状态（在后续全局事务中完成），处理下一个全局事务)</li></ol><h4 id=增量同步-tx1>增量同步（ TX1）</h4><ol><li>北向数据源更新数据（修改ETCD，调用HTTP，RPC接口），下发增量同步全局事务（TX1）</li><li>找到指定配置描述符，依次调用配置描述符的依赖，派生，校验，创建等回调函数</li><li>创建成功后，修改描述符标志位，使得满足上一次pending本地事务的依赖，触发pending本地事务的运行</li></ol><h4 id=异常情况-tx1>异常情况（ TX1）</h4><ul><li><p>当本地事务的描述符CRUD操作发生异常（VPP报错），本次全局事务视为失败</p></li><li><p>besteffort策略（默认策略）</p><ul><li><p>调度器复制本次失败的本地事务，新建retry全局事务，进行重新尝试</p><ul><li><p>由于上一次vpp api调用失败，无法预测vpp当前的配置，首先retreive失败的本地事务（vpp dump api）</p></li><li><p>使用retreive得到的配置刷新内存，再次执行失败的本地事务</p><ul><li><p>retreive的数据与事务数据一致：事务无需执行直接成功（上次失败原因：已经下发成功了但没收到回复）</p></li><li><p>retreive的数据与事务数据不一致：执行CRUD覆盖vpp的脏数据（上次失败原因：vpp内部异常）</p></li><li><p>retreive不到数据：执行CRUD下发配置（失败原因：IO或网络原因请求未到达vpp）</p></li></ul></li></ul></li></ul></li><li><p>revert策略</p><ul><li>调度器创建回退全局事务，进行回退<ul><li>由于上一次vpp api调用失败，无法预测vpp当前的配置，首先retreive失败的本地事务</li><li>使用retreive得到的配置刷新内存，按照derive的顺序自底向上进行回退</li></ul></li></ul></li></ul><h3 id=总结>总结</h3><ul><li>vpp agent事务处理方式符合X/Open XA的分布式事务处理规范</li><li>管控面采用vpp agent能极大降低开发者的心智负担</li><li>其中事务处理的的思想也适用于其他路由器的sdn代码开发</li></ul><h3 id=参考文档>参考文档</h3><p><a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>ligato</a>
<a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>/</a>
<a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>vpp</a>
<a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>-agent: ⚡️ Control plane management agent for</a>
<a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>FD.io&rsquo;s</a>
<a href=https://github.com/ligato/vpp-agent target=_blank rel=noopener>VPP (github.com)</a></p><p><a href=https://docs.ligato.io/en/latest/developer-guide/control-flows/ target=_blank rel=noopener>Control Flows -</a>
<a href=https://docs.ligato.io/en/latest/developer-guide/control-flows/ target=_blank rel=noopener>Ligato</a>
<a href=https://docs.ligato.io/en/latest/developer-guide/control-flows/ target=_blank rel=noopener>Docs</a></p><p><a href=https://seata.io/zh-cn/docs/overview/what-is-seata.html target=_blank rel=noopener>Seata</a></p><p><a href=http://icyfenix.cn/ target=_blank rel=noopener>凤凰架构：构筑可靠的大型分布式系统</a></p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Oct 3, 2022</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/vpp>vpp</a> <a class=category href=https://scottlx.github.io/tags/vpp-agent>vpp-agent</a> <a class=category href=https://scottlx.github.io/tags/sdn>sdn</a> <a class=category href=https://scottlx.github.io/tags/nfv>nfv</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86srv6/ title=初识srv6>初识srv6</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/%E5%88%9D%E8%AF%86ebpf/ title=初识ebpf>初识ebpf</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>