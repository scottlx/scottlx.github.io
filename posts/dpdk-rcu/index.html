<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>dpdk rcu lib</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.144.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek的博客</a></h1><h2>golang、云计算、SDN、NFV、软件架构</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/tools/>» 工具</option><option value=https://scottlx.github.io/archives/>» 归档</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/tools/ title=工具 target=_blank rel="noopener noreferrer">工具</a></li><li><a href=https://scottlx.github.io/archives/ title=归档 target=_blank rel="noopener noreferrer">归档</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Dec 8, 2023
- 1 minute read
- <a href=https://scottlx.github.io/posts/dpdk-rcu/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>dpdk rcu lib</h1></header><div class=entry-content><p>linux的RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改。RCU适用于需要频繁的读取数据，而相应修改数据并不多的情景。</p><p>dpdk中由于writer和reader同时访问一段内存，删除元素的时候需要确保</p><ol><li>删除时不会将内存put回allocator，而是删掉这段内存的引用。这样确保了新的访问者不会拿到这个元素的引用，而老的访问者不会在访问过程中core掉</li><li>只有在元素没有任何引用计数时，才释放掉该元素的内存</li></ol><p>静默期是指线程没有持有共享内存的引用的时期，也就是下图绿色的时期</p><p><img src=https://doc.dpdk.org/guides/_images/rcu_general_info.svg alt=rcu></p><p>上图中，有三个read thread，T1， T2，T3。两条黑色竖线分别代表writer执行delete和free的时刻。</p><p>执行delete时，T1和T2还拿着entry1和entry2的reference，此时writer还不能free entry1或entry2的内存，只能删除元素的引用.</p><p>writer<em><strong>必须等到执行delete时，当时引用该元素的的线程，都完成了一个静默期之后</strong></em>，才可以free这个内存。</p><p>writer不需要等T3进入静默期，因为执行delete时，T3还在静默期。</p><p>如何实现RCU机制</p><ol><li>writer需要一直轮询reader的状态，看是否进入静默期。这样会导致一直循环轮询，造成额外的cpu消耗。由于需要等reader的静默期结束，reader的静默期越长，reader的数量越多，writer cpu的消耗会越大，因此我们需要短的grace period。但是如果将reader的critical section减小，虽然writer的轮询变快了，但是reader的报告次数增加，reader的cpu消耗会增加，因此我们需要长的critical section。这两者之间看似矛盾。</li><li>长的critical section：dpdk的lcore一般都是一个while循环。循环的开始和结束必定是静默期。循环的过程中肯定是在访问各种各样的共享内存。因此critical section的粒度可以不要很细，不要每次访问的时候退出静默期，不访问的时候进入静默期，而是将整个循环认为是critical section，只有在循环的开始退出静默期，循环的结束进入静默期。</li><li>短的grace period：如果是pipeline模型，并不是所有worker都会使用相同的数据结构。话句话说，同一个元素，只会被部分的worker所引用和读取。因此writer不需要等到所有worker的critical section结束，而是使用该元素的worker结束critical section。这样将grace period粒度变小之后，缩短了writer整体的grace period。这种粒度的控制是通过 qsbr 实现的</li></ol><h2 id=如何使用rcu库>如何使用rcu库</h2><p>dpdk-stable-20.11.1/app/test/test_rcu_qsbr.c test_rcu_qsbr_sw_sv_3qs</p><p>先创建出struct rte_rcu_qsbr</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    sz <span style=color:#719e07>=</span> <span style=color:#268bd2>rte_rcu_qsbr_get_memsize</span>(RTE_MAX_LCORE);
</span></span><span style=display:flex><span>    rv <span style=color:#719e07>=</span> (<span style=color:#719e07>struct</span> rte_rcu_qsbr <span style=color:#719e07>*</span>)<span style=color:#268bd2>rte_zmalloc</span>(<span style=color:#b58900>NULL</span>, sz, RTE_CACHE_LINE_SIZE);
</span></span></code></pre></div><p>再初始化QS variable</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#268bd2>rte_rcu_qsbr_init</span>(rv, RTE_MAX_LCORE);
</span></span></code></pre></div><p>Reader注册自己的线程号，并上线（将自己加到writer的轮询队列里面）
online时会原子读qsbr里的token，并设置到v->qsbr_cnt[thread_id].cnt中</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>(<span style=color:#dc322f>void</span>)<span style=color:#268bd2>rte_rcu_qsbr_thread_register</span>(rv, lcore_id);
</span></span><span style=display:flex><span><span style=color:#268bd2>rte_rcu_qsbr_thread_online</span>(rv, lcore_id);
</span></span></code></pre></div><p>每次读取共享数据后，更新自己的静默状态（rte_rcu_qsbr_quiescent）</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#719e07>do</span> {
</span></span><span style=display:flex><span>        <span style=color:#719e07>for</span> (i <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; i <span style=color:#719e07>&lt;</span> num_keys; i <span style=color:#719e07>+=</span> j) {
</span></span><span style=display:flex><span>            <span style=color:#719e07>for</span> (j <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>; j <span style=color:#719e07>&lt;</span> QSBR_REPORTING_INTERVAL; j<span style=color:#719e07>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#268bd2>rte_hash_lookup</span>(tbl_rwc_test_param.h,
</span></span><span style=display:flex><span>                        keys <span style=color:#719e07>+</span> i <span style=color:#719e07>+</span> j);
</span></span><span style=display:flex><span>            <span style=color:#586e75>/* Update quiescent state counter */</span>
</span></span><span style=display:flex><span>            <span style=color:#268bd2>rte_rcu_qsbr_quiescent</span>(rv, lcore_id);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#719e07>while</span> (<span style=color:#719e07>!</span>writer_done);
</span></span></code></pre></div><p>rte_rcu_qsbr_quiescent 是将qsbr->token更新到自己thread的token里去v->qsbr_cnt[thread_id].cnt</p><p>如果reader线程，需要执行一个阻塞的函数，那么他就无法更新自己的静默状态了，这样会导致writer那边拿不到状态。此时需要先执行rte_rcu_qsbr_thread_offline()，将自己从writer的轮询队列中退出来，执行完阻塞函数后再online加回去。</p><p>writer在有数据更新时，调用rte_rcu_qsbr_start()触发reader的状态上报。支持reader往多个writer上报状态</p><p>rte_rcu_qsbr_start()其实是将qsbr->token自增1，也就是每次更新一个版本号。</p><p>rte_rcu_qsbr_check()用来检测是否所有reader进入了静默期，如果返回ok，则writer可以释放内存</p><p>rte_rcu_qsbr_check()其实是判断thread bitmap中所有reader的token是否大于传入的token版本号。如果不是的话就yield，直到满足条件后退出，并更新v->acked_token。下一次可以先直接拿v->acked_token进行判断，满足就退出，不用每次都遍历所有reader，类似fast path。</p><p>rte_rcu_qsbr_start()和rte_rcu_qsbr_check()是解耦开来了，也就是说writer可以在两个函数之间做自己的逻辑。比如start自增token之后，在新的内存里写新的数据，check阻塞，等所有reader过了静默期更新完自己的token之后，将reference指向新的数据，然后释放老数据的内存。</p><p><strong>writer删除的过程（单个资源）</strong></p><ol><li>启动grace period，也就是执行delete动作（例如hash表删除key，但不删除value指针指向的内存），调用rte_rcu_qsbr_start()，并记录token</li><li>做其他逻辑</li><li>rte_rcu_qsbr_check(token)阻塞，依次检查资源的reader的状态，过了grace period则开始free，释放内存</li></ol><p><strong>writer删除的过程（多个资源）</strong></p><ol><li>rte_rcu_qsbr_dq_create创建qsbr的fifo，这边传入释放函数的函数指针free_fn</li><li>启动grace period，批量执行delete动作</li><li>将被delete的资源存到自己的fifo里面（defer queue，一次释放很多qsbr）</li><li>做其他逻辑</li><li>调用rte_rcu_qsbr_dq_reclaim批量释放资源，里面会循环非阻塞调用rte_rcu_qsbr_check，根据结果调用释放函数free_fn（这边和rte_ring耦合了，只能释放rte_ring里分配的内存）</li></ol></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Dec 8, 2023</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/dpdk>dpdk</a> <a class=category href=https://scottlx.github.io/tags/rcu>rcu</a> <a class=category href=https://scottlx.github.io/tags/%e9%ab%98%e6%80%a7%e8%83%bd%e7%bd%91%e7%bb%9c>高性能网络</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/contiv-memif/ title="contiv memif">contiv memif</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/dpvs%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90/ title="dpvs 数据流分析">dpvs 数据流分析</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Sidebar Header</h1><p><p>Here&rsquo;s a
<a href=https://www.google.com target=_blank rel=noopener>link to google</a></p><p>New paragraph</p><p>Another paragraph which has two spaces in the end to create a new line using markdown<br>New line but not a new paragraph</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a></li></ul><section class=odd><h1>Sidebar Links</h1><li><a href=https://scottlx.github.io/about title="About me">About me</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>