<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>cilium datapath</title><link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.119.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» Blog</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=Blog>Blog</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Mar 3, 2025
- 5 minute read
- <a href=https://scottlx.github.io/posts/cilium-datapath/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>cilium datapath</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><ul><li><a href=#hook点>hook点</a></li><li><a href=#网络设备>网络设备</a></li><li><a href=#同节点pod2pod>同节点pod2pod</a></li><li><a href=#跨节点pod2pod>跨节点pod2pod</a></li><li><a href=#node2pod>node2pod</a></li><li><a href=#lb-service>lb service</a></li><li><a href=#pod2service>pod2service</a></li><li><a href=#node2service>node2service</a></li><li><a href=#pod2external>pod2external</a></li><li><a href=#参考资料>参考资料</a></li></ul></li></ul></nav><h3 id=hook点>hook点</h3><p>大部分是挂载位置是tc，tc是网络协议栈初始处理挂载点</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// linux source code: dev.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>__netif_receive_skb_core
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>list_for_each_entry_rcu</span>(ptype, <span style=color:#719e07>&amp;</span>ptype_all, list) {...} <span style=color:#586e75>// packet capture
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> do_xdp_generic <span style=color:#586e75>// handle generic xdp
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> sch_handle_ingress <span style=color:#586e75>// tc ingress
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>|</span> tcf_classify
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> __tcf_classify <span style=color:#586e75>// ebpf program is working here
</span></span></span></code></pre></div><p>如果没有下发policy，xdp就不会挂载各类filter程序</p><p><img src=https://rexrock.github.io/post-images/1614297388691.png alt="cilium datapath"></p><h3 id=网络设备>网络设备</h3><p>cillium的网络方案不像常规的网桥模式（ovs，linux bridge），datapath不是一个完整的run to completion，而是分散在各个虚拟接口上，类似pipeline模式</p><p>cillium_host: 集群内所有podCIDR的网关，地址对容器可见</p><p>cilium_net: cilium_host的veth对，ipvlan模式才会用到？</p><p>clilium_vxlan: 用来提供Pod跨节点通信overlay封装</p><p>lxcXXXX: 容器veth对在主机侧的接口</p><h3 id=同节点pod2pod>同节点pod2pod</h3><p>cillium_host是所有pod的网关，因此会先arp request该地址。arp相应其实是在lxc处被代答了，arp报文不会走到cillium_host</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>__section_entry
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>cil_from_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>	<span style=color:#719e07>case</span> <span style=color:#268bd2>bpf_htons</span>(ETH_P_ARP)<span style=color:#719e07>:</span>
</span></span><span style=display:flex><span>		ret <span style=color:#719e07>=</span> <span style=color:#268bd2>tail_call_internal</span>(ctx, CILIUM_CALL_ARP, <span style=color:#719e07>&amp;</span>ext_err);
</span></span><span style=display:flex><span>		<span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#268bd2>__section_tail</span>(CILIUM_MAP_CALLS, CILIUM_CALL_ARP)
</span></span><span style=display:flex><span><span style=color:#dc322f>int</span> <span style=color:#268bd2>tail_handle_arp</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> macaddr mac <span style=color:#719e07>=</span> THIS_INTERFACE_MAC;
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> macaddr smac;
</span></span><span style=display:flex><span>	__be32 sip;
</span></span><span style=display:flex><span>	__be32 tip;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Pass any unknown ARP requests to the Linux stack */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span><span style=color:#268bd2>arp_validate</span>(ctx, <span style=color:#719e07>&amp;</span>mac, <span style=color:#719e07>&amp;</span>smac, <span style=color:#719e07>&amp;</span>sip, <span style=color:#719e07>&amp;</span>tip))
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> CTX_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/*
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * The endpoint is expected to make ARP requests for its gateway IP.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * Most of the time, the gateway IP configured on the endpoint is
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * IPV4_GATEWAY but it may not be the case if after cilium agent reload
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * a different gateway is chosen. In such a case, existing endpoints
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * will have an old gateway configured. Since we don&#39;t know the IP of
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * previous gateways, we answer requests for all IPs with the exception
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * of the LXC IP (to avoid specific problems, like IP duplicate address
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * detection checks that might run within the container).
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (tip <span style=color:#719e07>==</span> LXC_IPV4)
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> CTX_ACT_OK;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> <span style=color:#268bd2>arp_respond</span>(ctx, <span style=color:#719e07>&amp;</span>mac, tip, <span style=color:#719e07>&amp;</span>smac, sip, <span style=color:#2aa198>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>普通ipv4报文，走handle_ipv4_from_lxc</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>cil_from_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_FROM_LXC)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> <span style=color:#268bd2>__tail_handle_ipv4</span>(ctx)  <span style=color:#586e75>// lookup ct, store in ct_buffer, zero indexed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4_cont</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>          <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4_from_lxc</span>(ctx, <span style=color:#719e07>&amp;</span>dst_id) <span style=color:#586e75>// do policy if ct est/new, ct_create if ct_status is new
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>            <span style=color:#719e07>|</span> <span style=color:#268bd2>__lookup_ip4_endpoint</span>(ip4) <span style=color:#586e75>// get local endpoint (pod or host)
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>            <span style=color:#719e07>|</span> <span style=color:#268bd2>ipv4_local_delivery</span>(...)
</span></span><span style=display:flex><span>              <span style=color:#719e07>|</span> <span style=color:#268bd2>ipv4_l3</span>(ctx,...) <span style=color:#586e75>// ttl-1 &amp; update mac header
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>              <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_call_dynamic</span>(ctx, <span style=color:#719e07>&amp;</span>POLICY_CALL_MAP, ep<span style=color:#719e07>-&gt;</span>lxc_id) <span style=color:#586e75>// jump to destination pod&#39;s bpf program for policy enforcement
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>                <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_policy</span>(...)
</span></span><span style=display:flex><span>                  <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_ipv4_ct_ingress_policy_only</span>(...)
</span></span><span style=display:flex><span>                    <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_ipv4_policy</span>(...)
</span></span><span style=display:flex><span>                      <span style=color:#719e07>|</span> <span style=color:#268bd2>ipv4_policy</span>(...)
</span></span><span style=display:flex><span>                        <span style=color:#719e07>|</span> <span style=color:#268bd2>redirect_ep</span>(...) <span style=color:#586e75>// redirect to dst iface
</span></span></span></code></pre></div><p>相关的map</p><p><code>CT_MAP_(TCP/ANY)(4/6)</code>: conntrack</p><p><code>cilium_lxc</code>：本机endpoint</p><p><code>cilium_call_policy</code>：pod ep对应的policy, BPF_MAP_TYPE_PROG_ARRAY</p><p>流程关键点是查<code>cilium_lxc</code>来判断是否local ep，然后做基本的二层转发</p><p>redirect_ep会根据宏定义判断最后调用redirect_peer（发往ifindex的peer，也就是容器里的eth0）还是redirect（发往ifindex，也就是lxc）。</p><p>5.10版本以上的内核建议开启bpf的host_routing模式。如果host_routing模式是legacy，则不会调用redirect_ep，而是返回CTX_ACT_OK。之后通过内核路由表转发到cillium_host设备上，走cil_from_netdev流程。这样流量会被内核路由表和iptables影响，且走了没有用的流程，性能较低。</p><p>一般情况下是直接redirect_peer发往对端eth0，因为对端ep的policy已经在<code>handle_policy</code>中的尾调用执行完毕了。</p><p>对端ep的ingress一般不会加载bpf代码，若走redirect，后续还会执行对端ep的ingress流程。</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#268bd2>cil_to_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span><span style=color:#719e07>|</span> tail_ipv4_to_endpoint
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> ipv4_policy
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>redirect_ep</span>(ctx, ifindex, from_host) <span style=color:#586e75>// redirect to dst iface
</span></span></span></code></pre></div><p>值得一提的是<code>TAIL_CT_LOOKUP4(ID, NAME, DIR, CONDITION, TARGET_ID, TARGET_NAME)</code>这个宏定义</p><ol><li>构造tuple查询ct</li><li>将ct信息存到CT_TAIL_CALL_BUFFER4，index是0，便于后续处理流程读取</li><li>根据宏定义的CONDITION，决定是否执行下一个尾调用</li></ol><p>总共有三处</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#268bd2>TAIL_CT_LOOKUP4</span>(CILIUM_CALL_IPV4_CT_EGRESS, tail_ipv4_ct_egress, CT_EGRESS,
</span></span><span style=display:flex><span>		<span style=color:#268bd2>is_defined</span>(ENABLE_PER_PACKET_LB),
</span></span><span style=display:flex><span>		CILIUM_CALL_IPV4_FROM_LXC_CONT, tail_handle_ipv4_cont)
</span></span><span style=display:flex><span><span style=color:#586e75>// tail_ipv4_ct_egress
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    
</span></span><span style=display:flex><span><span style=color:#268bd2>TAIL_CT_LOOKUP4</span>(CILIUM_CALL_IPV4_CT_INGRESS_POLICY_ONLY,
</span></span><span style=display:flex><span>		tail_ipv4_ct_ingress_policy_only, CT_INGRESS,
</span></span><span style=display:flex><span>		<span style=color:#268bd2>__and</span>(<span style=color:#268bd2>is_defined</span>(ENABLE_IPV4), <span style=color:#268bd2>is_defined</span>(ENABLE_IPV6)),
</span></span><span style=display:flex><span>		CILIUM_CALL_IPV4_TO_LXC_POLICY_ONLY, tail_ipv4_policy)
</span></span><span style=display:flex><span><span style=color:#586e75>// tail_ipv4_ct_ingress_policy_only
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    
</span></span><span style=display:flex><span><span style=color:#268bd2>TAIL_CT_LOOKUP4</span>(CILIUM_CALL_IPV4_CT_INGRESS, tail_ipv4_ct_ingress, CT_INGRESS,
</span></span><span style=display:flex><span>		<span style=color:#2aa198>1</span>, CILIUM_CALL_IPV4_TO_ENDPOINT, tail_ipv4_to_endpoint)
</span></span><span style=display:flex><span><span style=color:#586e75>// tail_ipv4_ct_ingress
</span></span></span></code></pre></div><h3 id=跨节点pod2pod>跨节点pod2pod</h3><p>在handle_ipv4_from_lxc时，<code>__lookup_ip4_endpoint</code>没有查到本地的ep，走<code>encap_and_redirect_lxc</code></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>cil_from_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_FROM_LXC)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> <span style=color:#268bd2>__tail_handle_ipv4</span>(ctx)  <span style=color:#586e75>// lookup ct, store in ct_buffer, zero indexed
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4_cont</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>          <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4_from_lxc</span>(ctx, <span style=color:#719e07>&amp;</span>dst_id)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> <span style=color:#268bd2>encap_and_redirect_lxc</span>(...) <span style=color:#586e75>// tunnel_endpoint is fetched from cilum_ipcache map
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>              <span style=color:#719e07>|</span> <span style=color:#268bd2>__encap_and_redirect_with_nodeid</span>(...)
</span></span><span style=display:flex><span>                <span style=color:#719e07>|</span> <span style=color:#268bd2>__encap_with_nodeid</span>(...)
</span></span><span style=display:flex><span>                <span style=color:#719e07>|</span> <span style=color:#268bd2>ctx_set_encap_info</span>(ctx, ...) <span style=color:#586e75>// redirect to vxlan netdev
</span></span></span></code></pre></div><p><code>encap_and_redirect_with_nodeid</code>还会执行ipsec的封装，若不开启则转发到对应的tunnel device</p><p>tunnel_endpoint是查找IPCACHE_MAP得到的，该表类似阿里的vmnc表</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cilium map get cilium_ipcache
</span></span><span style=display:flex><span>Key             Value                                                   State   Error
</span></span><span style=display:flex><span>10.0.2.158/32   <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>13789</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>172.18.0.5   sync
</span></span><span style=display:flex><span>10.0.1.214/32   <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>19140</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>172.18.0.5   sync
</span></span><span style=display:flex><span>10.0.1.213/32   <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>62536</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>0.0.0.0      sync
</span></span><span style=display:flex><span>0.0.0.0/0       <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>2</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>0.0.0.0          sync
</span></span><span style=display:flex><span>172.18.0.4/32   <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>1</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>0.0.0.0          sync
</span></span><span style=display:flex><span>10.0.1.116/32   <span style=color:#268bd2>identity</span><span style=color:#719e07>=</span><span style=color:#2aa198>9049</span> <span style=color:#268bd2>encryptkey</span><span style=color:#719e07>=</span><span style=color:#2aa198>0</span> <span style=color:#268bd2>tunnelendpoint</span><span style=color:#719e07>=</span>0.0.0.0       sync
</span></span></code></pre></div><p><code>ctx_set_encap_info</code>最终会调用helper <code>skb_set_tunnel_key</code>，再返回<strong>CTX_ACT_REDIRECT</strong>，由内核转到对应的tunnel设备上</p><p>之后执行tunnel设备的tc egress: <code>cil_to_overlay</code>。这边主要是做访问nodeport时，重定向发往remote ep时的snat，与pod2pod流程无关</p><p>之后内核tunnel设备会进行overlay封装，发往物理网口netdev</p><p>接收端节点，tunnel设备收到overlay报文后，走tunnel设备的ingress tc</p><p>此处已经时tunnel设备解封装后的报文，最后走ipv4_local_delivery，和同节点pod2pod后面的流程一样</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>//  bpf_overlay.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>|</span> <span style=color:#268bd2>cil_from_overlay</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4</span>(ctx, <span style=color:#719e07>&amp;</span>src_identity)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>ipcache_lookup4</span>(...) <span style=color:#586e75>// get dest identity
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>ipv4_local_delivery</span>(...) <span style=color:#586e75>// deliver to local identity, same steps with previous call stack
</span></span></span></code></pre></div><h3 id=node2pod>node2pod</h3><p>在发送端，根据路由表，pod网段先发送到cillium_host设备</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ ip r
</span></span><span style=display:flex><span>10.0.0.0/24 via 10.0.1.197 dev cilium_host src 10.0.1.197 mtu <span style=color:#2aa198>1450</span>
</span></span><span style=display:flex><span>10.0.1.0/24 via 10.0.1.197 dev cilium_host src 10.0.1.197
</span></span><span style=display:flex><span>10.0.2.0/24 via 10.0.1.197 dev cilium_host src 10.0.1.197 mtu <span style=color:#2aa198>1450</span>
</span></span></code></pre></div><p>tail_handle_ipv4之后流程类似pod2pod，本节点就<code>ipv4_local_delivery</code>，跨节点走<code>encap_and_redirect_with_nodeid</code></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_host.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>cil_from_netdev</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>do_netdev</span>(ctx, proto, from_host)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4_from_host</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4</span>(...)
</span></span><span style=display:flex><span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4</span>(...)
</span></span><span style=display:flex><span>          <span style=color:#719e07>|</span> <span style=color:#268bd2>encap_and_redirect_with_nodeid</span>(...) <span style=color:#586e75>// encap and send to remote tunnel endpoint
</span></span></span></code></pre></div><p>接收端cilium_vxlan的ingress方向，<code>lookup_ip4_endpoint</code>查询bpf map <code>cilium_lxc</code>判断是node上的<code>cilium_host</code></p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>//  bpf_overlay.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4</span>(ctx, <span style=color:#719e07>&amp;</span>src_identity)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> ep <span style=color:#719e07>=</span> <span style=color:#268bd2>lookup_ip4_endpoint</span>(ip4) <span style=color:#586e75>// look up endpoint from cilium_lxc
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#719e07>|</span> <span style=color:#719e07>if</span> (ep<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>&amp;</span> ENDPOINT_F_HOST)
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> <span style=color:#719e07>goto</span> to_host
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> to_host:
</span></span><span style=display:flex><span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>ipv4_l3</span>(...) <span style=color:#586e75>// update ttl and mac addresses
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>ctx_redirect</span>(ctx, HOST_IFINDEX, <span style=color:#2aa198>0</span>) <span style=color:#586e75>// redirect to cilium_host
</span></span></span></code></pre></div><h3 id=lb-service>lb service</h3><p>替代内核的 NodePort, LoadBalancer services and services with externalIPs的实现</p><h3 id=pod2service>pod2service</h3><p>首包流程</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>cil_from_container
</span></span><span style=display:flex><span>	<span style=color:#719e07>|</span> tail_handle_ipv4
</span></span><span style=display:flex><span>		<span style=color:#719e07>|</span> __per_packet_lb_svc_xlate_4
</span></span><span style=display:flex><span>			<span style=color:#719e07>|</span> lb4_extract_tuple <span style=color:#586e75>// 取五元组（pod --&gt; svc）
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			<span style=color:#719e07>|</span> lb4_lookup_service <span style=color:#586e75>// 查svc，能查到
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			<span style=color:#719e07>|</span> lb4_local <span style=color:#586e75>// 查ct，执行DNAT
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>				<span style=color:#719e07>|</span> ct_lookup4 <span style=color:#586e75>//根据五元组查询service类型连接状态（第一个包，所以查询不到）
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>				<span style=color:#719e07>|</span> lb4_select_backend_id <span style=color:#586e75>//根据算法选择一个service后端 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>				<span style=color:#719e07>|</span> ct_create4 <span style=color:#586e75>//创建service类型的连接状态（连接状态关联了service后端，后续同一个连接的数据包将导向用一个后端） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>				<span style=color:#719e07>|</span> lb4_xlate <span style=color:#586e75>// 执行DNAT（修改数据包的目的地址为endpoint的地址） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			<span style=color:#719e07>|</span> <span style=color:#268bd2>tail_call_internal</span>(ctx, CILIUM_CALL_IPV4_CT_EGRESS, ext_err) <span style=color:#586e75>// 保存ct到ct_buffer
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>				<span style=color:#719e07>|</span> tail_handle_ipv4_cont
</span></span><span style=display:flex><span>                	<span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4_from_lxc</span>(ctx, <span style=color:#719e07>&amp;</span>dst_id)
</span></span><span style=display:flex><span>           				 <span style=color:#719e07>|</span> <span style=color:#268bd2>encap_and_redirect_lxc</span>(...) <span style=color:#586e75>// tunnel_endpoint is fetched from cilum_ipcache map
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>             			 <span style=color:#719e07>|</span> <span style=color:#268bd2>__encap_and_redirect_with_nodeid</span>(...)
</span></span><span style=display:flex><span>             			   <span style=color:#719e07>|</span> <span style=color:#268bd2>__encap_with_nodeid</span>(...)
</span></span><span style=display:flex><span>            			   <span style=color:#719e07>|</span> <span style=color:#268bd2>ctx_redirect</span>(ctx, ENCAP_IFINDEX, <span style=color:#2aa198>0</span>) <span style=color:#586e75>// redirect to vxlan netdev
</span></span></span></code></pre></div><p><code>tail_handle_ipv4</code> 过程中查service表，若查到走dnat流程</p><p>dnat之后的流程和pod2pod流程基本一致</p><p>reply流程</p><p>主要是做反向DNAT</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#719e07>|</span> cil_to_container
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> tail_ipv4_to_endpoint
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> ipv4_policy
</span></span><span style=display:flex><span>        <span style=color:#719e07>|</span> lb4_rev_nat <span style=color:#586e75>// ct_state == CT_REPLY, do reverse nat
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          <span style=color:#719e07>|</span> <span style=color:#268bd2>map_lookup_elem</span>(<span style=color:#719e07>&amp;</span>LB4_REVERSE_NAT_MAP, ...) <span style=color:#586e75>// lookup reverset nat map
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          <span style=color:#719e07>|</span> __lb4_rev_nat <span style=color:#586e75>// replace source IP
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      <span style=color:#719e07>|</span> <span style=color:#268bd2>redirect_ep</span>(ctx, ifindex, from_host) <span style=color:#586e75>// redirect to dest iface
</span></span></span></code></pre></div><h3 id=node2service>node2service</h3><p>与pod2service的区别是，除了DNAT还要做一次SNAT，源地址统一改成node的地址</p><p>这是由于访问service的流量，可能是节点上来的，也有可能是外部来的。无论如何，都snat成nodeport地址</p><p>相应的，做反向DNAT之前要先做反向SNAT</p><h4 id=lb代码加载位置>lb代码加载位置</h4><ul><li><p>默认<code>cil_from_netdev</code>加载在cillium_host上</p></li><li><p>开启nodeport：<code>cil_from_netdev</code>会加载到物理口的tc egress上</p></li><li><p>开启 LB&amp;NodePort XDP加速：启动后编译选项 <code>-DENABLE_NODEPORT_ACCELERATION=1</code></p><p>之后bpf_xdp.c会编译尾调用<strong>CILIUM_CALL_IPV4_FROM_NETDEV</strong></p><p>最终<code>cil_xdp_entry</code>流程中会执行lb流程</p></li></ul><p>无论是上述哪种加载流程，最终都会执行<code>nodeport_lb4</code></p><h4 id=入向流量>入向流量</h4><ol><li>SVC lookup? &ndash;> DNAT</li><li>endpoint remote?<ol><li>tunnel or local?</li><li>SNAT</li><li>fib_lookup</li><li>redirect</li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nodeport_lb4
</span></span><span style=display:flex><span>  lb4_lookup_servic <span style=color:#586e75>//查询该流量是否属于对应的service前端 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    lb4_local <span style=color:#586e75>//执行lb算法选择service后端，进行DNAT 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      ct_lookup4 <span style=color:#586e75>//根据五元组查询service类型连接状态（第一个包，所以查询不到） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      lb4_select_backend_id <span style=color:#586e75>//根据算法选择一个service后端 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      ct_create4 <span style=color:#586e75>//创建service类型的连接状态（连接状态关联了service后端，后续同一个连接的数据包将导向用一个后端） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      lb4_xlate <span style=color:#586e75>//执行DNAT（修改数据包的目的地址为service后端的地址） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    ct_lookup4 <span style=color:#586e75>//根据五元组查询EGRESS(入)类型连接状态（注意此时五元组中的目的地址已经发生变化）（反转五元组） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    ct_create4 <span style=color:#586e75>//创建连接状态（使用反转五元组创建，用于反向DNAT） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_NODEPORT_NAT) <span style=color:#586e75>//执行尾调用，跳转到CILIUM_CALL_IPV4_NODEPORT_NAT 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    tail_nodeport_nat_ipv4
</span></span><span style=display:flex><span>      snat_v4_proces <span style=color:#586e75>//执行SNAT 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        snat_v4_handle_mapping <span style=color:#586e75>// 处理SNAT映射 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          snat_v4_lookup <span style=color:#586e75>// 根据五元组查询SNAT映射（查不到） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          snat_v4_new_mapping <span style=color:#586e75>//新建SNAT映射，首先调整原来的端口，若发生冲突则重新选择（会根据正向和反向分别建立映射，反向搜索） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        snat_v4_rewrite_egress <span style=color:#586e75>// 执行实际的SNAT动作（修改源地址、源端口、修正checksum） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      fib_lookup <span style=color:#586e75>// 查询路由表 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      eth_store_daddr<span style=color:#719e07>/</span>eth_store_saddr <span style=color:#586e75>// 设置mac地址 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      ctx_redirect <span style=color:#586e75>// 发送数据包 
</span></span></span></code></pre></div><h4 id=反向流量>反向流量</h4><ol><li>rev-SNAT xlation</li><li>rev-DNAT xlation</li><li>fib_lookup</li><li>redierct</li></ol><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>nodeport_lb4
</span></span><span style=display:flex><span>  lb4_lookup_service <span style=color:#586e75>// 查不到
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>  <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_NODEPORT_NAT_INGRESS)
</span></span><span style=display:flex><span>  tail_nodeport_nat_ingress_ipv4
</span></span><span style=display:flex><span>    snat_v4_rev_nat <span style=color:#586e75>// 执行SNAT 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      snat_v4_rev_nat_handle_mapping <span style=color:#586e75>//校验endpoint--&gt;lip(endpoint) 的snat entry是否存在
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        __snat_lookup <span style=color:#586e75>// 查询SNAT映射，查询到了正向流建立SNAT映射 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      snat_v4_rewrite_headers <span style=color:#586e75>// 执行rev-SNAT：endpoint --&gt; client
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_NODEPORT_REVNAT)
</span></span><span style=display:flex><span>    nodeport_rev_dnat_ingress_ipv4
</span></span><span style=display:flex><span>        ct_lookup4 <span style=color:#586e75>// 查询连接状态, CT_REPLY
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        lb4_rev_nat<span style=color:#586e75>// 执行rev-DNAT 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          <span style=color:#268bd2>map_lookup_elem</span>(<span style=color:#719e07>&amp;</span>LB4_REVERSE_NAT_MAP, <span style=color:#719e07>&amp;</span>ct_state→rev_nat_index)<span style=color:#586e75>// 查询rev-DNAT所需的原始IP端口（即service的IP及端口） 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>          __lb4_rev_nat<span style=color:#586e75>// 执行rev-DNAT，修改源端口、源地址、checksum 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    	ipv4_l3 <span style=color:#586e75>// ttl--
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        fib_lookup<span style=color:#586e75>// 查询路由表 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>        eth_store_daddr<span style=color:#719e07>/</span>eth_store_saddr <span style=color:#586e75>//设置mac地址 
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>      ctx_redirect <span style=color:#586e75>// 发送数据包 
</span></span></span></code></pre></div><h5 id=ct表>ct表</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(type, BPF_MAP_TYPE_LRU_HASH); <span style=color:#586e75>// LRU哈希表
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>__type</span>(key, <span style=color:#719e07>struct</span> ipv4_ct_tuple);  <span style=color:#586e75>// 哈希key
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>__type</span>(value, <span style=color:#719e07>struct</span> ct_entry);     <span style=color:#586e75>// 哈希value
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>__uint</span>(pinning, LIBBPF_PIN_BY_NAME);   <span style=color:#586e75>//固定在文件系统中
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>__uint</span>(max_entries, CT_MAP_SIZE_TCP);  <span style=color:#586e75>// 最大条目数
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>} CT_MAP_TCP4 __section_maps_btf;
</span></span></code></pre></div><h5 id=lb-realserver>lb realserver</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> lb4_backend {
</span></span><span style=display:flex><span>	__be32 address;		<span style=color:#586e75>/* Service endpoint IPv4 address */</span>
</span></span><span style=display:flex><span>	__be16 port;		<span style=color:#586e75>/* L4 port filter */</span>
</span></span><span style=display:flex><span>	__u8 proto;		<span style=color:#586e75>/* L4 protocol, currently not used (set to 0) */</span>
</span></span><span style=display:flex><span>	__u8 flags;
</span></span><span style=display:flex><span>	__u16 cluster_id;	<span style=color:#586e75>/* With this field, we can distinguish two
</span></span></span><span style=display:flex><span><span style=color:#586e75>				 * backends that have the same IP address,
</span></span></span><span style=display:flex><span><span style=color:#586e75>				 * but belong to the different cluster.
</span></span></span><span style=display:flex><span><span style=color:#586e75>				 */</span>
</span></span><span style=display:flex><span>	__u8 zone;
</span></span><span style=display:flex><span>	__u8 pad;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>通过cluster_id解决ip重叠问题</p><h5 id=snat表>snat表</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(type, BPF_MAP_TYPE_LRU_HASH);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(key, <span style=color:#719e07>struct</span> ipv4_ct_tuple);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(value, <span style=color:#719e07>struct</span> ipv4_nat_entry);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(pinning, LIBBPF_PIN_BY_NAME);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(max_entries, SNAT_MAPPING_IPV4_SIZE);
</span></span><span style=display:flex><span>} SNAT_MAPPING_IPV4 __section_maps_btf;
</span></span></code></pre></div><h3 id=pod2external>pod2external</h3><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>// bpf_lxc.c
</span></span></span><span style=display:flex><span><span style=color:#586e75></span><span style=color:#268bd2>cil_from_container</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>  <span style=color:#719e07>|</span> <span style=color:#268bd2>ep_tail_call</span>(ctx, CILIUM_CALL_IPV4_FROM_LXC)
</span></span><span style=display:flex><span>    <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>      <span style=color:#719e07>|</span> <span style=color:#268bd2>__tail_handle_ipv4</span>(ctx)
</span></span><span style=display:flex><span>        <span style=color:#719e07>|</span> <span style=color:#268bd2>tail_handle_ipv4_cont</span>(<span style=color:#719e07>struct</span> __ctx_buff <span style=color:#719e07>*</span>ctx)
</span></span><span style=display:flex><span>          <span style=color:#719e07>|</span> <span style=color:#268bd2>handle_ipv4_from_lxc</span>(ctx, <span style=color:#719e07>&amp;</span>dst_id)
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> ret <span style=color:#719e07>=</span> <span style=color:#268bd2>encap_and_redirect_lxc</span>(...)
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> <span style=color:#719e07>if</span> (ret <span style=color:#719e07>==</span> DROP_NO_TUNNEL_ENDPOINT) <span style=color:#719e07>goto</span> pass_to_stack
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> pass_to_stack: <span style=color:#268bd2>ipv4_l3</span>(...)
</span></span><span style=display:flex><span>            <span style=color:#719e07>|</span> <span style=color:#719e07>return</span> to stack
</span></span></code></pre></div><p>remote endpoint未查到，返回DROP_NO_TUNNEL_ENDPOINT</p><p>之后发往内核协议栈，内核可能有iptables规则nat成nodeport</p><p>接收回包时，内核根据出方向Masquerade的情况做反向nat，之后查内核路由表发给<code>cilium_host</code>。最后走cil_from_netdev，转给对应的pod</p><h3 id=参考资料>参考资料</h3><p><a href=https://arthurchiao.art/blog/cilium-life-of-a-packet-pod-to-service/ target=_blank rel=noopener>Life of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics</a></p><p><a href=https://zhuanlan.zhihu.com/p/576435879 target=_blank rel=noopener>cilium LB源码分析 - 知乎</a></p><p><a href=https://chnhaoran.github.io/blog/cilium-datapath-deep-dive-basic-connectivity-zh/ target=_blank rel=noopener>Cilium数据平面深度解析 1 - 基础连通性</a></p><p><a href=https://rexrock.github.io/post/cilium2/ target=_blank rel=noopener>Cilium datapath梳理 | REXROCK</a></p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Mar 3, 2025</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/ebpf>ebpf</a> <a class=category href=https://scottlx.github.io/tags/cilium>cilium</a> <a class=category href=https://scottlx.github.io/tags/k8s>k8s</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/dpvs-icmp/ title="dpvs icmp session">dpvs icmp session</a>
<a class="basic-alignment right" href=https://scottlx.github.io/posts/bpf_lpm_trie/ title="bpf lpm trie">bpf lpm trie</a></p><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=odd></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>