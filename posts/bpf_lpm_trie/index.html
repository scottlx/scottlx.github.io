<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=/css/fonts.css rel=stylesheet type=text/css><title>bpf lpm trie</title>
<link rel=stylesheet href=/css/hugo-octopress.css><link rel=stylesheet href=/css/fork-awesome.min.css><link href=https://scottlx.github.io/favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="windseek"><meta name=generator content="Hugo 0.145.0"></head><body><header role=banner><hgroup><h1><a href=https://scottlx.github.io/>windseek</a></h1><h2>be curious, be free</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigate…</option><option value=https://scottlx.github.io/>» 归档</option><option value=https://scottlx.github.io/archives/>» Archives</option><option value=https://scottlx.github.io/cheatsheet/>» CheatSheet</option><option value=https://scottlx.github.io/about/>» Aboutme</option></select></fieldset><ul class=main-navigation><li><a href=https://scottlx.github.io/ title=归档>归档</a></li><li><a href=https://scottlx.github.io/archives/ title=Archives target=_blank rel="noopener noreferrer">Archives</a></li><li><a href=https://scottlx.github.io/cheatsheet/ title=CheatSheet target=_blank rel="noopener noreferrer">CheatSheet</a></li><li><a href=https://scottlx.github.io/about/ title=Aboutme target=_blank rel="noopener noreferrer">Aboutme</a></li></ul><ul class=subscription></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:https://scottlx.github.io/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Mar 6, 2025
- 11 minute read
- <a href=https://scottlx.github.io/posts/bpf_lpm_trie/#disqus_thread>Comments</a>
- <a class=label href=https://scottlx.github.io/categories/%e6%8a%80%e6%9c%af%e4%bb%8b%e7%bb%8d/>技术介绍</a></p><h1 class=entry-title>bpf lpm trie</h1></header><div class=entry-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav><p>lpm有多种实现方式，最常用的是用trie。当然也会有更简单的实现方式，例如某些特定场景用多重哈希表就能解决（ipv4地址，32个掩码对应32个哈希表）</p><p>从4.11内核版本开始，bpf map引入了<code>BPF_MAP_TYPE_LPM_TRIE</code></p><p>主要是用于匹配ip地址，内部是将数据存储在一个不平衡的trie中，key使用<code>prefixlen,data</code></p><p>data是以大端网络序存储的，data[0]存的是msb。</p><p>prefixlen支持8的整数倍，最高可以是2048。因此除了ip匹配，还可以用来做端口，协议，vpcid等等的扩充匹配。在应用层面上除了做路由表，还可以作为acl，policy等匹配过滤的底层实现</p><h4 id=使用方式>使用方式</h4><p><a href=https://docs.kernel.org/next/bpf/map_lpm_trie.html target=_blank rel=noopener>BPF_MAP_TYPE_LPM_TRIE — The Linux Kernel documentation</a></p><p>除了上述基本的Ipv4的使用方式，扩展使用方式可以参考一下cillium中IPCACHE_MAP的使用</p><p>首先是map的定义</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> ipcache_key {
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> bpf_lpm_trie_key lpm_key;
</span></span><span style=display:flex><span>	__u16 cluster_id;
</span></span><span style=display:flex><span>	__u8 pad1;
</span></span><span style=display:flex><span>	__u8 family;
</span></span><span style=display:flex><span>	<span style=color:#719e07>union</span> {
</span></span><span style=display:flex><span>		<span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>			__u32		ip4;
</span></span><span style=display:flex><span>			__u32		pad4;
</span></span><span style=display:flex><span>			__u32		pad5;
</span></span><span style=display:flex><span>			__u32		pad6;
</span></span><span style=display:flex><span>		};
</span></span><span style=display:flex><span>		<span style=color:#719e07>union</span> v6addr	ip6;
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>} __packed;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>/* Global IP -&gt; Identity map for applying egress label-based policy */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(type, BPF_MAP_TYPE_LPM_TRIE);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(key, <span style=color:#719e07>struct</span> ipcache_key);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__type</span>(value, <span style=color:#719e07>struct</span> remote_endpoint_info);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(pinning, LIBBPF_PIN_BY_NAME);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(max_entries, IPCACHE_MAP_SIZE);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>__uint</span>(map_flags, BPF_F_NO_PREALLOC);
</span></span><span style=display:flex><span>} IPCACHE_MAP __section_maps_btf;
</span></span></code></pre></div><p>可以看到cillium将v4和v6合并成一个map查询，匹配条件并带上了<code>cluster_id</code></p><p>因此查询map时候，prefix_len需要加上cluster_id，pad1，family这四个字节的长度。例如查询192.168.10.0/24的时候，prefix_len(bit)= 24bit + 4byte*8bit/byte = 56bit</p><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/* IPCACHE_STATIC_PREFIX gets sizeof non-IP, non-prefix part of ipcache_key */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>#define IPCACHE_STATIC_PREFIX							\
</span></span></span><span style=display:flex><span><span style=color:#719e07>	(8 * (sizeof(struct ipcache_key) - sizeof(struct bpf_lpm_trie_key)	\
</span></span></span><span style=display:flex><span><span style=color:#719e07>	      - sizeof(union v6addr)))
</span></span></span><span style=display:flex><span><span style=color:#719e07>#define IPCACHE_PREFIX_LEN(PREFIX) (IPCACHE_STATIC_PREFIX + (PREFIX))
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>
</span></span><span style=display:flex><span><span style=color:#719e07>static</span> __always_inline __maybe_unused <span style=color:#719e07>struct</span> remote_endpoint_info <span style=color:#719e07>*</span>
</span></span><span style=display:flex><span><span style=color:#268bd2>ipcache_lookup4</span>(<span style=color:#719e07>const</span> <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>map, __be32 addr, __u32 prefix, __u32 cluster_id)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> ipcache_key key <span style=color:#719e07>=</span> {
</span></span><span style=display:flex><span>		.lpm_key <span style=color:#719e07>=</span> { <span style=color:#268bd2>IPCACHE_PREFIX_LEN</span>(prefix), {} },
</span></span><span style=display:flex><span>		.family <span style=color:#719e07>=</span> ENDPOINT_KEY_IPV4,
</span></span><span style=display:flex><span>		.ip4 <span style=color:#719e07>=</span> addr,
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Check overflow */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (cluster_id <span style=color:#719e07>&gt;</span> UINT16_MAX)
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	key.cluster_id <span style=color:#719e07>=</span> (__u16)cluster_id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	key.ip4 <span style=color:#719e07>&amp;=</span> <span style=color:#268bd2>GET_PREFIX</span>(prefix);
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> <span style=color:#268bd2>map_lookup_elem</span>(map, <span style=color:#719e07>&amp;</span>key);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>cluster_id</code>的字节序是大端还是小端其实没有区别，只要插入和查询都用的相同的字节序就行</p><h4 id=基本原理>基本原理</h4><p><a href=https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/lpm_trie.c target=_blank rel=noopener>lpm_trie.c - kernel/bpf/lpm_trie.c - Linux source code v5.13 - Bootlin Elixir Cross Referencer</a></p><h5 id=数据结构>数据结构</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>struct</span> lpm_trie_node {
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> rcu_head rcu;
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> lpm_trie_node __rcu <span style=color:#719e07>*</span>child[<span style=color:#2aa198>2</span>];
</span></span><span style=display:flex><span>    u32 prefixlen;  <span style=color:#586e75>// node的前缀，例如192.168.0.0/24这个node是24
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>    u32 flags;
</span></span><span style=display:flex><span>    u8 data[];   <span style=color:#586e75>// data+value，例如192.168.0.0/24 --》123，那么data[5]={c0, a8, 00, 00, 7b}
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>};
</span></span><span style=display:flex><span><span style=color:#719e07>struct</span> lpm_trie {
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> bpf_map			map;
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie_node __rcu	<span style=color:#719e07>*</span>root;
</span></span><span style=display:flex><span>	<span style=color:#dc322f>size_t</span>				n_entries; <span style=color:#586e75>// 节点数
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#dc322f>size_t</span>				max_prefixlen; <span style=color:#586e75>//最长前缀bit，例如ipv4是32，上述IPCACHE_MAP的例子是32+32 = 64
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#dc322f>size_t</span>				data_size; <span style=color:#586e75>// max_prefixlen的byte表示，max_prefixlen/8
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#dc322f>spinlock_t</span>			lock;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><ul><li><code>data</code> 数组的前 <code>trie->data_size</code> 字节存储前缀数据。整个<code>trie</code>的所有节点，前缀数据的大小是固定的</li><li>如果节点有 <code>value</code>，则 <code>value</code> 紧跟在前缀数据之后存储。</li></ul><h5 id=分配节点>分配节点</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#719e07>static</span> <span style=color:#719e07>struct</span> lpm_trie_node <span style=color:#719e07>*</span><span style=color:#268bd2>lpm_trie_node_alloc</span>(<span style=color:#719e07>const</span> <span style=color:#719e07>struct</span> lpm_trie <span style=color:#719e07>*</span>trie, <span style=color:#719e07>const</span> <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>value)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#719e07>struct</span> lpm_trie_node <span style=color:#719e07>*</span>node;
</span></span><span style=display:flex><span>    <span style=color:#dc322f>size_t</span> size <span style=color:#719e07>=</span> <span style=color:#719e07>sizeof</span>(<span style=color:#719e07>struct</span> lpm_trie_node) <span style=color:#719e07>+</span> trie<span style=color:#719e07>-&gt;</span>data_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (value)
</span></span><span style=display:flex><span>        size <span style=color:#719e07>+=</span> trie<span style=color:#719e07>-&gt;</span>map.value_size;  <span style=color:#586e75>// 如果有value，分配的空间加上value大小
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>    node <span style=color:#719e07>=</span> <span style=color:#268bd2>bpf_map_kmalloc_node</span>(<span style=color:#719e07>&amp;</span>trie<span style=color:#719e07>-&gt;</span>map, size, GFP_ATOMIC <span style=color:#719e07>|</span> __GFP_NOWARN, trie<span style=color:#719e07>-&gt;</span>map.numa_node);
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>node)
</span></span><span style=display:flex><span>        <span style=color:#719e07>return</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>if</span> (value)
</span></span><span style=display:flex><span>        <span style=color:#268bd2>memcpy</span>(node<span style=color:#719e07>-&gt;</span>data <span style=color:#719e07>+</span> trie<span style=color:#719e07>-&gt;</span>data_size, value, trie<span style=color:#719e07>-&gt;</span>map.value_size);  <span style=color:#586e75>// 如果有value，将其复制到 data 数组中前缀数据之后的位置。
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>    <span style=color:#719e07>return</span> node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=插入流程>插入流程</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/* This trie implements a longest prefix match algorithm that can be used to
</span></span></span><span style=display:flex><span><span style=color:#586e75> * match IP addresses to a stored set of ranges.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Data stored in @data of struct bpf_lpm_key and struct lpm_trie_node is
</span></span></span><span style=display:flex><span><span style=color:#586e75> * interpreted as big endian, so data[0] stores the most significant byte.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Match ranges are internally stored in instances of struct lpm_trie_node
</span></span></span><span style=display:flex><span><span style=color:#586e75> * which each contain their prefix length as well as two pointers that may
</span></span></span><span style=display:flex><span><span style=color:#586e75> * lead to more nodes containing more specific matches. Each node also stores
</span></span></span><span style=display:flex><span><span style=color:#586e75> * a value that is defined by and returned to userspace via the update_elem
</span></span></span><span style=display:flex><span><span style=color:#586e75> * and lookup functions.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * For instance, let&#39;s start with a trie that was created with a prefix length
</span></span></span><span style=display:flex><span><span style=color:#586e75> * of 32, so it can be used for IPv4 addresses, and one single element that
</span></span></span><span style=display:flex><span><span style=color:#586e75> * matches 192.168.0.0/16. The data array would hence contain
</span></span></span><span style=display:flex><span><span style=color:#586e75> * [0xc0, 0xa8, 0x00, 0x00] in big-endian notation. This documentation will
</span></span></span><span style=display:flex><span><span style=color:#586e75> * stick to IP-address notation for readability though.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * As the trie is empty initially, the new node (1) will be places as root
</span></span></span><span style=display:flex><span><span style=color:#586e75> * node, denoted as (R) in the example below. As there are no other node, both
</span></span></span><span style=display:flex><span><span style=color:#586e75> * child pointers are %NULL.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |       (1)  (R) |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Next, let&#39;s add a new node (2) matching 192.168.0.0/24. As there is already
</span></span></span><span style=display:flex><span><span style=color:#586e75> * a node with the same data and a smaller prefix (ie, a less specific one),
</span></span></span><span style=display:flex><span><span style=color:#586e75> * node (2) will become a child of (1). In child index depends on the next bit
</span></span></span><span style=display:flex><span><span style=color:#586e75> * that is outside of what (1) matches, and that bit is 0, so (2) will be
</span></span></span><span style=display:flex><span><span style=color:#586e75> * child[0] of (1):
</span></span></span><span style=display:flex><span><span style=color:#586e75> 
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 由于已经存在一个data相同但长度更短的前缀，新前缀将作为节点(1)的子节点存储。新前缀（192.168.0.0/24）在旧前缀（192.168.0.0/16）之后的下一位（第17位） 为0，因此将成为孩子0
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |       (1)  (R) |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |       (2)      |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    | 192.168.0.0/24 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |    value: 2    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * The child[1] slot of (1) could be filled with another node which has bit #17
</span></span></span><span style=display:flex><span><span style=color:#586e75> * (the next bit after the ones that (1) matches on) set to 1. For instance,
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 192.168.128.0/24:
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 第17位为1，所以插入在右边
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |       (1)  (R) |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *              +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                   |      |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    +----------------+  +------------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |       (2)      |  |        (3)       |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    | 192.168.0.0/24 |  | 192.168.128.0/24 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |    value: 2    |  |     value: 3     |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    |   [0]    [1]   |  |    [0]    [1]    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *    +----------------+  +------------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * Let&#39;s add another node (4) to the game for 192.168.1.0/24. In order to place
</span></span></span><span style=display:flex><span><span style=color:#586e75> * it, node (1) is looked at first, and because (4) of the semantics laid out
</span></span></span><span style=display:flex><span><span style=color:#586e75> * above (bit #17 is 0), it would normally be attached to (1) as child[0].
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 本来要插入在（1）的左孩子，但是这个位置已经被（2）占掉了，所以要创造出这样的一个空间，也就是（2）的prefixlen 24往前移一位prefixlen 23，作为假节点
</span></span></span><span style=display:flex><span><span style=color:#586e75> * However, that slot is already allocated, so a new node is needed in between.
</span></span></span><span style=display:flex><span><span style=color:#586e75> * That node does not have a value attached to it and it will never be
</span></span></span><span style=display:flex><span><span style=color:#586e75> * returned to users as result of a lookup. It is only there to differentiate
</span></span></span><span style=display:flex><span><span style=color:#586e75> * the traversal further. It will get a prefix as wide as necessary to
</span></span></span><span style=display:flex><span><span style=color:#586e75> * distinguish its two children:
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      |       (1)  (R) |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                      +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                           |      |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            +----------------+  +------------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            |       (4)  (I) |  |        (3)       |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            | 192.168.0.0/23 |  | 192.168.128.0/24 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            |    value: ---  |  |     value: 3     |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            |   [0]    [1]   |  |    [0]    [1]    |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *            +----------------+  +------------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *                 |      |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  +----------------+  +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  |       (2)      |  |       (5)      |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  | 192.168.0.0/24 |  | 192.168.1.0/24 |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  |    value: 2    |  |     value: 5   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  |   [0]    [1]   |  |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75> *  +----------------+  +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * 192.168.1.1/32 would be a child of (5) etc.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * An intermediate node will be turned into a &#39;real&#39; node on demand. In the
</span></span></span><span style=display:flex><span><span style=color:#586e75> * example above, (4) would be re-used if 192.168.0.0/23 is added to the trie.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * A fully populated trie would have a height of 32 nodes, as the trie was
</span></span></span><span style=display:flex><span><span style=color:#586e75> * created with a prefix length of 32.
</span></span></span><span style=display:flex><span><span style=color:#586e75> *
</span></span></span><span style=display:flex><span><span style=color:#586e75> * The lookup starts at the root node. If the current node matches and if there
</span></span></span><span style=display:flex><span><span style=color:#586e75> * is a child that can be used to become more specific, the trie is traversed
</span></span></span><span style=display:flex><span><span style=color:#586e75> * downwards. The last node in the traversal that is a non-intermediate one is
</span></span></span><span style=display:flex><span><span style=color:#586e75> * returned.
</span></span></span><span style=display:flex><span><span style=color:#586e75> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>static</span> <span style=color:#dc322f>size_t</span> <span style=color:#268bd2>longest_prefix_match</span>(<span style=color:#719e07>const</span> <span style=color:#719e07>struct</span> lpm_trie <span style=color:#719e07>*</span>trie,
</span></span><span style=display:flex><span>				   <span style=color:#719e07>const</span> <span style=color:#719e07>struct</span> lpm_trie_node <span style=color:#719e07>*</span>node,
</span></span><span style=display:flex><span>				   <span style=color:#719e07>const</span> <span style=color:#719e07>struct</span> bpf_lpm_trie_key <span style=color:#719e07>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	u32 limit <span style=color:#719e07>=</span> <span style=color:#268bd2>min</span>(node<span style=color:#719e07>-&gt;</span>prefixlen, key<span style=color:#719e07>-&gt;</span>prefixlen);  <span style=color:#586e75>// 匹配到两者的最小就可以停止了，例如/24和/16，只要匹配到/16就可以确定已经匹配上了
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	u32 prefixlen <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>, i <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>BUILD_BUG_ON</span>(<span style=color:#268bd2>offsetof</span>(<span style=color:#719e07>struct</span> lpm_trie_node, data) <span style=color:#719e07>%</span> <span style=color:#719e07>sizeof</span>(u32)); <span style=color:#586e75>// 确保数据四字节对齐
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>BUILD_BUG_ON</span>(<span style=color:#268bd2>offsetof</span>(<span style=color:#719e07>struct</span> bpf_lpm_trie_key, data) <span style=color:#719e07>%</span> <span style=color:#719e07>sizeof</span>(u32));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#719e07>#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) &amp;&amp; defined(CONFIG_64BIT)  </span><span style=color:#586e75>// 如果64位系统支持不对齐读取，则先处理开头的64bit
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* data_size &gt;= 16 has very small probability.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * We do not use a loop for optimal code generation.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (trie<span style=color:#719e07>-&gt;</span>data_size <span style=color:#719e07>&gt;=</span> <span style=color:#2aa198>8</span>) {
</span></span><span style=display:flex><span>		u64 diff <span style=color:#719e07>=</span> <span style=color:#268bd2>be64_to_cpu</span>(<span style=color:#719e07>*</span>(__be64 <span style=color:#719e07>*</span>)node<span style=color:#719e07>-&gt;</span>data <span style=color:#719e07>^</span>
</span></span><span style=display:flex><span>				       <span style=color:#719e07>*</span>(__be64 <span style=color:#719e07>*</span>)key<span style=color:#719e07>-&gt;</span>data);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		prefixlen <span style=color:#719e07>=</span> <span style=color:#2aa198>64</span> <span style=color:#719e07>-</span> <span style=color:#268bd2>fls64</span>(diff);
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (prefixlen <span style=color:#719e07>&gt;=</span> limit)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> limit;
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (diff)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> prefixlen;
</span></span><span style=display:flex><span>		i <span style=color:#719e07>=</span> <span style=color:#2aa198>8</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#719e07>#endif
</span></span></span><span style=display:flex><span><span style=color:#719e07></span>	<span style=color:#586e75>// 循环4个字节4个字节去匹配
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>while</span> (trie<span style=color:#719e07>-&gt;</span>data_size <span style=color:#719e07>&gt;=</span> i <span style=color:#719e07>+</span> <span style=color:#2aa198>4</span>) {
</span></span><span style=display:flex><span>		u32 diff <span style=color:#719e07>=</span> <span style=color:#268bd2>be32_to_cpu</span>(<span style=color:#719e07>*</span>(__be32 <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>node<span style=color:#719e07>-&gt;</span>data[i] <span style=color:#719e07>^</span>
</span></span><span style=display:flex><span>				       <span style=color:#719e07>*</span>(__be32 <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>key<span style=color:#719e07>-&gt;</span>data[i]); <span style=color:#586e75>// 异或，不匹配的bit为1
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>		prefixlen <span style=color:#719e07>+=</span> <span style=color:#2aa198>32</span> <span style=color:#719e07>-</span> <span style=color:#268bd2>fls</span>(diff);   <span style=color:#586e75>// Find Last Set，返回一个整数的最高有效位的位置（从1开始计数），取最高的不匹配的位置
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>if</span> (prefixlen <span style=color:#719e07>&gt;=</span> limit)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> limit; <span style=color:#586e75>// 若超过limit，说明完全匹配上，直接返回limit
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>if</span> (diff)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> prefixlen;  <span style=color:#586e75>// 发现不匹配的位置，则当前的位置就是最长匹配前缀的位置
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		i <span style=color:#719e07>+=</span> <span style=color:#2aa198>4</span>; <span style=color:#586e75>// 若没有diff，说明这四个byte都匹配上了，继续
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>// 如果trie-&gt;data_size不是8的倍数，需要再处理末尾的1，2，3个字节
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>if</span> (trie<span style=color:#719e07>-&gt;</span>data_size <span style=color:#719e07>&gt;=</span> i <span style=color:#719e07>+</span> <span style=color:#2aa198>2</span>) {
</span></span><span style=display:flex><span>		u16 diff <span style=color:#719e07>=</span> <span style=color:#268bd2>be16_to_cpu</span>(<span style=color:#719e07>*</span>(__be16 <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>node<span style=color:#719e07>-&gt;</span>data[i] <span style=color:#719e07>^</span>
</span></span><span style=display:flex><span>				       <span style=color:#719e07>*</span>(__be16 <span style=color:#719e07>*</span>)<span style=color:#719e07>&amp;</span>key<span style=color:#719e07>-&gt;</span>data[i]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		prefixlen <span style=color:#719e07>+=</span> <span style=color:#2aa198>16</span> <span style=color:#719e07>-</span> <span style=color:#268bd2>fls</span>(diff);
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (prefixlen <span style=color:#719e07>&gt;=</span> limit)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> limit;
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (diff)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> prefixlen;
</span></span><span style=display:flex><span>		i <span style=color:#719e07>+=</span> <span style=color:#2aa198>2</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (trie<span style=color:#719e07>-&gt;</span>data_size <span style=color:#719e07>&gt;=</span> i <span style=color:#719e07>+</span> <span style=color:#2aa198>1</span>) {
</span></span><span style=display:flex><span>		prefixlen <span style=color:#719e07>+=</span> <span style=color:#2aa198>8</span> <span style=color:#719e07>-</span> <span style=color:#268bd2>fls</span>(node<span style=color:#719e07>-&gt;</span>data[i] <span style=color:#719e07>^</span> key<span style=color:#719e07>-&gt;</span>data[i]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (prefixlen <span style=color:#719e07>&gt;=</span> limit)
</span></span><span style=display:flex><span>			<span style=color:#719e07>return</span> limit;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> prefixlen;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#586e75>/* Called from syscall or from eBPF program */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>static</span> <span style=color:#dc322f>int</span> <span style=color:#268bd2>trie_update_elem</span>(<span style=color:#719e07>struct</span> bpf_map <span style=color:#719e07>*</span>map,
</span></span><span style=display:flex><span>			    <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>_key, <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>value, u64 flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie <span style=color:#719e07>*</span>trie <span style=color:#719e07>=</span> <span style=color:#268bd2>container_of</span>(map, <span style=color:#719e07>struct</span> lpm_trie, map);
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie_node <span style=color:#719e07>*</span>node, <span style=color:#719e07>*</span>im_node <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>, <span style=color:#719e07>*</span>new_node <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie_node __rcu <span style=color:#719e07>**</span>slot;
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> bpf_lpm_trie_key <span style=color:#719e07>*</span>key <span style=color:#719e07>=</span> _key;
</span></span><span style=display:flex><span>	<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>long</span> irq_flags;
</span></span><span style=display:flex><span>	<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> next_bit;
</span></span><span style=display:flex><span>	<span style=color:#dc322f>size_t</span> matchlen <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#dc322f>int</span> ret <span style=color:#719e07>=</span> <span style=color:#2aa198>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#268bd2>unlikely</span>(flags <span style=color:#719e07>&gt;</span> BPF_EXIST))
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> <span style=color:#719e07>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (key<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>&gt;</span> trie<span style=color:#719e07>-&gt;</span>max_prefixlen) <span style=color:#586e75>//最大匹配长度校验
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>return</span> <span style=color:#719e07>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>spin_lock_irqsave</span>(<span style=color:#719e07>&amp;</span>trie<span style=color:#719e07>-&gt;</span>lock, irq_flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Allocate and fill a new node */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (trie<span style=color:#719e07>-&gt;</span>n_entries <span style=color:#719e07>==</span> trie<span style=color:#719e07>-&gt;</span>map.max_entries) {  <span style=color:#586e75>// 最大node容量校验
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		ret <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>ENOSPC;
</span></span><span style=display:flex><span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	new_node <span style=color:#719e07>=</span> <span style=color:#268bd2>lpm_trie_node_alloc</span>(trie, value); <span style=color:#586e75>// 分配新node
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>new_node) {
</span></span><span style=display:flex><span>		ret <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>ENOMEM;
</span></span><span style=display:flex><span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	trie<span style=color:#719e07>-&gt;</span>n_entries<span style=color:#719e07>++</span>;   <span style=color:#586e75>// node计数增加
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>	new_node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>=</span> key<span style=color:#719e07>-&gt;</span>prefixlen;
</span></span><span style=display:flex><span>	<span style=color:#268bd2>RCU_INIT_POINTER</span>(new_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>0</span>], <span style=color:#b58900>NULL</span>);  <span style=color:#586e75>// 初始化child指针
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>RCU_INIT_POINTER</span>(new_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>1</span>], <span style=color:#b58900>NULL</span>);
</span></span><span style=display:flex><span>	<span style=color:#268bd2>memcpy</span>(new_node<span style=color:#719e07>-&gt;</span>data, key<span style=color:#719e07>-&gt;</span>data, trie<span style=color:#719e07>-&gt;</span>data_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Now find a slot to attach the new node. To do that, walk the tree
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * from the root and match as many bits as possible for each node until
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * we either find an empty slot or a slot that needs to be replaced by
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * an intermediate node.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	slot <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>trie<span style=color:#719e07>-&gt;</span>root;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>while</span> ((node <span style=color:#719e07>=</span> <span style=color:#268bd2>rcu_dereference_protected</span>(<span style=color:#719e07>*</span>slot,
</span></span><span style=display:flex><span>					<span style=color:#268bd2>lockdep_is_held</span>(<span style=color:#719e07>&amp;</span>trie<span style=color:#719e07>-&gt;</span>lock)))) {  <span style=color:#586e75>//如果slot 非空，则将其值赋给 node，并进入循环体。
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		matchlen <span style=color:#719e07>=</span> <span style=color:#268bd2>longest_prefix_match</span>(trie, node, key);  <span style=color:#586e75>// 匹配的长度
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>!=</span> matchlen <span style=color:#719e07>||</span> <span style=color:#586e75>// 这边不相等的情况下matchlen一定比node-&gt;prefixlen小，也就是说key没有完全匹配上node，此时找到位置了，需要插在node上面
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		    node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>==</span> key<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>||</span>  <span style=color:#586e75>// 找到prefix完全匹配的节点，应该在这一层插入
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		    node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>==</span> trie<span style=color:#719e07>-&gt;</span>max_prefixlen) <span style=color:#586e75>// node已经是trie最深的叶子节点了
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			<span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		next_bit <span style=color:#719e07>=</span> <span style=color:#268bd2>extract_bit</span>(key<span style=color:#719e07>-&gt;</span>data, node<span style=color:#719e07>-&gt;</span>prefixlen);  <span style=color:#586e75>//从目标键 key 的数据中提取当前前缀长度位置的位，存储在 next_bit
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		slot <span style=color:#719e07>=</span> <span style=color:#719e07>&amp;</span>node<span style=color:#719e07>-&gt;</span>child[next_bit]; <span style=color:#586e75>//slot是当前处理的指针，根据next_bit往下遍历
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* If the slot is empty (a free child pointer or an empty root),
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * simply assign the @new_node to that slot and be done.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>node) {
</span></span><span style=display:flex><span>		<span style=color:#268bd2>rcu_assign_pointer</span>(<span style=color:#719e07>*</span>slot, new_node); <span style=color:#586e75>// 空位置则直接插入
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* If the slot we picked already exists, replace it with @new_node
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * which already has the correct data array set.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 *   下面这种情况，matchlen == 24, key-&gt;prefixlen = 24，其实就是节点的替换，刷新value
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |     new_node   |           |       (1)      |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   | 192.168.0.0/24 |           | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |    value: 3    |           |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |   [0]    [1]   |           |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+  
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |                           |   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     			  +--------------------------&gt;|
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             |       (2) node |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                  	                 | 192.168.0.0/24 | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                	                 |    value: 2    | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 |   [0]    [1]   |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>==</span> matchlen) {
</span></span><span style=display:flex><span>		new_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>0</span>] <span style=color:#719e07>=</span> node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>0</span>];
</span></span><span style=display:flex><span>		new_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>1</span>] <span style=color:#719e07>=</span> node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>1</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>(node<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>&amp;</span> LPM_TREE_NODE_FLAG_IM))
</span></span><span style=display:flex><span>			trie<span style=color:#719e07>-&gt;</span>n_entries<span style=color:#719e07>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#268bd2>rcu_assign_pointer</span>(<span style=color:#719e07>*</span>slot, new_node);
</span></span><span style=display:flex><span>		<span style=color:#268bd2>kfree_rcu</span>(node, rcu);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* If the new node matches the prefix completely, it must be inserted
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 * as an ancestor. Simply insert it between @node and *@slot.
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 *   下面这种情况，matchlen == 17, key-&gt;prefixlen == 17，node-&gt;prefixlen &gt; matchlen, 需要在node上面插入
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |       (3)  key |           |       (1)      |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   | 192.168.0.0/17 |           | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |    value: 1    |           |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |   [0]    [1]   |           |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+  
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |                           |   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     			  +--------------------------&gt;|
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             |       (2) node |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                  	                 | 192.168.0.0/24 | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                	                 |    value: 2    | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 |   [0]    [1]   |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75> 
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (matchlen <span style=color:#719e07>==</span> key<span style=color:#719e07>-&gt;</span>prefixlen) {
</span></span><span style=display:flex><span>		next_bit <span style=color:#719e07>=</span> <span style=color:#268bd2>extract_bit</span>(node<span style=color:#719e07>-&gt;</span>data, matchlen);   <span style=color:#586e75>// 上图例子：17bit是0， 所以是左孩子
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#268bd2>rcu_assign_pointer</span>(new_node<span style=color:#719e07>-&gt;</span>child[next_bit], node); <span style=color:#586e75>// node作为new_node的child
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#268bd2>rcu_assign_pointer</span>(<span style=color:#719e07>*</span>slot, new_node);
</span></span><span style=display:flex><span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#586e75>/*
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   下面这种情况，matchlen == 23, key-&gt;prefixlen == 24，node-&gt;prefixlen &gt; matchlen, 需要插imnode，matchlen作为imnode的prefixlen
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |       (3)  new |           |       (1)      |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   | 192.168.1.0/24 |           | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |    value: 1    |           |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   |   [0]    [1]   |           |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *   +----------------+           +----------------+  
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |                           |   
</span></span></span><span style=display:flex><span><span style=color:#586e75>     			  +--------------------------&gt;|
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                     	             |       (2) node |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                  	                 | 192.168.0.0/24 | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                	                 |    value: 2    | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 |   [0]    [1]   |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>     
</span></span></span><span style=display:flex><span><span style=color:#586e75>     						    ||
</span></span></span><span style=display:flex><span><span style=color:#586e75>     							||
</span></span></span><span style=display:flex><span><span style=color:#586e75>     							V
</span></span></span><span style=display:flex><span><span style=color:#586e75>                 	                 
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      |       (1)  (R) |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      | 192.168.0.0/16 |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      |    value: 1    |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                      +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                           |      
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |       (4)  (I) |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            | 192.168.0.0/23 | 
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |    value: ---  |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            |   [0]    [1]   |  
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *            +----------------+ 
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *                 |      |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  +----------------+  +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  |       (2)      |  |  (5) new, key  |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  | 192.168.0.0/24 |  | 192.168.1.0/24 |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  |    value: 2    |  |     value: 5   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  |   [0]    [1]   |  |   [0]    [1]   |
</span></span></span><span style=display:flex><span><span style=color:#586e75>     *  +----------------+  +----------------+
</span></span></span><span style=display:flex><span><span style=color:#586e75> 
</span></span></span><span style=display:flex><span><span style=color:#586e75>	 */</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>	im_node <span style=color:#719e07>=</span> <span style=color:#268bd2>lpm_trie_node_alloc</span>(trie, <span style=color:#b58900>NULL</span>); <span style=color:#586e75>// 假node，value是空
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>im_node) {
</span></span><span style=display:flex><span>		ret <span style=color:#719e07>=</span> <span style=color:#719e07>-</span>ENOMEM;
</span></span><span style=display:flex><span>		<span style=color:#719e07>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	im_node<span style=color:#719e07>-&gt;</span>prefixlen <span style=color:#719e07>=</span> matchlen;  <span style=color:#586e75>// matchlen作为imnode的prefixlen
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	im_node<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>|=</span> LPM_TREE_NODE_FLAG_IM; <span style=color:#586e75>// node标记
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>	<span style=color:#268bd2>memcpy</span>(im_node<span style=color:#719e07>-&gt;</span>data, node<span style=color:#719e07>-&gt;</span>data, trie<span style=color:#719e07>-&gt;</span>data_size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Now determine which child to install in which slot */</span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#268bd2>extract_bit</span>(key<span style=color:#719e07>-&gt;</span>data, matchlen)) {   <span style=color:#586e75>// key是newnode，所以如果1，说明new_node在im_node右孩子
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		<span style=color:#268bd2>rcu_assign_pointer</span>(im_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>0</span>], node);
</span></span><span style=display:flex><span>		<span style=color:#268bd2>rcu_assign_pointer</span>(im_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>1</span>], new_node);
</span></span><span style=display:flex><span>	} <span style=color:#719e07>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#268bd2>rcu_assign_pointer</span>(im_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>0</span>], new_node);
</span></span><span style=display:flex><span>		<span style=color:#268bd2>rcu_assign_pointer</span>(im_node<span style=color:#719e07>-&gt;</span>child[<span style=color:#2aa198>1</span>], node);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Finally, assign the intermediate node to the determined spot */</span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>rcu_assign_pointer</span>(<span style=color:#719e07>*</span>slot, im_node);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>out:
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (ret) {
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (new_node)
</span></span><span style=display:flex><span>			trie<span style=color:#719e07>-&gt;</span>n_entries<span style=color:#719e07>--</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#268bd2>kfree</span>(new_node);
</span></span><span style=display:flex><span>		<span style=color:#268bd2>kfree</span>(im_node);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#268bd2>spin_unlock_irqrestore</span>(<span style=color:#719e07>&amp;</span>trie<span style=color:#719e07>-&gt;</span>lock, irq_flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=查询流程>查询流程</h5><div class=highlight><pre tabindex=0 style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#586e75>/* Called from syscall or from eBPF program */</span>
</span></span><span style=display:flex><span><span style=color:#719e07>static</span> <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span><span style=color:#268bd2>trie_lookup_elem</span>(<span style=color:#719e07>struct</span> bpf_map <span style=color:#719e07>*</span>map, <span style=color:#dc322f>void</span> <span style=color:#719e07>*</span>_key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie <span style=color:#719e07>*</span>trie <span style=color:#719e07>=</span> <span style=color:#268bd2>container_of</span>(map, <span style=color:#719e07>struct</span> lpm_trie, map);
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> lpm_trie_node <span style=color:#719e07>*</span>node, <span style=color:#719e07>*</span>found <span style=color:#719e07>=</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>	<span style=color:#719e07>struct</span> bpf_lpm_trie_key <span style=color:#719e07>*</span>key <span style=color:#719e07>=</span> _key;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#586e75>/* Start walking the trie from the root node ... */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>for</span> (node <span style=color:#719e07>=</span> <span style=color:#268bd2>rcu_dereference</span>(trie<span style=color:#719e07>-&gt;</span>root); node;) {
</span></span><span style=display:flex><span>		<span style=color:#dc322f>unsigned</span> <span style=color:#dc322f>int</span> next_bit;
</span></span><span style=display:flex><span>		<span style=color:#dc322f>size_t</span> matchlen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#586e75>/* Determine the longest prefix of @node that matches @key.
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * If it&#39;s the maximum possible prefix for this trie, we have
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * an exact match and can return it directly.
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 */</span>
</span></span><span style=display:flex><span>		matchlen <span style=color:#719e07>=</span> <span style=color:#268bd2>longest_prefix_match</span>(trie, node, key);
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (matchlen <span style=color:#719e07>==</span> trie<span style=color:#719e07>-&gt;</span>max_prefixlen) { <span style=color:#586e75>// 到底了，直接返回
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			found <span style=color:#719e07>=</span> node;
</span></span><span style=display:flex><span>			<span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#586e75>/* If the number of bits that match is smaller than the prefix
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * length of @node, bail out and return the node we have seen
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * last in the traversal (ie, the parent).
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 */</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (matchlen <span style=color:#719e07>&lt;</span> node<span style=color:#719e07>-&gt;</span>prefixlen) <span style=color:#586e75>// 没有完全匹配，那就找到最长匹配了，但是是上一个
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			<span style=color:#719e07>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#586e75>/* Consider this node as return candidate unless it is an
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * artificially added intermediate one.
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 */</span>
</span></span><span style=display:flex><span>		<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>(node<span style=color:#719e07>-&gt;</span>flags <span style=color:#719e07>&amp;</span> LPM_TREE_NODE_FLAG_IM)) <span style=color:#586e75>// 不是假node才算找到
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>			found <span style=color:#719e07>=</span> node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#586e75>/* If the node match is fully satisfied, let&#39;s see if we can
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * become more specific. Determine the next bit in the key and
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 * traverse down.
</span></span></span><span style=display:flex><span><span style=color:#586e75>		 */</span>
</span></span><span style=display:flex><span>		next_bit <span style=color:#719e07>=</span> <span style=color:#268bd2>extract_bit</span>(key<span style=color:#719e07>-&gt;</span>data, node<span style=color:#719e07>-&gt;</span>prefixlen); <span style=color:#586e75>//完全匹配了，那就继续往下走继续匹配
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>		node <span style=color:#719e07>=</span> <span style=color:#268bd2>rcu_dereference</span>(node<span style=color:#719e07>-&gt;</span>child[next_bit]);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>if</span> (<span style=color:#719e07>!</span>found)
</span></span><span style=display:flex><span>		<span style=color:#719e07>return</span> <span style=color:#b58900>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#719e07>return</span> found<span style=color:#719e07>-&gt;</span>data <span style=color:#719e07>+</span> trie<span style=color:#719e07>-&gt;</span>data_size;  <span style=color:#586e75>// value在data_size后面
</span></span></span><span style=display:flex><span><span style=color:#586e75></span>}
</span></span></code></pre></div></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>windseek</span></span>
<time>Mar 6, 2025</time>
<span class=categories>Tags:
<a class=category href=https://scottlx.github.io/tags/ebpf>ebpf</a> <a class=category href=https://scottlx.github.io/tags/cilium>cilium</a> <a class=category href=https://scottlx.github.io/tags/k8s>k8s</a></span></p><p class=meta><a class="basic-alignment left" href=https://scottlx.github.io/posts/cilium-datapath/ title="cilium datapath">cilium datapath</a></p><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//scottlx.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><h1>Who am I</h1><p><p>云原生网络开发 &ndash;> 高级网管(笑</p><p>golang、云计算、SDN、NFV、软件架构</p><p>记录一些工作上的笔记，主要是以太网数据面开发（包括不限于dpdk，ebpf，ovs，dpvs，vpp&mldr;)以及k8s</p><p>也会记录一些web3方面的学习探索</p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/scottlx title=https://github.com/scottlx><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href="https://www.facebook.com/profile.php?id=100009824623685" title="https://www.facebook.com/profile.php?id=100009824623685"><i class="fa fa-facebook fa-3x"></i></a></li></ul><section class=even><h1>Recent Posts</h1><ul id=recent_posts></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2025 windseek - <a href=https://scottlx.github.io/license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>